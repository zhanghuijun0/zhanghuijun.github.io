<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>UNIX-TOOLBOX中文版 | Hexo Blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UNIX-TOOLBOX中文版</h1><a id="logo" href="/.">Hexo Blogs</a><p class="description">小小码农</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UNIX-TOOLBOX中文版</h1><div class="post-meta">Nov 29, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#系统"><span class="toc-number">1.</span> <span class="toc-text">系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#硬件信息"><span class="toc-number">1.1.</span> <span class="toc-text">硬件信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#显示状态信息"><span class="toc-number">1.2.</span> <span class="toc-text">显示状态信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户"><span class="toc-number">1.3.</span> <span class="toc-text">用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#限制"><span class="toc-number">1.4.</span> <span class="toc-text">限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行级别"><span class="toc-number">1.5.</span> <span class="toc-text">运行级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重设-root-密码"><span class="toc-number">1.6.</span> <span class="toc-text">重设 root 密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核模块"><span class="toc-number">1.7.</span> <span class="toc-text">内核模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译内核"><span class="toc-number">1.8.</span> <span class="toc-text">编译内核</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程"><span class="toc-number">2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程列表"><span class="toc-number">2.1.</span> <span class="toc-text">进程列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先级"><span class="toc-number">2.2.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前台-后台"><span class="toc-number">2.3.</span> <span class="toc-text">前台/后台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Top"><span class="toc-number">2.4.</span> <span class="toc-text">Top</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kill命令与信号"><span class="toc-number">2.5.</span> <span class="toc-text">Kill命令与信号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件系统"><span class="toc-number">3.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#权限"><span class="toc-number">3.1.</span> <span class="toc-text">权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘信息"><span class="toc-number">3.2.</span> <span class="toc-text">磁盘信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boot"><span class="toc-number">3.3.</span> <span class="toc-text">Boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谁打开了那些文件"><span class="toc-number">3.4.</span> <span class="toc-text">谁打开了那些文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载-重挂载一个文件系统"><span class="toc-number">3.5.</span> <span class="toc-text">挂载/重挂载一个文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#给即时烧录-on-the-fly-添加-swap"><span class="toc-number">3.6.</span> <span class="toc-text">给即时烧录(on-the-fly)添加 swap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载一个-SMB-共享"><span class="toc-number">3.7.</span> <span class="toc-text">挂载一个 SMB 共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂载镜像文件"><span class="toc-number">3.8.</span> <span class="toc-text">挂载镜像文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建并刻录-ISO-镜像文件"><span class="toc-number">3.9.</span> <span class="toc-text">创建并刻录 ISO 镜像文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建基于文件的镜像文件"><span class="toc-number">3.10.</span> <span class="toc-text">创建基于文件的镜像文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建基于内存的文件系统"><span class="toc-number">3.11.</span> <span class="toc-text">创建基于内存的文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘性能"><span class="toc-number">3.12.</span> <span class="toc-text">磁盘性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络"><span class="toc-number">4.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#路由"><span class="toc-number">4.1.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置额外的-IP-地址"><span class="toc-number">4.2.</span> <span class="toc-text">配置额外的 IP 地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ndd-set-dev-ip-ip-forwarding-1-查看-IP-转发-0-禁用-1-启用"><span class="toc-number">5.</span> <span class="toc-text">ndd -set /dev/ip ip_forwarding 1       # 查看 IP 转发 0=禁用, 1=启用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hostname-d-等同于-dnsdomainname"><span class="toc-number">6.</span> <span class="toc-text">hostname -d                        # 等同于 dnsdomainname</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dig-x-78-31-70-238"><span class="toc-number">7.</span> <span class="toc-text">dig -x 78.31.70.238</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#host-78-31-70-238"><span class="toc-number">8.</span> <span class="toc-text">host 78.31.70.238</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nslookup-78-31-70-238"><span class="toc-number">9.</span> <span class="toc-text">nslookup 78.31.70.238</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dhcpcd-n-eth0-触发更新-并不总是可以工作"><span class="toc-number">10.</span> <span class="toc-text">dhcpcd -n eth0           # 触发更新(并不总是可以工作)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dhcpcd-k-eth0-释放并关闭"><span class="toc-number">11.</span> <span class="toc-text">dhcpcd -k eth0           # 释放并关闭</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dhclient-bge0"><span class="toc-number">12.</span> <span class="toc-text">dhclient bge0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-etc-dhclient-conf"><span class="toc-number">13.</span> <span class="toc-text">cat /etc/dhclient.conf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipconfig-renew-更新所有适配器"><span class="toc-number">14.</span> <span class="toc-text">ipconfig /renew          # 更新所有适配器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipconfig-renew-LAN-更新名叫-“LAN”-的适配器"><span class="toc-number">15.</span> <span class="toc-text">ipconfig /renew LAN      # 更新名叫 “LAN” 的适配器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipconfig-release-WLAN-释放名叫-“WLAN”-的适配器"><span class="toc-number">16.</span> <span class="toc-text">ipconfig /release WLAN   # 释放名叫 “WLAN” 的适配器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-nl-i-bge0-not-port-ssh-and-src-192-168-16-121-or-192-168-16-54"><span class="toc-number">17.</span> <span class="toc-text">tcpdump -nl -i bge0 not port ssh and src (192.168.16.121 or 192.168.16.54)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-l-gt-dump-amp-amp-tail-f-dump-缓冲输出"><span class="toc-number">18.</span> <span class="toc-text">tcpdump -l > dump && tail -f dump               # 缓冲输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-i-rl0-w-traffic-rl0-把数据报文写入二进制文件"><span class="toc-number">19.</span> <span class="toc-text">tcpdump -i rl0 -w traffic.rl0                   # 把数据报文写入二进制文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-r-traffic-rl0-从文件读取数据报文-也可以使用-ethereal"><span class="toc-number">20.</span> <span class="toc-text">tcpdump -r traffic.rl0                          # 从文件读取数据报文(也可以使用 ethereal)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-port-80-两个经典命令"><span class="toc-number">21.</span> <span class="toc-text">tcpdump port 80                                 # 两个经典命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-host-google-com"><span class="toc-number">22.</span> <span class="toc-text">tcpdump host google.com</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-i-eth0-X-port-110-or-143-查看端口-110-POP-或-143-IMAP-的数据报文"><span class="toc-number">23.</span> <span class="toc-text">tcpdump -i eth0 -X port (110 or 143)          # 查看端口 110(POP) 或 143(IMAP)的数据报文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-n-i-eth0-icmp-只捕获-ping"><span class="toc-number">24.</span> <span class="toc-text">tcpdump -n -i eth0 icmp                         # 只捕获 ping</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpdump-i-eth0-s-0-A-port-80-grep-GET-s-0-为全部包-A-为-ASCII"><span class="toc-number">25.</span> <span class="toc-text">tcpdump -i eth0 -s 0 -A port 80 | grep GET      # -s 0 为全部包, -A 为 ASCII</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nmap-cb-vu-扫描主机上所有保留的-TCP-端口"><span class="toc-number">26.</span> <span class="toc-text">nmap cb.vu               # 扫描主机上所有保留的 TCP 端口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nmap-sP-192-168-16-0-24-找出在-0-24-上主机所使用的-IP"><span class="toc-number">27.</span> <span class="toc-text">nmap -sP 192.168.16.0/24 # 找出在 0/24 上主机所使用的 IP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nmap-sS-sV-O-cb-vu-做秘密-SYN-扫描来探测系统和系统服务的版本信息"><span class="toc-number">28.</span> <span class="toc-text">nmap -sS -sV -O cb.vu    # 做秘密 SYN 扫描来探测系统和系统服务的版本信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-add-dev-eth0-root-tbf-rate-480kbit-latency-50ms-burst-1540"><span class="toc-number">29.</span> <span class="toc-text">tc qdisc add dev eth0 root tbf rate 480kbit latency 50ms burst 1540</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-s-qdisc-ls-dev-eth0-状态"><span class="toc-number">30.</span> <span class="toc-text">tc -s qdisc ls dev eth0                         # 状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-del-dev-eth0-root-删除队列"><span class="toc-number">31.</span> <span class="toc-text">tc qdisc del dev eth0 root                      # 删除队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-change-dev-eth0-root-tbf-rate-220kbit-latency-50ms-burst-1540"><span class="toc-number">32.</span> <span class="toc-text">tc qdisc change dev eth0 root tbf rate 220kbit latency 50ms burst 1540</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kldload-dummynet-如有必要加载这个模块"><span class="toc-number">33.</span> <span class="toc-text">kldload dummynet                                # 如有必要加载这个模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-pipe-1-config-bw-500Kbit-s-创建一个带宽限制的-pipe"><span class="toc-number">34.</span> <span class="toc-text">ipfw pipe 1 config bw 500Kbit/s                 # 创建一个带宽限制的 pipe</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-add-pipe-1-ip-from-me-to-any-转移所有上传进入这个-pipe"><span class="toc-number">35.</span> <span class="toc-text">ipfw add pipe 1 ip from me to any               # 转移所有上传进入这个 pipe</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-add-dev-eth0-root-handle-1-prio-priomap-2-2-2-2-2-2-2-2-1-1-1-1-1-1-1-0"><span class="toc-number">36.</span> <span class="toc-text">tc qdisc add dev eth0 root handle 1: prio priomap 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-add-dev-eth0-parent-1-1-handle-10-sfq"><span class="toc-number">37.</span> <span class="toc-text">tc qdisc add dev eth0 parent 1:1 handle 10: sfq</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-add-dev-eth0-parent-1-2-handle-20-sfq"><span class="toc-number">38.</span> <span class="toc-text">tc qdisc add dev eth0 parent 1:2 handle 20: sfq</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-add-dev-eth0-parent-1-3-handle-30-sfq"><span class="toc-number">39.</span> <span class="toc-text">tc qdisc add dev eth0 parent 1:3 handle 30: sfq</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-filter-add-dev-eth0-protocol-ip-parent-1-prio-1-u32"><span class="toc-number">40.</span> <span class="toc-text">tc filter add dev eth0 protocol ip parent 1: prio 1 u32 \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-s-qdisc-ls-dev-eth0-queue-status"><span class="toc-number">41.</span> <span class="toc-text">tc -s qdisc ls dev eth0                         # queue status</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tc-qdisc-del-dev-eth0-root-delete-all-QoS"><span class="toc-number">42.</span> <span class="toc-text">tc qdisc del dev eth0 root                      # delete all QoS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-13-8192-lt-10000-lt-2-14-16384-结尾是-2-14-16384"><span class="toc-number">43.</span> <span class="toc-text">2^13 (8192) < 10000 < 2^14 (16384)              # 结尾是 2^14 = 16384</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#echo-“obase-16-2-14-1024”-bc-掩码是-0x3C00"><span class="toc-number">44.</span> <span class="toc-text">echo “obase=16;(2^14)-1024” | bc                # 掩码是 0x3C00</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-pipe-1-config-bw-500Kbit-s"><span class="toc-number">45.</span> <span class="toc-text">ipfw pipe 1 config bw 500Kbit/s</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-queue-1-config-pipe-1-weight-100"><span class="toc-number">46.</span> <span class="toc-text">ipfw queue 1 config pipe 1 weight 100</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-queue-2-config-pipe-1-weight-10"><span class="toc-number">47.</span> <span class="toc-text">ipfw queue 2 config pipe 1 weight 10</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-queue-3-config-pipe-1-weight-1"><span class="toc-number">48.</span> <span class="toc-text">ipfw queue 3 config pipe 1 weight 1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-add-10-queue-1-proto-udp-dst-port-10000-11024"><span class="toc-number">49.</span> <span class="toc-text">ipfw add 10 queue 1 proto udp dst-port 10000-11024</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-add-11-queue-1-proto-udp-dst-ip-123-23-0-1-或-和使用服务器-IP"><span class="toc-number">50.</span> <span class="toc-text">ipfw add 11 queue 1 proto udp dst-ip 123.23.0.1 # 或/和使用服务器 IP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-add-20-queue-2-dsp-port-ssh"><span class="toc-number">51.</span> <span class="toc-text">ipfw add 20 queue 2 dsp-port ssh</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-add-30-queue-3-from-me-to-any-剩余所有"><span class="toc-number">52.</span> <span class="toc-text">ipfw add 30 queue 3 from me to any              # 剩余所有</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-list-规则信息"><span class="toc-number">53.</span> <span class="toc-text">ipfw list                                       # 规则信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-pipe-list-管道信息"><span class="toc-number">54.</span> <span class="toc-text">ipfw pipe list                                  # 管道信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipfw-flush-删除除默认外所有规则"><span class="toc-number">55.</span> <span class="toc-text">ipfw flush                                      # 删除除默认外所有规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ypwhich-获取提供-NIS-服务的服务器名"><span class="toc-number">56.</span> <span class="toc-text">ypwhich                  # 获取提供 NIS 服务的服务器名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#domainname-已配置的-NIS-域名"><span class="toc-number">57.</span> <span class="toc-text">domainname               # 已配置的 NIS 域名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ypcat-group-列印-NIS-映射-group"><span class="toc-number">58.</span> <span class="toc-text">ypcat group              # 列印 NIS 映射 group</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-var-yp-amp-amp-make-重建-yp-数据库"><span class="toc-number">59.</span> <span class="toc-text">cd /var/yp && make       # 重建 yp 数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ps-auxww-grep-ypbind"><span class="toc-number">60.</span> <span class="toc-text">ps auxww | grep ypbind</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#yppoll-passwd-byname"><span class="toc-number">61.</span> <span class="toc-text">yppoll passwd.byname</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-etc-yp-conf"><span class="toc-number">62.</span> <span class="toc-text">cat /etc/yp.conf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-t-dsa-N-‘’"><span class="toc-number">63.</span> <span class="toc-text">ssh-keygen -t dsa -N ‘’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-ssh-id-dsa-pub-ssh-you-host-server-“cat-gt-gt-ssh-authorized-keys2”"><span class="toc-number">64.</span> <span class="toc-text">cat ~/.ssh/id_dsa.pub | ssh you@host-server “cat - >> ~/.ssh/authorized_keys2”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-ssh"><span class="toc-number">65.</span> <span class="toc-text">cd ~/.ssh</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-i-f-keyfilename-pub-gt-gt-authorized-keys2"><span class="toc-number">66.</span> <span class="toc-text">ssh-keygen -i -f keyfilename.pub >> authorized_keys2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scp-ssh-puttykey-pub-root-192-168-51-254-ssh"><span class="toc-number">67.</span> <span class="toc-text">scp .ssh/puttykey.pub root@192.168.51.254:.ssh/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-ssh-1"><span class="toc-number">68.</span> <span class="toc-text">cd ~/.ssh</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-i-f-puttykey-pub-gt-gt-authorized-keys2"><span class="toc-number">69.</span> <span class="toc-text">ssh-keygen -i -f puttykey.pub >> authorized_keys2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-l-f-etc-ssh-ssh-host-rsa-key-pub-RSA-密钥"><span class="toc-number">70.</span> <span class="toc-text">ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub      # RSA 密钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-l-f-etc-ssh-ssh-host-dsa-key-pub-DSA-密钥-默认"><span class="toc-number">71.</span> <span class="toc-text">ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub      # DSA 密钥(默认)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-linda"><span class="toc-number">72.</span> <span class="toc-text">ssh linda</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scp-file-txt-host-two-tmp"><span class="toc-number">73.</span> <span class="toc-text">scp file.txt host-two:/tmp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scp-joe-host-two-www-html-www-tmp"><span class="toc-number">74.</span> <span class="toc-text">scp joe@host-two:/www/*.html /www/tmp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scp-r-joe-host-two-www-www-tmp"><span class="toc-number">75.</span> <span class="toc-text">scp -r joe@host-two:/www /www/tmp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L-localport-desthost-destport-user-gate-gate-为目标主机网关"><span class="toc-number">76.</span> <span class="toc-text">ssh -L localport:desthost:destport user@gate  # gate 为目标主机网关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-R-destport-desthost-localport-user-gate-转发你的-localport-到目标端口"><span class="toc-number">77.</span> <span class="toc-text">ssh -R destport:desthost:localport user@gate  # 转发你的 localport 到目标端口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-X-user-gate-转发-X-程序"><span class="toc-number">78.</span> <span class="toc-text">ssh -X user@gate   # 转发 X 程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L-2401-localhost-2401-L-8080-localhost-80-user-gate"><span class="toc-number">79.</span> <span class="toc-text">ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L-139-smbserver-139-L-3388-smbserver-3389-user-gate"><span class="toc-number">80.</span> <span class="toc-text">ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统-gt-控制面板-gt-添加硬件-是，我已经连接了此硬件-Y-添加新的硬件设备-在列表最下面-。"><span class="toc-number">81.</span> <span class="toc-text">系统->控制面板->添加硬件 # 是，我已经连接了此硬件(Y) # 添加新的硬件设备(在列表最下面)。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安装我手动选择的硬件-网络适配器-Microsoft-Microsoft-Loopback-Adapter。"><span class="toc-number">82.</span> <span class="toc-text">安装我手动选择的硬件 # 网络适配器 # Microsoft , Microsoft Loopback Adapter。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#启用-Microsoft-网络客户端。-禁用-Microsoft-网络文件和打印机共享"><span class="toc-number">83.</span> <span class="toc-text">启用 Microsoft 网络客户端。# 禁用 Microsoft 网络文件和打印机共享</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-R-2022-localhost-22-user-gate-转发客户端-22-端口到-gate-2022-端口"><span class="toc-number">84.</span> <span class="toc-text">ssh -R 2022:localhost:22 user@gate            # 转发客户端 22 端口到 gate:2022 端口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L-3022-localhost-2022-admin-gate-转发客户端-3022-端口到-gate-2022-端口"><span class="toc-number">85.</span> <span class="toc-text">ssh -L 3022:localhost:2022 admin@gate         # 转发客户端 3022 端口到 gate:2022 端口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-p-3022-admin-localhost-local-3022-gt-gate-2022-gt-client-22"><span class="toc-number">86.</span> <span class="toc-text">ssh -p 3022 admin@localhost                   # local:3022 -> gate:2022 -> client:22</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-R-15900-localhost-5900-user-gate"><span class="toc-number">87.</span> <span class="toc-text">ssh -R 15900:localhost:5900 user@gate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L-5900-localhost-15900-admin-gate"><span class="toc-number">88.</span> <span class="toc-text">ssh -L 5900:localhost:15900 admin@gate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vncconnect-display-0-localhost"><span class="toc-number">89.</span> <span class="toc-text">vncconnect -display :0 localhost</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-a-home-colin-backup-colin"><span class="toc-number">90.</span> <span class="toc-text">rsync -a /home/colin/ /backup/colin/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-a-var-var-bak"><span class="toc-number">91.</span> <span class="toc-text">rsync -a /var/ /var_bak/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-aR-–delete-during-home-user-backup-使用相对路径-看下面"><span class="toc-number">92.</span> <span class="toc-text">rsync -aR –delete-during /home/user/ /backup/      # 使用相对路径(看下面)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-axSRzv-home-user-user-server-backup-user"><span class="toc-number">93.</span> <span class="toc-text">rsync -axSRzv /home/user/ user@server:/backup/user/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-azR-–exclude-tmp-home-user-user-server-backup"><span class="toc-number">94.</span> <span class="toc-text">rsync -azR –exclude /tmp/ /home/user/ user@server:/backup/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-az-e-‘ssh-p-20022’-home-colin-user-server-backup-colin"><span class="toc-number">95.</span> <span class="toc-text">rsync -az -e ‘ssh -p 20022’ /home/colin/ user@server:/backup/colin/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-axSRz-home-ruser-hostname-rmodule-backup"><span class="toc-number">96.</span> <span class="toc-text">rsync -axSRz /home/ ruser@hostname::rmodule/backup/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-axSRz-ruser-hostname-rmodule-backup-home-回拷贝"><span class="toc-number">97.</span> <span class="toc-text">rsync -axSRz ruser@hostname::rmodule/backup/ /home/    # 回拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-t-dsa-N-‘’-创建密钥对"><span class="toc-number">98.</span> <span class="toc-text">ssh-keygen -t dsa -N ‘’                   # 创建密钥对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-user-server-ssh-authorized-keys2-从服务器拷贝本地文件"><span class="toc-number">99.</span> <span class="toc-text">rsync user@server:.ssh/authorized_keys2 . # 从服务器拷贝本地文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-id-dsa-pub-gt-gt-authorized-keys2-或者使用编辑器添加这个公钥"><span class="toc-number">100.</span> <span class="toc-text">cat id_dsa.pub >> authorized_keys2        # 或者使用编辑器添加这个公钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-authorized-keys2-user-server-ssh-拷贝文件回服务器"><span class="toc-number">101.</span> <span class="toc-text">rsync authorized_keys2 user@server:.ssh/  # 拷贝文件回服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#del-authorized-keys2-删除本地拷贝"><span class="toc-number">102.</span> <span class="toc-text">del authorized_keys2                      # 删除本地拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sudo-etc-init-d-dhcpd-restart-用-root-权限运行-rc-脚本"><span class="toc-number">103.</span> <span class="toc-text">sudo /etc/init.d/dhcpd restart            # 用 root 权限运行 rc 脚本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sudo-u-sysadmin-whoami-使用其他用户运行命令"><span class="toc-number">104.</span> <span class="toc-text">sudo -u sysadmin whoami                   # 使用其他用户运行命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-etc-sudoers"><span class="toc-number">105.</span> <span class="toc-text">cat /etc/sudoers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#主机别名"><span class="toc-number">106.</span> <span class="toc-text">主机别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用户别名-和-runas-别名"><span class="toc-number">107.</span> <span class="toc-text">用户别名 和 runas 别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命令别名，其值为全路径命令"><span class="toc-number">108.</span> <span class="toc-text">命令别名，其值为全路径命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一个真实的规则"><span class="toc-number">109.</span> <span class="toc-text">一个真实的规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用户-sysadmin-可以在-DMZ-服务器上执行一些命令"><span class="toc-number">110.</span> <span class="toc-text">用户 sysadmin 可以在 DMZ 服务器上执行一些命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#所有用户可以在-DESKTOP-别名的主机上-挂载-卸载-CD-ROM"><span class="toc-number">111.</span> <span class="toc-text">所有用户可以在 DESKTOP 别名的主机上 挂载/卸载 CD-ROM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-des-salt-in-file-out-file-des"><span class="toc-number">112.</span> <span class="toc-text">openssl des -salt -in file -out file.des</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-des-d-salt-in-file-des-out-file"><span class="toc-number">113.</span> <span class="toc-text">openssl des -d -salt -in file.des -out file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-cf-directory-openssl-des-salt-out-directory-tar-des-加密"><span class="toc-number">114.</span> <span class="toc-text">tar -cf - directory | openssl des -salt -out directory.tar.des      # 加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-des-d-salt-in-directory-tar-des-tar-x-解密"><span class="toc-number">115.</span> <span class="toc-text">openssl des -d -salt -in directory.tar.des | tar -x                 # 解密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-zcf-directory-openssl-des-salt-out-directory-tar-gz-des-加密"><span class="toc-number">116.</span> <span class="toc-text">tar -zcf - directory | openssl des -salt -out directory.tar.gz.des  # 加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-des-d-salt-in-directory-tar-gz-des-tar-xz-解密"><span class="toc-number">117.</span> <span class="toc-text">openssl des -d -salt -in directory.tar.gz.des | tar -xz             # 解密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-c-file-使用密码加密文件"><span class="toc-number">118.</span> <span class="toc-text">gpg -c file                        # 使用密码加密文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-file-gpg-文件解密-选项-o-其他文件"><span class="toc-number">119.</span> <span class="toc-text">gpg file.gpg                       # 文件解密(选项 -o 其他文件)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–gen-key-这需要一些时间"><span class="toc-number">120.</span> <span class="toc-text">gpg –gen-key                      # 这需要一些时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-e-r-‘Your-Name’-file-使用你的公钥加密"><span class="toc-number">121.</span> <span class="toc-text">gpg -e -r ‘Your Name’ file                  # 使用你的公钥加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-o-file-d-file-gpg-解密。使用-o-指定输出文件"><span class="toc-number">122.</span> <span class="toc-text">gpg -o file -d file.gpg                     # 解密。使用 -o 指定输出文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-a-o-alicekey-asc-–export-‘Alice’-Alice-导出她的公钥到-ascii-文件中"><span class="toc-number">123.</span> <span class="toc-text">gpg -a -o alicekey.asc –export ‘Alice’               # Alice 导出她的公钥到 ascii 文件中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–send-keys-–keyserver-subkeys-pgp-net-KEYID-Alice-把她的公钥放入一个服务器"><span class="toc-number">124.</span> <span class="toc-text">gpg –send-keys –keyserver subkeys.pgp.net KEYID     # Alice 把她的公钥放入一个服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–import-alicekey-asc-你导入她的密钥到你的公钥环-pubring-中"><span class="toc-number">125.</span> <span class="toc-text">gpg –import alicekey.asc                             # 你导入她的密钥到你的公钥环(pubring)中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–search-keys-–keyserver-subkeys-pgp-net-‘Alice’-或者从一个服务器中获取他的公钥"><span class="toc-number">126.</span> <span class="toc-text">gpg –search-keys –keyserver subkeys.pgp.net ‘Alice’ # 或者从一个服务器中获取他的公钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-e-r-‘Alice’-file-给-Alice-加密文件"><span class="toc-number">127.</span> <span class="toc-text">gpg -e -r ‘Alice’ file                      # 给 Alice 加密文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-d-file-gpg-o-file-解密-Alice-给你的加密文件"><span class="toc-number">128.</span> <span class="toc-text">gpg -d file.gpg -o file                     # 解密 Alice 给你的加密文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–list-keys-列出所有公钥并查看其-KEYID"><span class="toc-number">129.</span> <span class="toc-text">gpg –list-keys                             # 列出所有公钥并查看其 KEYID</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–gen-revoke-‘Your-Name’-产生一份撤销密钥证书"><span class="toc-number">130.</span> <span class="toc-text">gpg –gen-revoke ‘Your Name’                # 产生一份撤销密钥证书</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–list-secret-keys-列出所有私钥"><span class="toc-number">131.</span> <span class="toc-text">gpg –list-secret-keys                      # 列出所有私钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–delete-keys-NAME-从本的密钥环中删除一个公钥"><span class="toc-number">132.</span> <span class="toc-text">gpg –delete-keys NAME                      # 从本的密钥环中删除一个公钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–delete-secret-key-NAME-从本的密钥环中删除一个私钥"><span class="toc-number">133.</span> <span class="toc-text">gpg –delete-secret-key NAME                # 从本的密钥环中删除一个私钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–fingerprint-KEYID-显示-KIYID-这个密钥的指纹"><span class="toc-number">134.</span> <span class="toc-text">gpg –fingerprint KEYID                     # 显示 KIYID 这个密钥的指纹</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gpg-–edit-key-KEYID-编辑密钥-比如签名或者添加-删除-email"><span class="toc-number">135.</span> <span class="toc-text">gpg –edit-key KEYID                        # 编辑密钥(比如签名或者添加/删除 email)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-urandom-of-dev-sdc1-可选"><span class="toc-number">136.</span> <span class="toc-text">dd if=/dev/urandom of=/dev/sdc1          # 可选</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-y-luksFormat-dev-sdc1-这破坏了在-sdc1-上的数据"><span class="toc-number">137.</span> <span class="toc-text">cryptsetup -y luksFormat /dev/sdc1       # 这破坏了在 sdc1 上的数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-luksOpen-dev-sdc1-sdc1"><span class="toc-number">138.</span> <span class="toc-text">cryptsetup luksOpen /dev/sdc1 sdc1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkfs-ext3-dev-mapper-sdc1-创建-ext3-文件系统"><span class="toc-number">139.</span> <span class="toc-text">mkfs.ext3 /dev/mapper/sdc1               # 创建 ext3 文件系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-t-ext3-dev-mapper-sdc1-mnt"><span class="toc-number">140.</span> <span class="toc-text">mount -t ext3 /dev/mapper/sdc1 /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#umount-mnt"><span class="toc-number">141.</span> <span class="toc-text">umount /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-luksClose-sdc1-Detach-已加密的分区"><span class="toc-number">142.</span> <span class="toc-text">cryptsetup luksClose sdc1                # Detach 已加密的分区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-luksOpen-dev-sdc1-sdc1-1"><span class="toc-number">143.</span> <span class="toc-text">cryptsetup luksOpen /dev/sdc1 sdc1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-t-ext3-dev-mapper-sdc1-mnt-1"><span class="toc-number">144.</span> <span class="toc-text">mount -t ext3 /dev/mapper/sdc1 /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#umount-mnt-1"><span class="toc-number">145.</span> <span class="toc-text">umount /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-luksClose-sdc1"><span class="toc-number">146.</span> <span class="toc-text">cryptsetup luksClose sdc1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-y-create-sdc1-dev-sdc1-或任何其他分区像-dev-loop0"><span class="toc-number">147.</span> <span class="toc-text">cryptsetup -y create sdc1 /dev/sdc1      # 或任何其他分区像 /dev/loop0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dmsetup-ls-检查一下，将显示：sdc1-254-0"><span class="toc-number">148.</span> <span class="toc-text">dmsetup ls                               # 检查一下，将显示：sdc1 (254, 0)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkfs-ext3-dev-mapper-sdc1-只有第一次要这么做！"><span class="toc-number">149.</span> <span class="toc-text">mkfs.ext3 /dev/mapper/sdc1               # 只有第一次要这么做！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-t-ext3-dev-mapper-sdc1-mnt-2"><span class="toc-number">150.</span> <span class="toc-text">mount -t ext3 /dev/mapper/sdc1 /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#umount-mnt-2"><span class="toc-number">151.</span> <span class="toc-text">umount /mnt/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cryptsetup-remove-sdc1-Detach-已加密的分区"><span class="toc-number">152.</span> <span class="toc-text">cryptsetup remove sdc1                   # Detach 已加密的分区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#echo-‘geom-eli-load-”YES”‘-gt-gt-boot-loader-conf-也可以在系统引导时加载或者做：kldload-geom-eli"><span class="toc-number">153.</span> <span class="toc-text">echo ‘geom_eli_load=”YES”‘ >> /boot/loader.conf   # 也可以在系统引导时加载或者做：kldload geom_eli</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-random-of-root-ad1-key-bs-64-count-1-加密主密钥的密钥"><span class="toc-number">154.</span> <span class="toc-text">dd if=/dev/random of=/root/ad1.key bs=64 count=1  # 加密主密钥的密钥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-init-s-4096-K-root-ad1-key-dev-ad1-对于磁盘也可用-s-8192"><span class="toc-number">155.</span> <span class="toc-text">geli init -s 4096 -K /root/ad1.key /dev/ad1       # 对于磁盘也可用 -s 8192</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-attach-k-root-ad1-key-dev-ad1-将-dev-ad1-与所生成的密钥-root-ad1-key-关联"><span class="toc-number">156.</span> <span class="toc-text">geli attach -k /root/ad1.key /dev/ad1             # 将 /dev/ad1 与所生成的密钥 /root/ad1.key 关联</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-random-of-dev-ad1-eli-bs-1m-可选，需要很长时间"><span class="toc-number">157.</span> <span class="toc-text">dd if=/dev/random of=/dev/ad1.eli bs=1m           # 可选，需要很长时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#newfs-dev-ad1-eli-创建文件系统"><span class="toc-number">158.</span> <span class="toc-text">newfs /dev/ad1.eli                                # 创建文件系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-dev-ad1-eli-mnt"><span class="toc-number">159.</span> <span class="toc-text">mount /dev/ad1.eli /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-attach-k-root-ad1-key-dev-ad1"><span class="toc-number">160.</span> <span class="toc-text">geli attach -k /root/ad1.key /dev/ad1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fsck-ny-t-ffs-dev-ad1-eli-检查文件系统"><span class="toc-number">161.</span> <span class="toc-text">fsck -ny -t ffs /dev/ad1.eli                      # 检查文件系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-dev-ad1-eli-mnt-1"><span class="toc-number">162.</span> <span class="toc-text">mount /dev/ad1.eli /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#umount-mnt-3"><span class="toc-number">163.</span> <span class="toc-text">umount /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-detach-dev-ad1-eli"><span class="toc-number">164.</span> <span class="toc-text">geli detach /dev/ad1.eli</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#grep-geli-etc-rc-conf"><span class="toc-number">165.</span> <span class="toc-text">grep geli /etc/rc.conf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#grep-geli-etc-fstab"><span class="toc-number">166.</span> <span class="toc-text">grep geli /etc/fstab</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-zero-of-cryptedfile-bs-1M-count-1000-1-GB-文件"><span class="toc-number">167.</span> <span class="toc-text">dd if=/dev/zero of=/cryptedfile bs=1M count=1000  # 1 GB 文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mdconfig-at-vnode-f-cryptedfile"><span class="toc-number">168.</span> <span class="toc-text">mdconfig -at vnode -f /cryptedfile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-init-dev-md0-仅用密码加密"><span class="toc-number">169.</span> <span class="toc-text">geli init /dev/md0                                # 仅用密码加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-attach-dev-md0"><span class="toc-number">170.</span> <span class="toc-text">geli attach /dev/md0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#newfs-U-m-0-dev-md0-eli"><span class="toc-number">171.</span> <span class="toc-text">newfs -U -m 0 /dev/md0.eli</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-dev-md0-eli-mnt"><span class="toc-number">172.</span> <span class="toc-text">mount /dev/md0.eli /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#umount-dev-md0-eli"><span class="toc-number">173.</span> <span class="toc-text">umount /dev/md0.eli</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-detach-md0-eli"><span class="toc-number">174.</span> <span class="toc-text">geli detach md0.eli</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mdconfig-at-vnode-f-cryptedfile-1"><span class="toc-number">175.</span> <span class="toc-text">mdconfig -at vnode -f /cryptedfile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#geli-attach-dev-md0-1"><span class="toc-number">176.</span> <span class="toc-text">geli attach /dev/md0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-dev-md0-eli-mnt-1"><span class="toc-number">177.</span> <span class="toc-text">mount /dev/md0.eli /mnt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkdir-p-usr-local-certs-CA"><span class="toc-number">178.</span> <span class="toc-text">mkdir -p /usr/local/certs/CA</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-usr-local-certs-CA"><span class="toc-number">179.</span> <span class="toc-text">cd /usr/local/certs/CA</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkdir-certs-crl-newcerts-private"><span class="toc-number">180.</span> <span class="toc-text">mkdir certs crl newcerts private</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#echo-“01”-gt-serial-仅当-serial-不存在时"><span class="toc-number">181.</span> <span class="toc-text">echo “01” > serial                        # 仅当 serial 不存在时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#touch-index-txt"><span class="toc-number">182.</span> <span class="toc-text">touch index.txt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-req-new-x509-days-730-config-etc-ssl-openssl-cnf"><span class="toc-number">183.</span> <span class="toc-text">openssl req -new -x509 -days 730 -config /etc/ssl/openssl.cnf \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-req-new-keyout-newkey-pem-out-newreq-pem"><span class="toc-number">184.</span> <span class="toc-text">openssl req -new -keyout newkey.pem -out newreq.pem \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-req-nodes-new-keyout-newkey-pem-out-newreq-pem"><span class="toc-number">185.</span> <span class="toc-text">openssl req -nodes -new -keyout newkey.pem -out newreq.pem \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-newreq-pem-newkey-pem-gt-new-pem"><span class="toc-number">186.</span> <span class="toc-text">cat newreq.pem newkey.pem > new.pem</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-ca-policy-policy-anything-out-servernamecert-pem"><span class="toc-number">187.</span> <span class="toc-text">openssl ca -policy policy_anything -out servernamecert.pem \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mv-newkey-pem-servernamekey-pem"><span class="toc-number">188.</span> <span class="toc-text">mv newkey.pem servernamekey.pem</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-x509-text-in-servernamecert-pem-显示证书信息"><span class="toc-number">189.</span> <span class="toc-text">openssl x509 -text -in servernamecert.pem      # 显示证书信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-req-noout-text-in-server-csr-显示申请信息"><span class="toc-number">190.</span> <span class="toc-text">openssl req -noout -text -in server.csr        # 显示申请信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openssl-s-client-connect-cb-vu-443-检查-web-服务器认证信息"><span class="toc-number">191.</span> <span class="toc-text">openssl s_client -connect cb.vu:443            # 检查 web 服务器认证信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkdir-p-usr-local-cvs"><span class="toc-number">192.</span> <span class="toc-text">mkdir -p /usr/local/cvs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-usr-local-cvs-设置-CVSROOT-环境变量-本地"><span class="toc-number">193.</span> <span class="toc-text">setenv CVSROOT /usr/local/cvs      # 设置 CVSROOT 环境变量(本地)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-init-创建所有初始化-CVS-配置文件"><span class="toc-number">194.</span> <span class="toc-text">cvs init                           # 创建所有初始化 CVS 配置文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-root"><span class="toc-number">195.</span> <span class="toc-text">cd /root</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-checkout-CVSROOT-签出配置文件来修改他们"><span class="toc-number">196.</span> <span class="toc-text">cvs checkout CVSROOT               # 签出配置文件来修改他们</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-CVSROOT"><span class="toc-number">197.</span> <span class="toc-text">cd CVSROOT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-commit-config"><span class="toc-number">198.</span> <span class="toc-text">cvs commit config</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-add-writers-添加文件-writers-进-repository"><span class="toc-number">199.</span> <span class="toc-text">cvs add writers                    # 添加文件 writers 进 repository</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-edit-checkoutlist"><span class="toc-number">200.</span> <span class="toc-text">cvs edit checkoutlist</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-gt-gt-checkoutlist"><span class="toc-number">201.</span> <span class="toc-text">cat >> checkoutlist</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-commit-提交所有配置更改"><span class="toc-number">202.</span> <span class="toc-text">cvs commit                         # 提交所有配置更改</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#htpasswd-cb-passwd-user1-password1-c-创建文件"><span class="toc-number">203.</span> <span class="toc-text">htpasswd -cb passwd user1 password1  # -c 创建文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#htpasswd-b-passwd-user2-password2"><span class="toc-number">204.</span> <span class="toc-text">htpasswd -b passwd user2 password2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cat-passwd"><span class="toc-number">205.</span> <span class="toc-text">cat passwd</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-d-pserver-colin-192-168-50-254-usr-local-cvs-login"><span class="toc-number">206.</span> <span class="toc-text">cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs login</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-pserver-cvsdirectory"><span class="toc-number">207.</span> <span class="toc-text">setenv CVSROOT :pserver:@:/cvsdirectory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-usr-local-cvs-仅限本的使用"><span class="toc-number">208.</span> <span class="toc-text">setenv CVSROOT /usr/local/cvs                               # 仅限本的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-local-usr-local-cvs-同上"><span class="toc-number">209.</span> <span class="toc-text">setenv CVSROOT :local:/usr/local/cvs                        # 同上</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-ext-user-cvsserver-usr-local-cvs-通过-SSH-直接访问"><span class="toc-number">210.</span> <span class="toc-text">setenv CVSROOT :ext:user@cvsserver:/usr/local/cvs           # 通过 SSH 直接访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVS-RSH-ssh-ext-协议访问"><span class="toc-number">211.</span> <span class="toc-text">setenv CVS_RSH ssh                                          # ext 协议访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-pserver-user-cvsserver-254-usr-local-cvs-通过-pserver-网络访问"><span class="toc-number">212.</span> <span class="toc-text">setenv CVSROOT :pserver:user@cvsserver.254:/usr/local/cvs   # 通过 pserver 网络访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-d-pserver-colin-192-168-50-254-usr-local-cvs-checkout-MyProject"><span class="toc-number">213.</span> <span class="toc-text">cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs checkout MyProject</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-pserver-colin-192-168-50-254-usr-local-cvs"><span class="toc-number">214.</span> <span class="toc-text">setenv CVSROOT :pserver:colin@192.168.50.254:/usr/local/cvs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-checkout-MyProject"><span class="toc-number">215.</span> <span class="toc-text">cvs checkout MyProject</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L2401-localhost-2401-colin-cvs-server-直接连接到-cvs-服务器。或："><span class="toc-number">216.</span> <span class="toc-text">ssh -L2401:localhost:2401 colin@cvs_server   # 直接连接到 cvs 服务器。或：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-L2401-cvs-server-2401-colin-gateway-使用一个网关间接连接到-cvs-服务器"><span class="toc-number">217.</span> <span class="toc-text">ssh -L2401:cvs_server:2401 colin@gateway     # 使用一个网关间接连接到 cvs 服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-CVSROOT-pserver-colin-localhost-usr-local-cvs"><span class="toc-number">218.</span> <span class="toc-text">setenv CVSROOT :pserver:colin@localhost:/usr/local/cvs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-login"><span class="toc-number">219.</span> <span class="toc-text">cvs login</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-checkout-MyProject-src"><span class="toc-number">220.</span> <span class="toc-text">cvs checkout MyProject/src</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-import-options-directory-name-vendor-tag-release-tag"><span class="toc-number">221.</span> <span class="toc-text">cvs import [options] directory-name vendor-tag release-tag</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-devel-必须在该目录中来导入"><span class="toc-number">222.</span> <span class="toc-text">cd /devel                          # 必须在该目录中来导入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-import-myapp-Company-R1-0-修订-release-标签可以为任何单个单词"><span class="toc-number">223.</span> <span class="toc-text">cvs import myapp Company R1_0      # 修订(release)标签可以为任何单个单词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-devel-tools"><span class="toc-number">224.</span> <span class="toc-text">cd /devel/tools</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-import-myapp-tools-Company-R1-0"><span class="toc-number">225.</span> <span class="toc-text">cvs import myapp/tools Company R1_0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-co-myapp-tools-仅会签出-tools-目录"><span class="toc-number">226.</span> <span class="toc-text">cvs co myapp/tools                 # 仅会签出 tools 目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-co-r-R1-1-myapp-签出修订版本为-R1-1-的-myapp-sticky"><span class="toc-number">227.</span> <span class="toc-text">cvs co -r R1_1 myapp               # 签出修订版本为 R1_1 的 myapp (sticky)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-q-d-update-P-典型的-CVS-更新"><span class="toc-number">228.</span> <span class="toc-text">cvs -q -d update -P                # 典型的 CVS 更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-update-A-重置所有-sticky-标签-或日期、选项"><span class="toc-number">229.</span> <span class="toc-text">cvs update -A                      # 重置所有 sticky 标签(或日期、选项)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-add-newfile-添加一个新文件"><span class="toc-number">230.</span> <span class="toc-text">cvs add newfile                    # 添加一个新文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-add-kb-newfile-添加一个二进制文件"><span class="toc-number">231.</span> <span class="toc-text">cvs add -kb newfile                # 添加一个二进制文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-commit-file1-file2-仅提交这两个文件"><span class="toc-number">232.</span> <span class="toc-text">cvs commit file1 file2             # 仅提交这两个文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cvs-commit-m-“message”-提交所有更改并为这个更改添加日志消息"><span class="toc-number">233.</span> <span class="toc-text">cvs commit -m “message”            # 提交所有更改并为这个更改添加日志消息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-devel-project"><span class="toc-number">234.</span> <span class="toc-text">cd /devel/project</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#diff-Naur-olddir-newdir-gt-patchfile-Create-a-patch-from-a-directory-or-a-file"><span class="toc-number">235.</span> <span class="toc-text">diff -Naur olddir newdir > patchfile # Create a patch from a directory or a file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#diff-Naur-oldfile-newfile-gt-patchfile"><span class="toc-number">236.</span> <span class="toc-text">diff -Naur oldfile newfile > patchfile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-devel-project-1"><span class="toc-number">237.</span> <span class="toc-text">cd /devel/project</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#patch-–dry-run-p0-lt-patchfile-Test-the-path-without-applying-it"><span class="toc-number">238.</span> <span class="toc-text">patch –dry-run -p0 < patchfile    # Test the path without applying it</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#patch-p0-lt-patchfile"><span class="toc-number">239.</span> <span class="toc-text">patch -p0 < patchfile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#patch-p1-lt-patchfile-strip-off-the-1st-level-from-the-path"><span class="toc-number">240.</span> <span class="toc-text">patch -p1 < patchfile              # strip off the 1st level from the path</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svnadmin-create-–fs-type-fsfs-home-svn-project1"><span class="toc-number">241.</span> <span class="toc-text">svnadmin create –fs-type fsfs /home/svn/project1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-import-project1-file-home-svn-project1-trunk-m-‘Initial-import’"><span class="toc-number">242.</span> <span class="toc-text">svn import /project1/ file:///home/svn/project1/trunk -m ‘Initial import’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-checkout-file-home-svn-project1"><span class="toc-number">243.</span> <span class="toc-text">svn checkout file:///home/svn/project1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-checkout-svn-ssh-hostname-home-svn-project1"><span class="toc-number">244.</span> <span class="toc-text">svn checkout svn+ssh://hostname/home/svn/project1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#groupadd-subversion"><span class="toc-number">245.</span> <span class="toc-text">groupadd subversion</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#groupmod-A-user1-subversion"><span class="toc-number">246.</span> <span class="toc-text">groupmod -A user1 subversion</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chown-R-root-subversion-home-svn"><span class="toc-number">247.</span> <span class="toc-text">chown -R root:subversion /home/svn</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chmod-R-770-home-svn"><span class="toc-number">248.</span> <span class="toc-text">chmod -R 770 /home/svn</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#any-“-svn-foo”-URL-will-map-to-a-repository-home-svn-foo"><span class="toc-number">249.</span> <span class="toc-text">any “/svn/foo” URL will map to a repository /home/svn/foo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chown-R-www-www-home-svn"><span class="toc-number">250.</span> <span class="toc-text">chown -R www:www /home/svn</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#htpasswd-c-etc-svn-passwd-user1-c-creates-the-file"><span class="toc-number">251.</span> <span class="toc-text">htpasswd -c /etc/svn-passwd user1  # -c creates the file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Default-it-read-access-“-”-would-be-default-no-access"><span class="toc-number">252.</span> <span class="toc-text">Default it read access. “* =” would be default no access</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Give-write-access-to-the-developers"><span class="toc-number">253.</span> <span class="toc-text">Give write access to the developers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-help-import-Get-help-for-any-command"><span class="toc-number">254.</span> <span class="toc-text">svn help import                                # Get help for any command</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-import-project1-newdir-http-host-url-svn-project1-trunk-src-m-‘add-newdir’"><span class="toc-number">255.</span> <span class="toc-text">svn import /project1/newdir http://host.url/svn/project1/trunk/src -m ‘add newdir’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-co-http-host-url-svn-project1-trunk-Checkout-the-most-recent-version"><span class="toc-number">256.</span> <span class="toc-text">svn co http://host.url/svn/project1/trunk      # Checkout the most recent version</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-mkdir-http-host-url-svn-project1-tags-Create-the-tags-directory"><span class="toc-number">257.</span> <span class="toc-text">svn mkdir http://host.url/svn/project1/tags/   # Create the tags directory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-copy-m-“Tag-rc1-rel-”-http-host-url-svn-project1-trunk"><span class="toc-number">258.</span> <span class="toc-text">svn copy -m “Tag rc1 rel.” http://host.url/svn/project1/trunk \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-status-–verbose-Check-files-status-into-working-dir"><span class="toc-number">259.</span> <span class="toc-text">svn status [–verbose]                         # Check files status into working dir</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-add-src-file-h-src-file-cpp-Add-two-files"><span class="toc-number">260.</span> <span class="toc-text">svn add src/file.h src/file.cpp                # Add two files</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-commit-m-‘Added-new-class-file’-Commit-the-changes-with-a-message"><span class="toc-number">261.</span> <span class="toc-text">svn commit -m ‘Added new class file’           # Commit the changes with a message</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-ls-http-host-url-svn-project1-tags-List-all-tags"><span class="toc-number">262.</span> <span class="toc-text">svn ls http://host.url/svn/project1/tags/      # List all tags</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-move-foo-c-bar-c-Move-rename-files"><span class="toc-number">263.</span> <span class="toc-text">svn move foo.c bar.c                           # Move (rename) files</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#svn-delete-some-old-file-Delete-files"><span class="toc-number">264.</span> <span class="toc-text">svn delete some_old_file                       # Delete files</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#less-unixtoolbox-xhtml"><span class="toc-number">265.</span> <span class="toc-text">less unixtoolbox.xhtml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mail-c-cb-vu"><span class="toc-number">266.</span> <span class="toc-text">mail c@cb.vu</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#echo-“This-is-the-mail-body”-mail-c-cb-vu"><span class="toc-number">267.</span> <span class="toc-text">echo “This is the mail body” | mail c@cb.vu</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd"><span class="toc-number">268.</span> <span class="toc-text">cd /</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-cf-home-tar-home-归档整个-home-目录-c-为创建"><span class="toc-number">269.</span> <span class="toc-text">tar -cf home.tar home/        # 归档整个 /home 目录(c 为创建)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-czf-home-tgz-home-等同于-zip-压缩"><span class="toc-number">270.</span> <span class="toc-text">tar -czf home.tgz home/       # 等同于 zip 压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-cjf-home-tbz-home-等同于-bzip2-压缩"><span class="toc-number">271.</span> <span class="toc-text">tar -cjf home.tbz home/       # 等同于 bzip2 压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-C-usr-czf-local-tgz-local-etc-local-www"><span class="toc-number">272.</span> <span class="toc-text">tar -C /usr -czf local.tgz local/etc local/www</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-C-usr-xzf-local-tgz-释放-local-目录到-usr"><span class="toc-number">273.</span> <span class="toc-text">tar -C /usr -xzf local.tgz    # 释放 local 目录到 /usr</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-usr-tar-xzf-local-tgz-同上面一样"><span class="toc-number">274.</span> <span class="toc-text">cd /usr; tar -xzf local.tgz   # 同上面一样</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-tzf-home-tgz-列出归档文件中的所有文件，并不释放"><span class="toc-number">275.</span> <span class="toc-text">tar -tzf home.tgz             # 列出归档文件中的所有文件，并不释放</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-xf-home-tar-释放归档文件-x-为释放"><span class="toc-number">276.</span> <span class="toc-text">tar -xf home.tar              # 释放归档文件(x 为释放)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-xzf-home-tgz-等同于-zip-压缩"><span class="toc-number">277.</span> <span class="toc-text">tar -xzf home.tgz             # 等同于 zip 压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-xjf-home-tgz-等同于-bzip2-压缩"><span class="toc-number">278.</span> <span class="toc-text">tar -xjf home.tgz             # 等同于 bzip2 压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-xjf-home-tgz-home-colin-file-txt-释放单个文件"><span class="toc-number">279.</span> <span class="toc-text">tar -xjf home.tgz home/colin/file.txt    # 释放单个文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-c-dir-gzip-ssh-user-remote-‘dd-of-dir-tgz’-归档压缩-dir-目录并存储到远程主机上"><span class="toc-number">280.</span> <span class="toc-text">tar c dir/ | gzip | ssh user@remote ‘dd of=dir.tgz’ # 归档压缩 dir/ 目录并存储到远程主机上</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-cvf-find-print-gt-backup-tar-归档当前目录"><span class="toc-number">281.</span> <span class="toc-text">tar cvf - find . -print > backup.tar              # 归档当前目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-cf-C-etc-tar-xpf-C-backup-etc-拷贝目录"><span class="toc-number">282.</span> <span class="toc-text">tar -cf - -C /etc . | tar xpf - -C /backup/etc      # 拷贝目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-cf-C-etc-ssh-user-remote-tar-xpf-C-backup-etc-远程拷贝"><span class="toc-number">283.</span> <span class="toc-text">tar -cf - -C /etc . | ssh user@remote tar xpf - -C /backup/etc      # 远程拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tar-czf-home-tgz-–exclude-‘-o’-–exclude-‘tmp-‘-home"><span class="toc-number">284.</span> <span class="toc-text">tar -czf home.tgz –exclude ‘*.o’ –exclude ‘tmp/‘ home/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-of-bs-conv"><span class="toc-number">285.</span> <span class="toc-text">dd if= of= bs= conv=</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-hda-of-dev-hdc-bs-16065b-拷贝磁盘到磁盘-相同大小"><span class="toc-number">286.</span> <span class="toc-text">dd if=/dev/hda of=/dev/hdc bs=16065b                # 拷贝磁盘到磁盘(相同大小)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-sda7-of-home-root-img-bs-4096-conv-notrunc-noerror-备份"><span class="toc-number">287.</span> <span class="toc-text">dd if=/dev/sda7 of /home/root.img bs=4096 conv=notrunc,noerror # 备份 /</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-home-root-img-of-dev-sda7-bs-4096-conv-notrunc-noerror-恢复"><span class="toc-number">288.</span> <span class="toc-text">dd if /home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror # 恢复 /</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-bs-1M-if-dev-ad4s3e-gzip-c-gt-ad4s3e-gz-压缩备份"><span class="toc-number">289.</span> <span class="toc-text">dd bs=1M if=/dev/ad4s3e | gzip -c > ad4s3e.gz                  # 压缩备份</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gunzip-dc-ad4s3e-gz-dd-of-dev-ad0s3e-bs-1M-解压恢复"><span class="toc-number">290.</span> <span class="toc-text">gunzip -dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M                 # 解压恢复</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-bs-1M-if-dev-ad4s3e-gzip-ssh-eedcoba-fry-‘dd-of-ad4s3e-gz’-也可为远程的"><span class="toc-number">291.</span> <span class="toc-text">dd bs=1M if=/dev/ad4s3e | gzip | ssh eedcoba@fry ‘dd of=ad4s3e.gz’ # 也可为远程的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gunzip-dc-ad4s3e-gz-ssh-eedcoba-host-‘dd-of-dev-ad0s3e-bs-1M’"><span class="toc-number">292.</span> <span class="toc-text">gunzip -dc ad4s3e.gz | ssh eedcoba@host ‘dd of=/dev/ad0s3e bs=1M’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-ad0-of-dev-ad2-skip-1-seek-1-bs-4k-conv-noerror-忽略-MBR"><span class="toc-number">293.</span> <span class="toc-text">dd if=/dev/ad0 of=/dev/ad2 skip=1 seek=1 bs=4k conv=noerror    # 忽略 MBR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-hda-of-dev-null-bs-1m-检查坏扇区"><span class="toc-number">294.</span> <span class="toc-text">dd if=/dev/hda of=/dev/null bs=1m                   # 检查坏扇区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-bs-1k-if-dev-hda1-conv-sync-noerror-notrunc-gzip-ssh-发送到远程"><span class="toc-number">295.</span> <span class="toc-text">dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh \ # 发送到远程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-bs-1k-if-dev-hda1-conv-sync-noerror-notrunc-of-hda1-img-存储为一个映像文件"><span class="toc-number">296.</span> <span class="toc-text">dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img    # 存储为一个映像文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-o-loop-hda1-img-mnt-挂载这个映像文件"><span class="toc-number">297.</span> <span class="toc-text">mount -o loop /hda1.img /mnt                        # 挂载这个映像文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rsync-ax-mnt-newdisk-拷贝到一个新磁盘"><span class="toc-number">298.</span> <span class="toc-text">rsync -ax /mnt/ /newdisk/                           # 拷贝到一个新磁盘</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-hda-of-dev-hda-刷新磁状态"><span class="toc-number">299.</span> <span class="toc-text">dd if=/dev/hda of=/dev/hda                          # 刷新磁状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#上面的命令对于刷新磁盘-refresh-disk-很有用。这绝对安全，但必须先卸载磁盘。"><span class="toc-number">300.</span> <span class="toc-text">上面的命令对于刷新磁盘(refresh disk)很有用。这绝对安全，但必须先卸载磁盘。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-zero-of-dev-hdc-删除全部数据"><span class="toc-number">301.</span> <span class="toc-text">dd if=/dev/zero of=/dev/hdc                         # 删除全部数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-urandom-of-dev-hdc-更好的删除全部数据"><span class="toc-number">302.</span> <span class="toc-text">dd if=/dev/urandom of=/dev/hdc                      # 更好的删除全部数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kill-USR1-PID-查看-dd-进度-仅Linux"><span class="toc-number">303.</span> <span class="toc-text">kill -USR1 PID                                      # 查看 dd 进度(仅Linux!)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-sda-of-mbr-sda-bak-bs-512-count-1-完全备份-MBR"><span class="toc-number">304.</span> <span class="toc-text">dd if=/dev/sda of=/mbr_sda.bak bs=512 count=1                  # 完全备份 MBR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-dev-zero-of-dev-sda-bs-512-count-1-删除-MBR-和分区表"><span class="toc-number">305.</span> <span class="toc-text">dd if=/dev/zero of=/dev/sda bs=512 count=1                     # 删除 MBR 和分区表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-mbr-sda-bak-of-dev-sda-bs-512-count-1-完全恢复MBR"><span class="toc-number">306.</span> <span class="toc-text">dd if=/mbr_sda.bak of=/dev/sda bs=512 count=1                  # 完全恢复MBR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-mbr-sda-bak-of-dev-sda-bs-446-count-1-仅回复引导程序"><span class="toc-number">307.</span> <span class="toc-text">dd if=/mbr_sda.bak of=/dev/sda bs=446 count=1                  # 仅回复引导程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dd-if-mbr-sda-bak-of-dev-sda-bs-1-count-64-skip-446-seek-446-恢复分区表"><span class="toc-number">308.</span> <span class="toc-text">dd if=/mbr_sda.bak of=/dev/sda bs=1 count=64 skip=446 seek=446 # 恢复分区表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#screen"><span class="toc-number">309.</span> <span class="toc-text">screen</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#top"><span class="toc-number">310.</span> <span class="toc-text">top</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#screen-r"><span class="toc-number">311.</span> <span class="toc-text">screen -r</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#screen-R-D"><span class="toc-number">312.</span> <span class="toc-text">screen -R -D</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-f-perm-444-寻找所有无法读取的文件"><span class="toc-number">313.</span> <span class="toc-text">find . -type f ! -perm -444        # 寻找所有无法读取的文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-d-perm-111-寻找所有无法访问的目录"><span class="toc-number">314.</span> <span class="toc-text">find . -type d ! -perm -111        # 寻找所有无法访问的目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-home-user-cmin-10-print-寻找最后-10-分钟创建或修改的文件"><span class="toc-number">315.</span> <span class="toc-text">find /home/user/ -cmin 10 -print   # 寻找最后 10 分钟创建或修改的文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-name-‘-ch-’-xargs-grep-E-‘expr’-在当前目录及子目录搜索-‘expr’-表达式"><span class="toc-number">316.</span> <span class="toc-text">find . -name ‘*.[ch]’ | xargs grep -E ‘expr’ # 在当前目录及子目录搜索 ‘expr’ 表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-name-“-core”-xargs-rm-寻找-core-垃圾并删除它们-也可试试-core"><span class="toc-number">317.</span> <span class="toc-text">find / -name “.core” | xargs rm   # 寻找 core 垃圾并删除它们(也可试试 core.)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-name-“-core”-print-exec-rm-另一种语法"><span class="toc-number">318.</span> <span class="toc-text">find / -name “*.core” -print -exec rm {} \;  # 另一种语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-iname-“-png”-o-iname-“-jpg”-print-exec-tar-rf-images-tar"><span class="toc-number">319.</span> <span class="toc-text">find . ( -iname “.png” -o -iname “.jpg” ) -print -exec tar -rf images.tar {} \;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-f-name-“-txt”-name-README-txt-print-除-README-txt-的文件"><span class="toc-number">320.</span> <span class="toc-text">find . -type f -name “*.txt” ! -name README.txt -print  # 除 README.txt 的文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-var-size-10M-exec-ls-lh-查找-gt-10-MB-的文件"><span class="toc-number">321.</span> <span class="toc-text">find /var/ -size +10M -exec ls -lh {} \;     # 查找 > 10 MB 的文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-var-size-10M-ls-这个更简单"><span class="toc-number">322.</span> <span class="toc-text">find /var/ -size +10M -ls           # 这个更简单</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-size-10M-size-50M-print"><span class="toc-number">323.</span> <span class="toc-text">find . -size +10M -size -50M -print</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-usr-ports-name-work-type-d-print-exec-rm-rf-清理-port"><span class="toc-number">324.</span> <span class="toc-text">find /usr/ports/ -name work -type d -print -exec rm -rf {} \;  # 清理 port</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-f-user-root-perm-4000-exec-ls-l"><span class="toc-number">325.</span> <span class="toc-text">find / -type f -user root -perm -4000 -exec ls -l {} \;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-f-xargs-ls-l-不能工作于有空格的名字"><span class="toc-number">326.</span> <span class="toc-text">find . -type f | xargs ls -l       # 不能工作于有空格的名字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-f-print0-xargs-0-ls-l-可工作于有空格的名字"><span class="toc-number">327.</span> <span class="toc-text">find . -type f -print0 | xargs -0 ls -l  # 可工作于有空格的名字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find-type-f-exec-ls-l-‘-’-或使用用于-exec-的引用-‘-’"><span class="toc-number">328.</span> <span class="toc-text">find . -type f -exec ls -l ‘{}’ \; # 或使用用于 -exec 的引用 ‘{}’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#which-command-显示命令的全路径名"><span class="toc-number">329.</span> <span class="toc-text">which command                      # 显示命令的全路径名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-command-显示一个命令执行完成所用的时间"><span class="toc-number">330.</span> <span class="toc-text">time command                       # 显示一个命令执行完成所用的时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-cat-使用-time-作为秒表，用-Ctrl-c-来停止"><span class="toc-number">331.</span> <span class="toc-text">time cat                           # 使用 time 作为秒表，用 Ctrl-c 来停止</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set-grep-USER-列显当前环境变量"><span class="toc-number">332.</span> <span class="toc-text">set | grep $USER                   # 列显当前环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cal-3-显示三个月日历"><span class="toc-number">333.</span> <span class="toc-text">cal -3                             # 显示三个月日历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#date-u-–utc-–universal-MMDDhhmm-CC-YY-ss"><span class="toc-number">334.</span> <span class="toc-text">date [-u|–utc|–universal] [MMDDhhmm[[CC]YY][.ss]]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#date-10022155-设置日期和时间"><span class="toc-number">335.</span> <span class="toc-text">date 10022155                      # 设置日期和时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#whatis-grep-显示命令的简短信息"><span class="toc-number">336.</span> <span class="toc-text">whatis grep                        # 显示命令的简短信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#whereis-java-查询命令的的路径和标准目录"><span class="toc-number">337.</span> <span class="toc-text">whereis java                       # 查询命令的的路径和标准目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setenv-varname-value-设置环境变量，设置变量-varname-的值为-value-csh-tcsh"><span class="toc-number">338.</span> <span class="toc-text">setenv varname value               # 设置环境变量，设置变量 varname 的值为 value (csh/tcsh)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#export-varname-”value”-设置环境变量，设置变量-varname-的值为-value-sh-ksh-bash"><span class="toc-number">339.</span> <span class="toc-text">export varname=”value”             # 设置环境变量，设置变量 varname 的值为 value  (sh/ksh/bash)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pwd-显示当前工作目录"><span class="toc-number">340.</span> <span class="toc-text">pwd                                # 显示当前工作目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkdir-p-path-to-dir-如果存在不显示错误，建立所需的上级目录"><span class="toc-number">341.</span> <span class="toc-text">mkdir -p /path/to/dir              # 如果存在不显示错误，建立所需的上级目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mkdir-p-project-bin-src-obj-doc-html-man-pdf-debug-some-more-dirs"><span class="toc-number">342.</span> <span class="toc-text">mkdir -p project/{bin,src,obj,doc/{html,man,pdf},debug/some/more/dirs}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rmdir-path-to-dir-移除目录"><span class="toc-number">343.</span> <span class="toc-text">rmdir /path/to/dir                 # 移除目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rm-rf-path-to-dir-移除目录和其内容-强制"><span class="toc-number">344.</span> <span class="toc-text">rm -rf /path/to/dir                # 移除目录和其内容(强制)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cp-la-dir1-dir2-存档、硬连接目录所有文件，用来替代拷贝"><span class="toc-number">345.</span> <span class="toc-text">cp -la /dir1 /dir2                 # 存档、硬连接目录所有文件，用来替代拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cp-lpR-dir1-dir2-同上-FreeBSD"><span class="toc-number">346.</span> <span class="toc-text">cp -lpR /dir1 /dir2                # 同上 (FreeBSD)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cp-unixtoolbox-xhtml-bak-拷贝文件成新扩展名的快速方法"><span class="toc-number">347.</span> <span class="toc-text">cp unixtoolbox.xhtml{,.bak}        # 拷贝文件成新扩展名的快速方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mv-dir1-dir2-修改目录名"><span class="toc-number">348.</span> <span class="toc-text">mv /dir1 /dir2                     # 修改目录名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rpm-qa-列出已安装过的软件包-RH-SuSE-基于-RPM-的"><span class="toc-number">349.</span> <span class="toc-text">rpm -qa                            # 列出已安装过的软件包(RH, SuSE, 基于 RPM 的)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dpkg-l-Debian-Ubuntu"><span class="toc-number">350.</span> <span class="toc-text">dpkg -l                            # Debian, Ubuntu</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-info-列出所有已安装过的软件包-FreeBSD"><span class="toc-number">351.</span> <span class="toc-text">pkg_info                           # 列出所有已安装过的软件包(FreeBSD)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-info-W-smbd-查看-smbd-安装了那些软件包-FreeBSD"><span class="toc-number">352.</span> <span class="toc-text">pkg_info -W smbd                   # 查看 smbd 安装了那些软件包(FreeBSD)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkginfo-Solaris"><span class="toc-number">353.</span> <span class="toc-text">pkginfo                            # Solaris</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rpm-i-pkgname-rpm-安装软件包-RH-SuSE-基于-RPM-的"><span class="toc-number">354.</span> <span class="toc-text">rpm -i pkgname.rpm                 # 安装软件包(RH, SuSE, 基于 RPM 的)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rpm-e-pkgname-删除软件包"><span class="toc-number">355.</span> <span class="toc-text">rpm -e pkgname                     # 删除软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#apt-get-update-更新源列表"><span class="toc-number">356.</span> <span class="toc-text">apt-get update                     # 更新源列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#apt-get-install-emacs-安装-emacs-软件包"><span class="toc-number">357.</span> <span class="toc-text">apt-get install emacs              # 安装 emacs 软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dpkg-–remove-emacs-删除-emacs-软件包"><span class="toc-number">358.</span> <span class="toc-text">dpkg –remove emacs                # 删除 emacs 软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dpkg-S-file-查找拥有该-file-的软件包"><span class="toc-number">359.</span> <span class="toc-text">dpkg -S file                       # 查找拥有该 file 的软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#emerge-–sync-同步更新本地-protage-树"><span class="toc-number">360.</span> <span class="toc-text">emerge –sync                      # 同步更新本地 protage 树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#emerge-u-packagename-安装或更新一个软件包"><span class="toc-number">361.</span> <span class="toc-text">emerge -u packagename              # 安装或更新一个软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#emerge-C-packagename-删除软件包"><span class="toc-number">362.</span> <span class="toc-text">emerge -C packagename              # 删除软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#revdep-rebuild-修复依赖关系的缺失"><span class="toc-number">363.</span> <span class="toc-text">revdep-rebuild                     # 修复依赖关系的缺失</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkgadd-d-Solaris-9-Product-SUNWgtar"><span class="toc-number">364.</span> <span class="toc-text">pkgadd -d /Solaris_9/Product SUNWgtar</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkgadd-d-SUNWgtar-添加下载的软件包-先要-bunzip2"><span class="toc-number">365.</span> <span class="toc-text">pkgadd -d SUNWgtar                 # 添加下载的软件包(先要 bunzip2)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkgrm-SUNWgtar-删除软件包"><span class="toc-number">366.</span> <span class="toc-text">pkgrm SUNWgtar                     # 删除软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-add-r-rsync-获取并安装-rsync"><span class="toc-number">367.</span> <span class="toc-text">pkg_add -r rsync                   # 获取并安装 rsync</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-delete-var-db-pkg-rsync-xx-删除-rsync-软件包"><span class="toc-number">368.</span> <span class="toc-text">pkg_delete /var/db/pkg/rsync-xx    # 删除 rsync 软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#export-PACKAGESITE-ftp-ftp-freebsd-org-pub-FreeBSD-ports-i386-packages-Latest"><span class="toc-number">369.</span> <span class="toc-text">export PACKAGESITE=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages/Latest/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#or-ftp-ftp-freebsd-org-pub-FreeBSD-ports-i386-packages-6-stable-Latest"><span class="toc-number">370.</span> <span class="toc-text">or ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#portsnap-fetch-extract-当第一次运行这个命令，会创建-port-树"><span class="toc-number">371.</span> <span class="toc-text">portsnap fetch extract             # 当第一次运行这个命令，会创建 port 树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#portsnap-fetch-update-跟新-port-树"><span class="toc-number">372.</span> <span class="toc-text">portsnap fetch update              # 跟新 port 树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cd-usr-ports-net-rsync-选择软件安装目录"><span class="toc-number">373.</span> <span class="toc-text">cd /usr/ports/net/rsync/           # 选择软件安装目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#make-install-distclean-安装并清理-也可看-man-ports"><span class="toc-number">374.</span> <span class="toc-text">make install distclean             # 安装并清理(也可看 man ports)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#make-package-Make-一个二进制软件包"><span class="toc-number">375.</span> <span class="toc-text">make package                       # Make 一个二进制软件包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ldd-usr-bin-rsync-列出所有所需的运行时库"><span class="toc-number">376.</span> <span class="toc-text">ldd /usr/bin/rsync                 # 列出所有所需的运行时库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ldconfig-n-path-to-libs-添加一个路径到共享库目录Add-a-path-to-the-shared-libraries-directories"><span class="toc-number">377.</span> <span class="toc-text">ldconfig -n /path/to/libs/         # 添加一个路径到共享库目录Add a path to the shared libraries directories</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ldconfig-m-path-to-libs-FreeBSD"><span class="toc-number">378.</span> <span class="toc-text">ldconfig -m /path/to/libs/         # FreeBSD</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LD-LIBRARY-PATH-设置连接库路径的环境变量"><span class="toc-number">379.</span> <span class="toc-text">LD_LIBRARY_PATH                    # 设置连接库路径的环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iconv-f-t"><span class="toc-number">380.</span> <span class="toc-text">iconv -f  -t  </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iconv-f-ISO8859-1-t-UTF-8-o-file-input-gt-file-utf8"><span class="toc-number">381.</span> <span class="toc-text">iconv -f ISO8859-1 -t UTF-8 -o file.input > file_utf8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iconv-l-列显系统所支持的字符编码"><span class="toc-number">382.</span> <span class="toc-text">iconv -l                           # 列显系统所支持的字符编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sed-‘s-‘-dosfile-txt-gt-unixfile-txt"><span class="toc-number">383.</span> <span class="toc-text">sed ‘s/.$//‘ dosfile.txt > unixfile.txt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sed-n-p-unixfile-txt-gt-dosfile-txt"><span class="toc-number">384.</span> <span class="toc-text">sed -n p unixfile.txt > dosfile.txt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gs-dBATCH-dNOPAUSE-sDEVICE-jpeg-r150-dTextAlphaBits-4-dGraphicsAlphaBits-4"><span class="toc-number">385.</span> <span class="toc-text">gs -dBATCH -dNOPAUSE -sDEVICE=jpeg -r150 -dTextAlphaBits=4 -dGraphicsAlphaBits=4 \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#convert-unixtoolbox-pdf-unixtoolbox-03d-png"><span class="toc-number">386.</span> <span class="toc-text">convert unixtoolbox.pdf unixtoolbox-%03d.png</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#convert-jpeg-images-pdf-把所有图片转换成一份简单的-PDF-文档"><span class="toc-number">387.</span> <span class="toc-text">convert *.jpeg images.pdf          # 把所有图片转换成一份简单的 PDF 文档</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gs-q-sPAPERSIZE-a4-dNOPAUSE-dBATCH-sDEVICE-pdfwrite-sOutputFile-all-pdf"><span class="toc-number">388.</span> <span class="toc-text">gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=all.pdf \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mencoder-o-videoout-avi-oac-mp3lame-ovc-lavc-srate-11025"><span class="toc-number">389.</span> <span class="toc-text">mencoder -o videoout.avi -oac mp3lame -ovc lavc -srate 11025 \</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cdparanoia-B-拷贝音轨成-wav-文件到当前目录列表-dir"><span class="toc-number">390.</span> <span class="toc-text">cdparanoia -B                      # 拷贝音轨成 wav 文件到当前目录列表(dir)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lame-b-256-in-wav-out-mp3-编码成-256-kb-s-的-mp3"><span class="toc-number">391.</span> <span class="toc-text">lame -b 256 in.wav out.mp3         # 编码成 256 kb/s 的 mp3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#for-i-in-wav-do-lame-b-256-i-basename-i-wav-mp3-done"><span class="toc-number">392.</span> <span class="toc-text">for i in *.wav; do lame -b 256 $i basename $i .wav.mp3; done</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#oggenc-in-wav-b-256-out-ogg-编码成-256-kb-s-的-Ogg-Vorbis"><span class="toc-number">393.</span> <span class="toc-text">oggenc in.wav -b 256 out.ogg       # 编码成 256 kb/s 的 Ogg Vorbis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpr-unixtoolbox-ps-用默认打印机打印"><span class="toc-number">394.</span> <span class="toc-text">lpr unixtoolbox.ps                 # 用默认打印机打印</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#export-PRINTER-hp4600-更改默认打印机"><span class="toc-number">395.</span> <span class="toc-text">export PRINTER=hp4600              # 更改默认打印机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpr-Php4500-2-unixtoolbox-ps-指定打印机-hp4500-并打印-2-份"><span class="toc-number">396.</span> <span class="toc-text">lpr -Php4500 #2 unixtoolbox.ps     # 指定打印机 hp4500 并打印 2 份</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpr-o-Duplex-DuplexNoTumble-…-启用双面打印"><span class="toc-number">397.</span> <span class="toc-text">lpr -o Duplex=DuplexNoTumble …   # 启用双面打印</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpr-o-PageSize-A4-Duplex-DuplexNoTumble-…"><span class="toc-number">398.</span> <span class="toc-text">lpr -o PageSize=A4,Duplex=DuplexNoTumble …</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpq-查看默认打印机的队列"><span class="toc-number">399.</span> <span class="toc-text">lpq                                # 查看默认打印机的队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpq-l-Php4500-详细显示打印机队列信息"><span class="toc-number">400.</span> <span class="toc-text">lpq -l -Php4500                    # 详细显示打印机队列信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lprm-删除所有打印机内的用户打印作业"><span class="toc-number">401.</span> <span class="toc-text">lprm -                             # 删除所有打印机内的用户打印作业</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lprm-Php4500-3186-删除作业-3186。可使用-lpq-查看作业号"><span class="toc-number">402.</span> <span class="toc-text">lprm -Php4500 3186                 # 删除作业 3186。可使用 lpq 查看作业号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpc-status-列印所有可用打印机"><span class="toc-number">403.</span> <span class="toc-text">lpc status                         # 列印所有可用打印机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lpc-status-hp4500-如果打印机在线，查看其状态和列队长度"><span class="toc-number">404.</span> <span class="toc-text">lpc status hp4500                  # 如果打印机在线，查看其状态和列队长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gs-dSAFER-dNOPAUSE-sDEVICE-deskjet-sOutputFile-lpr-file-pdf"><span class="toc-number">405.</span> <span class="toc-text">gs -dSAFER -dNOPAUSE -sDEVICE=deskjet -sOutputFile=|lpr file.pdf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#psql-d-template1-U-pgsql"><span class="toc-number">406.</span> <span class="toc-text">psql -d template1 -U pgsql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#createuser-U-pgsql-P-bob-P-会请求一个秘密"><span class="toc-number">407.</span> <span class="toc-text">createuser -U pgsql -P bob         # -P 会请求一个秘密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#createdb-U-pgsql-O-bob-bobdb-新数据库-bobdn-的所有者是-bob"><span class="toc-number">408.</span> <span class="toc-text">createdb -U pgsql -O bob bobdb     # 新数据库 bobdn 的所有者是 bob</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dropdb-bobdb-删除数据库-bobdb"><span class="toc-number">409.</span> <span class="toc-text">dropdb bobdb                       # 删除数据库 bobdb</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dropuser-bob-删除用户-bob"><span class="toc-number">410.</span> <span class="toc-text">dropuser bob                       # 删除用户 bob</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TYPE-DATABASE-USER-IP-ADDRESS-IP-MASK-METHOD"><span class="toc-number">411.</span> <span class="toc-text">TYPE  DATABASE    USER        IP-ADDRESS        IP-MASK          METHOD</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pg-dump-–clean-dbname-gt-dbname-sql-dump"><span class="toc-number">412.</span> <span class="toc-text">pg_dump –clean dbname > dbname_sql.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#psql-dbname-lt-dbname-sql-dump"><span class="toc-number">413.</span> <span class="toc-text">psql dbname < dbname_sql.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pg-dumpall-–clean-gt-full-dump"><span class="toc-number">414.</span> <span class="toc-text">pg_dumpall –clean > full.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#psql-f-full-dump-postgres"><span class="toc-number">415.</span> <span class="toc-text">psql -f full.dump postgres</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#etc-init-d-mysql-stop"><span class="toc-number">416.</span> <span class="toc-text">/etc/init.d/mysql stop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#killall-mysqld"><span class="toc-number">417.</span> <span class="toc-text">killall mysqld</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysqld-–skip-grant-tables"><span class="toc-number">418.</span> <span class="toc-text">mysqld –skip-grant-tables</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysqladmin-u-root-password-‘newpasswd’"><span class="toc-number">419.</span> <span class="toc-text">mysqladmin -u root password ‘newpasswd’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#etc-init-d-mysql-start"><span class="toc-number">420.</span> <span class="toc-text">/etc/init.d/mysql start</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-u-root-mysql"><span class="toc-number">421.</span> <span class="toc-text">mysql -u root mysql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-u-root-mysql-1"><span class="toc-number">422.</span> <span class="toc-text">mysql -u root mysql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-u-root-mysql-2"><span class="toc-number">423.</span> <span class="toc-text">mysql -u root mysql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysqldump-u-root-psecret-–add-drop-database-dbname-gt-dbname-sql-dump"><span class="toc-number">424.</span> <span class="toc-text">mysqldump -u root -psecret –add-drop-database dbname > dbname_sql.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-u-root-psecret-D-dbname-lt-dbname-sql-dump"><span class="toc-number">425.</span> <span class="toc-text">mysql -u root -psecret -D dbname < dbname_sql.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysqldump-u-root-psecret-–add-drop-database-–all-databases-gt-full-dump"><span class="toc-number">426.</span> <span class="toc-text">mysqldump -u root -psecret –add-drop-database –all-databases > full.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-u-root-psecret-lt-full-dump"><span class="toc-number">427.</span> <span class="toc-text">mysql -u root -psecret < full.dump</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sqlite-database-db-dump-gt-dump-sql-备份"><span class="toc-number">428.</span> <span class="toc-text">sqlite database.db .dump > dump.sql              # 备份</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sqlite-database-db-lt-dump-sql-恢复"><span class="toc-number">429.</span> <span class="toc-text">sqlite database.db < dump.sql                    # 恢复</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-o-remount-home"><span class="toc-number">430.</span> <span class="toc-text">mount -o remount /home</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-检查-usrquota-已经激活，否则重启"><span class="toc-number">431.</span> <span class="toc-text">mount                              # 检查 usrquota 已经激活，否则重启</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#quotacheck-vum-home"><span class="toc-number">432.</span> <span class="toc-text">quotacheck -vum /home</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chmod-644-home-aquota-user-让用户检查自己的配额"><span class="toc-number">433.</span> <span class="toc-text">chmod 644 /home/aquota.user        # 让用户检查自己的配额</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount-home-重新挂载分区"><span class="toc-number">434.</span> <span class="toc-text">mount /home                        # 重新挂载分区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#grep-quotas-etc-rc-conf"><span class="toc-number">435.</span> <span class="toc-text">grep quotas /etc/rc.conf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#etc-rc-d-quota-start"><span class="toc-number">436.</span> <span class="toc-text">/etc/rc.d/quota start</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#edquota-u-colin"><span class="toc-number">437.</span> <span class="toc-text">edquota -u colin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#edquota-p-refuser-awk-F-3-gt-499-print-1-39-etc-passwd"><span class="toc-number">438.</span> <span class="toc-text">edquota -p refuser awk -F: $3 > 499 {print $1}' /etc/passwd</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#edquota-p-refuser-user1-user2-复用给-2-个用户"><span class="toc-number">439.</span> <span class="toc-text">edquota -p refuser user1 user2     # 复用给 2 个用户</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#quota-u-colin-查看用户的限额"><span class="toc-number">440.</span> <span class="toc-text">quota -u colin                     # 查看用户的限额</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#repquota-home-所有用户在这个分区上的限额情况"><span class="toc-number">441.</span> <span class="toc-text">repquota /home                     # 所有用户在这个分区上的限额情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ifconfig-sed-‘s-g’-cut-d”-“-f1-uniq-grep-E-“-a-z0-9-”-sort-r"><span class="toc-number">442.</span> <span class="toc-text">ifconfig | sed ‘s/  / /g’ | cut -d” “ -f1 | uniq | grep -E “[a-z0-9]+” | sort -r</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ifconfig-sed-‘-inet-addr-d-s-s-‘-sort-t-k1-1n-k2-2n-k3-3n-k4-4n"><span class="toc-number">443.</span> <span class="toc-text">ifconfig | sed ‘/.inet addr:/!d;s///;s/ .//‘|sort -t. -k1,1n -k2,2n -k3,3n -k4,4n</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-1-gt-file-重定向标准输出到-file。"><span class="toc-number">444.</span> <span class="toc-text">cmd 1> file                         # 重定向标准输出到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-2-gt-file-重定向标准错误输出到-file。"><span class="toc-number">445.</span> <span class="toc-text">cmd 2> file                         # 重定向标准错误输出到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-1-gt-gt-file-重定向标准输出并追加到-file。"><span class="toc-number">446.</span> <span class="toc-text">cmd 1>> file                        # 重定向标准输出并追加到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-amp-gt-file-重定向标准输出和标准错误输出到-file。"><span class="toc-number">447.</span> <span class="toc-text">cmd &> file                         # 重定向标准输出和标准错误输出到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-gt-file-2-gt-amp-1-重定向标准错误输出到标准输出然后重定向到-file。"><span class="toc-number">448.</span> <span class="toc-text">cmd >file 2>&1                      # 重定向标准错误输出到标准输出然后重定向到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd1-cmd2-cmd1-的输出通过管道连接到-cmd2-的输入"><span class="toc-number">449.</span> <span class="toc-text">cmd1 | cmd2                         # cmd1 的输出通过管道连接到 cmd2 的输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd1-2-gt-amp-1-cmd2-cmd1-的输出和错误输出通过管道连接到-cmd2-的输入"><span class="toc-number">450.</span> <span class="toc-text">cmd1 2>&1 | cmd2                    # cmd1 的输出和错误输出通过管道连接到 cmd2 的输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#in-bashrc"><span class="toc-number">451.</span> <span class="toc-text">in .bashrc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#要检查当前可用别名-alias-，只需简单输入命令-alias"><span class="toc-number">452.</span> <span class="toc-text">要检查当前可用别名(alias)，只需简单输入命令 alias</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-gt-amp-file-重定向标准输出和标准错误输出到-file。"><span class="toc-number">453.</span> <span class="toc-text">cmd >& file                         # 重定向标准输出和标准错误输出到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd-gt-gt-amp-file-追加标准输出和标准错误输出到-file。"><span class="toc-number">454.</span> <span class="toc-text">cmd >>& file                        # 追加标准输出和标准错误输出到 file。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd1-cmd2-cmd1-的输出通过管道连接到-cmd2-的输入-1"><span class="toc-number">455.</span> <span class="toc-text">cmd1 | cmd2                         # cmd1 的输出通过管道连接到 cmd2 的输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd1-amp-cmd2-cmd1-的输出和错误输出通过管道连接到-cmd2-的输入"><span class="toc-number">456.</span> <span class="toc-text">cmd1 |& cmd2                        # cmd1 的输出和错误输出通过管道连接到 cmd2 的输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#in-cshrc"><span class="toc-number">457.</span> <span class="toc-text">in .cshrc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bindkey-和颜色"><span class="toc-number">458.</span> <span class="toc-text">Bindkey 和颜色</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#所有-EOF前的代码都会进入到-testhome-sh-文件中去"><span class="toc-number">459.</span> <span class="toc-text">所有_EOF前的代码都会进入到 testhome.sh 文件中去</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#此脚本可以创建一份供双面打印机打印的-PDF-格式的书"><span class="toc-number">460.</span> <span class="toc-text">此脚本可以创建一份供双面打印机打印的 PDF 格式的书</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重复前项-0-次或多次"><span class="toc-number">461.</span> <span class="toc-text">重复前项 0 次或多次</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编程"><span class="toc-number">462.</span> <span class="toc-text">编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-基础"><span class="toc-number">462.1.</span> <span class="toc-text">C 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-实例"><span class="toc-number">462.2.</span> <span class="toc-text">C 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-基础-1"><span class="toc-number">462.3.</span> <span class="toc-text">C++ 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-实例-1"><span class="toc-number">462.4.</span> <span class="toc-text">C++ 实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#g-c-IPv4-cpp-simplecpp-cpp-编译成目标文件"><span class="toc-number">463.</span> <span class="toc-text">g++ -c IPv4.cpp simplecpp.cpp                # 编译成目标文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#g-IPv4-o-simplecpp-o-o-simplecpp-exe-连接目标代码，生成可执行文件"><span class="toc-number">464.</span> <span class="toc-text">g++ IPv4.o simplecpp.o -o simplecpp.exe      # 连接目标代码，生成可执行文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#simplecpp-exe"><span class="toc-number">465.</span> <span class="toc-text">./simplecpp.exe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的-Makefile"><span class="toc-number">465.1.</span> <span class="toc-text">简单的 Makefile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在线帮助"><span class="toc-number">466.</span> <span class="toc-text">在线帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文档"><span class="toc-number">466.1.</span> <span class="toc-text">文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他-Unix-Linux-参考"><span class="toc-number">466.2.</span> <span class="toc-text">其他 Unix/Linux 参考</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p>硬件 | 状态信息 | 用户 | 限制 | 运行级别 | root 密码 | 编译内核</p>
<p>正在运行的内核和系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># uname -a                           # 获取内核版本（和BSD版本）</span><br><span class="line"># lsb_release -a                     # 显示任何 LSB 发行版版本信息</span><br><span class="line"># cat /etc/SuSE-release              # 获取 SuSE 版本</span><br><span class="line"># cat /etc/debian_version            # 获取 Debian 版本</span><br></pre></td></tr></table></figure>
<p>使用 /etc/DISTR-release 其中DISTR(发行代号)= lsb (Ubuntu), redhat, gentoo, mandrake, sun (Solaris), 等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># uptime                             # 显示系统开机运行到现在经过的时间</span><br><span class="line"># hostname                           # 显示系统主机名</span><br><span class="line"># hostname -i                        # 显示主机的 IP 地址</span><br><span class="line"># man hier                           # 描述文件系统目录结构</span><br><span class="line"># last reboot                        # 显示系统最后重启的历史记录</span><br></pre></td></tr></table></figure>
<h2 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h2><p>内核检测到的硬件信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># dmesg                              # 检测到的硬件和启动的消息</span><br><span class="line"># lsdev                              # 关于已安装硬件的信息</span><br><span class="line"># dd if=/dev/mem bs=1k skip=768 count=256 2&gt;/dev/null | strings -n 8 # 读取 BIOS 信息</span><br></pre></td></tr></table></figure>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/cpuinfo                  # CPU 讯息</span><br><span class="line"># cat /proc/meminfo                  # 内存信息</span><br><span class="line"># grep MemTotal /proc/meminfo        # 显示物理内存大小</span><br><span class="line"># watch -n1 &apos;cat /proc/interrupts&apos;   # 监控内核处理的所有中断</span><br><span class="line"># free -m                            # 显示已用和空闲的内存信息 (-m 为 MB)</span><br><span class="line"># cat /proc/devices                  # 显示当前核心配置的设备</span><br><span class="line"># lspci -tv                          # 显示 PCI 设备</span><br><span class="line"># lsusb -tv                          # 显示 USB 设备</span><br><span class="line"># lshal                              # 显示所有设备属性列表</span><br><span class="line"># dmidecode                          # 显示从 BIOS 中获取的硬件信息</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># sysctl hw.model                    # CPU 讯息</span><br><span class="line"># sysctl hw                          # 得到很多硬件信息</span><br><span class="line"># sysctl vm                          # 虚拟内存使用情况</span><br><span class="line"># dmesg | grep &quot;real mem&quot;            # 物理内存</span><br><span class="line"># sysctl -a | grep mem               # 内核内存的设置和信息</span><br><span class="line"># sysctl dev                         # 显示当前核心配置的设备</span><br><span class="line"># pciconf -l -cv                     # 显示 PCI 设备</span><br><span class="line"># usbdevs -v                         # 显示 USB 设备</span><br><span class="line"># atacontrol list                    # 显示 ATA 设备</span><br></pre></td></tr></table></figure>
<h2 id="显示状态信息"><a href="#显示状态信息" class="headerlink" title="显示状态信息"></a>显示状态信息</h2><p>以下的命令有助于找出正在系统中运行着的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># top                                # 显示和更新使用 cpu 最多的进程</span><br><span class="line"># mpstat 1                           # 显示进程相关的信息</span><br><span class="line"># vmstat 2                           # 显示虚拟内存的状态信息</span><br><span class="line"># iostat 2                           # 显示 I/O 状态信息(2 秒 间隙)</span><br><span class="line"># systat -vmstat 1                   # 显示 BSD 系统状态信息(1 秒 间隙)</span><br><span class="line"># systat -tcp 1                      # 显示 BSD TCP 连接信息(也可以试试 -ip)</span><br><span class="line"># systat -netstat 1                  # 显示 BSD 当前网络连接信息</span><br><span class="line"># systat -ifstat 1                   # 显示 BSD 当前网卡带宽信息</span><br><span class="line"># systat -iostat 1                   # 显示 BSD CPU 和磁盘使用情况</span><br><span class="line"># tail -n 500 /var/log/messages      # 显示最新500条内核/系统日志的信息</span><br><span class="line"># tail /var/log/warn                 # 显示系统警告信息(看syslog.conf)</span><br></pre></td></tr></table></figure>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># id                                 # 显示当前用户和用户组的 ID</span><br><span class="line"># last                               # 列出目前与过去登入系统的用户相关信息</span><br><span class="line"># who                                # 显示目前登入系统的用户信息</span><br><span class="line"># groupadd admin                     # 建立新组&quot;admin&quot;和添加新用户 colin 并加入 admin 用户组(Linux/Solaris)</span><br><span class="line"># useradd -c &quot;Colin Barschel&quot; -g admin -m colin</span><br><span class="line"># userdel colin                      # 删除用户 colin(Linux/Solaris)</span><br><span class="line"># adduser joe                        # FreeBSD 添加用户 joe(交互式)</span><br><span class="line"># rmuser joe                         # FreeBSD 删除用户 joe(交互式)</span><br><span class="line"># pw groupadd admin                  # 在 FreeBSD 上使用 pw</span><br><span class="line"># pw groupmod admin -m newmember     # 添加新用户到一个组</span><br><span class="line"># pw useradd colin -c &quot;Colin Barschel&quot; -g admin -m -s /bin/tcsh </span><br><span class="line"># pw userdel colin; pw groupdel admin</span><br></pre></td></tr></table></figure>
<p>加密过的密码存储在 /etc/shadow (Linux and Solaris) 或 /etc/master.passwd (FreeBSD) 中. 如果手动修改了 master.passwd，需要运行 # pwd_mkdb -p master.passwd 来重建数据库。</p>
<p>使用 nologin 来临时阻止所有用户登录(root除外)。用户登录时将会显示 nologin 中的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;Sorry no login now&quot; &gt; /etc/nologin       # (Linux)</span><br><span class="line"># echo &quot;Sorry no login now&quot; &gt; /var/run/nologin   # (FreeBSD)</span><br></pre></td></tr></table></figure>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>某些应用程序需要设置可打开最大文件和 socket 数量(像代理服务器，数据库)。 默认限制通常很低。<br>Linux</p>
<p>每 shell/脚本</p>
<p>shell 的限制是受 ulimit 支配的。使用 ulimit -a 可查看其状态信息。 举个例子，改变可打开最大文件数从 1024 到 10240，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ulimit -n 10240                    # 这只在shell中有用</span><br></pre></td></tr></table></figure>
<p>ulimit 命令可以使用在脚本中来更改对此脚本的限制。</p>
<p>每 用户/进程</p>
<p>登录用户和应用程序的限制可以在 /etc/security/limits.conf 中配置。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/security/limits.conf</span><br><span class="line">*   hard    nproc   250              # 限制所有用户进程数</span><br><span class="line">asterisk hard nofile 409600          # 限制应用程序可打开最大文件数</span><br><span class="line">系统级</span><br></pre></td></tr></table></figure>
<p>用sysctl来设置内核限制。要使其永久，可以在 /etc/sysctl.conf 中进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -a                          # 显示所有系统限制</span><br><span class="line"># sysctl fs.file-max                 # 显示系统最大文件打开数</span><br><span class="line"># sysctl fs.file-max=102400          # 更改系统最大文件打开数</span><br><span class="line"># cat /etc/sysctl.conf</span><br><span class="line">fs.file-max=102400                   # 在 sysctl.conf 中的永久项</span><br><span class="line"># cat /proc/sys/fs/file-nr           # 在使用的文件句柄数</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<p>每 shell/脚本</p>
<p>在 csh 或 tcsh 中使用 limits 命令，在 sh 或 bash 中使用 ulimit 命令。</p>
<p>每 用户/进程</p>
<p>在 /etc/login.conf 中配置登录后的默认限制。未作限制的值为系统最大限制值。</p>
<p>系统级</p>
<p>内核限制同样使用 sysctl 来设置。永久配置，在 /etc/sysctl.conf 或 /boot/loader.conf 中。其语法与 Linux 相同，只是键值不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -a                          # 显示所有系统限制</span><br><span class="line"># sysctl kern.maxfiles=XXXX          # 最大文件描述符数</span><br><span class="line">kern.ipc.nmbclusters=32768           # 在 /etc/sysctl.conf 中的永久项</span><br><span class="line">kern.maxfiles=65536                  # Squid 通常用这个值</span><br><span class="line">kern.maxfilesperproc=32768</span><br><span class="line">kern.ipc.somaxconn=8192              # TCP 列队。apache/sendmail 最好用这个值</span><br><span class="line"># sysctl kern.openfiles              # 在使用的文件描述符数</span><br><span class="line"># sysctl kern.ipc.numopensockets     # 已经开启的 socket 数目</span><br></pre></td></tr></table></figure>
<p>详情请看 FreeBSD 手册 11章。</p>
<p>Solaris</p>
<p>在 /etc/system 中的下列设置，会提高每个进程可以打开最大文件描述符的数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set rlim_fd_max = 4096               # 一个进程可以打开文件描述符的&quot;硬&quot;限制</span><br><span class="line">set rlim_fd_cur = 1024               # 一个进程可以打开文件描述符的&quot;软&quot;限制</span><br></pre></td></tr></table></figure>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>Linux</p>
<p>一旦内核加载完成，内核会启动 init 进程，然后运行 rc 脚本，之后运行所有属于其运行级别的命令脚本。这些脚本都储存在 /etc/rc.d/rcN.d 中(N代表运行级别)，并且都建立着到 /etc/init.d 子目录中命令脚本程序的符号链接。<br>默认运行级别配置在 /etc/inittab 中。它通常为 3 或 5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep default: /etc/inittab                                         </span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>
<p>可以使用 init 来改变当前运行级别。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># init 5                             # 进入运行级别 5</span><br></pre></td></tr></table></figure>
<p>运行级别列表如下：<br>0       系统停止<br>1       进入单用户模式(也可以是 S)<br>2       没有 NFS 特性的多用户模式<br>3       完全多用户模式(正常操作模式)<br>4       未使用<br>5       类似于级别3，但提供 XWindow 系统登录环境<br>6       重新启动系统<br>使用 chkconfig 工具控制程序在一个运行级别启动和停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig --list                   # 列出所有 init 脚本</span><br><span class="line"># chkconfig --list sshd              # 查看 sshd 在各个运行级别中的启动配置</span><br><span class="line"># chkconfig sshd --level 35 on       # 对 sshd 在级别 3 和 5 下创建启动项</span><br><span class="line"># chkconfig sshd off                 # 在所有的运行级别下禁用 sshd</span><br></pre></td></tr></table></figure>
<p>Debian 和基于Debian 发行版像 Ubuntu 或 Knoppix 使用命令 update-rc.d 来管理运行级别脚本。默认启动为 2,3,4 和 5，停止为 0,1 和 6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># update-rc.d sshd defaults          # 设置 sshd 为默认启动级别</span><br><span class="line"># update-rc.d sshd start 20 2 3 4 5 . stop 20 0 1 6 .  # 用显示参数</span><br><span class="line"># update-rc.d -f sshd remove         # 在所有的运行级别下禁用 sshd</span><br><span class="line"># shutdown -h now (或者 # poweroff)  # 关闭停止系统</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<p>BSD 启动步骤不同于 SysV, 她没有运行级别。她的启动状态(单用户，有或没有 XWindow)被配置在 /etc/ttys中。所有的系统脚本都位于 /etc/rc.d/中，第三方应用程序位于 /usr/local/etc/rc.d/中。service 的启动顺序被配置在 /etc/rc.conf 和/etc/rc.conf.local中。默认行为可在 /etc/defaults/rc.conf 中进行配置。 这些脚本至少响应 start|stop|status.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/rc.d/sshd status</span><br><span class="line">sshd is running as pid 552.</span><br><span class="line"># shutdown now                       # 进入单用户模式</span><br><span class="line"># exit                               # 返回到多用户模式</span><br><span class="line"># shutdown -p now                    # 关闭停止系统</span><br><span class="line"># shutdown -r now                    # 重新启动系统</span><br></pre></td></tr></table></figure>
<p>同样可以使用进程 init 进入下列状态级别。举个例子： # init 6 为重启。<br>0       停止系统并关闭电源 (信号 USR2)<br>1       进入单用户模式 (信号 TERM)<br>6       重新启动 (信号 INT)<br>c       阻止进一步登录 (信号 TSTP)<br>q       重新检查 ttys(5) 文件 (信号 HUP)</p>
<h2 id="重设-root-密码"><a href="#重设-root-密码" class="headerlink" title="重设 root 密码"></a>重设 root 密码</h2><p>Linux 方法 1</p>
<p>在引导加载器(lilo 或 grub)中，键入如下启选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init=/bin/sh</span><br></pre></td></tr></table></figure></p>
<p>内核会挂载 root 分区，进程 init 会启动 bourne shell 而不是 rc，然后是运行级别。使用命令 passwd 设置密码然后重启。别忘了需要在单用户模式下做这些动作。<br>如果重启后 root 分区被挂载为只读，重新挂在它为读写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mount -o remount,rw /</span><br><span class="line"># passwd                             # 或者删除 root 密码 (/etc/shadow)</span><br><span class="line"># sync; mount -o remount,ro /        # sync 在重新挂在为只读之前 sync 一下</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure>
<p>FreeBSD 和 Linux 方法 2</p>
<p>FreeBSD 不会让你这么做。解决方案是用其他操作系统(像系统紧急修复光盘)挂载 root 分区，然后更改密码。<br>用 live cd 或安装盘启动进入修复模式后，会得到一个 shell。<br>用 fdisk 查找 root 分区。比如：fdisk /dev/sda<br>挂载它并使用 chroot 命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mount -o rw /dev/ad4s3a /mnt</span><br><span class="line"># chroot /mnt                        # 改变程序执行时所参考的根目录位置为 /mnt</span><br><span class="line"># passwd</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure>
<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># lsmod                              # 列出所有已载入内核的模块</span><br><span class="line"># modprobe isdn                      # 载入 isdn 模块</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kldstat                            # 列出所有已载入内核的模块</span><br><span class="line"># kldload crypto                     # 载入 crypto 模块</span><br></pre></td></tr></table></figure>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/src/linux</span><br><span class="line"># make mrproper                      # 清除所有东西，包括配置文件</span><br><span class="line"># make oldconfig                     # 从当前内核配置文件的基础上创建一个新的配置文件</span><br><span class="line"># make menuconfig                    # 或者 xconfig (Qt) 或者 gconfig (GTK)</span><br><span class="line"># make                               # 创建一个已压缩的内核映像文件</span><br><span class="line"># make modules                       # 编译模块</span><br><span class="line"># make modules_install               # 安装模块</span><br><span class="line"># make install                       # 安装内核</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<p>要改变和重建内核，需要拷贝源配置文件然后编辑它。当然也可以直接编辑 GENERIC 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/src/sys/i386/conf/</span><br><span class="line"># cp GENERIC MYKERNEL</span><br><span class="line"># cd /usr/src</span><br><span class="line"># make buildkernel KERNCONF=MYKERNEL</span><br><span class="line"># make installkernel KERNCONF=MYKERNEL</span><br></pre></td></tr></table></figure>
<p>要重建完全的操作系统：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># make buildworld                    # 构建完全的系统，但不是内核</span><br><span class="line"># make buildkernel                   # 使用 KERNCONF 配置文件编译内核</span><br><span class="line"># make installkernel</span><br><span class="line"># reboot</span><br><span class="line"># mergemaster -p                     # 建立临时根环境并比对系统配置文件</span><br><span class="line"># make installworld</span><br><span class="line"># mergemaster                        # 升级所有配置和其他文件</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure>
<p>对于源的一些小改动，有时候简单的命令就足够了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># make kernel world                  # 编译并安装内核和系统</span><br><span class="line"># mergemaster</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>列表 | 优先级 | 后台/前台 | Top | Kill</p>
<h2 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h2><p>PID是每个进程唯一号码。使用 ps 获取所有正在运行的进程列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ps -auxefw                         # 所有正在运行进程的详尽列表</span><br></pre></td></tr></table></figure>
<p>然而，更典型的用法是使用管道或者 pgrep:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ps axww | grep cron</span><br><span class="line">  586  ??  Is     0:01.48 /usr/sbin/cron -s</span><br><span class="line"># ps aux | grep &apos;ss[h]&apos;              # Find all ssh pids without the grep pid</span><br><span class="line"># pgrep -l sshd                      # 查找所有进程名中有sshd的进程ID</span><br><span class="line"># echo $$                            # The PID of your shell</span><br><span class="line"># fuser -va 22/tcp                   # 列出使用端口22的进程</span><br><span class="line"># fuser -va /home                    # 列出访问 /home 分区的进程</span><br><span class="line"># strace df                          # 跟踪系统调用和信号</span><br><span class="line"># truss df                           # 同上(FreeBSD/Solaris/类Unix)</span><br><span class="line"># history | tail -50                 # 显示最后50个使用过的命令</span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>用 renice 更改正在运行进程的优先级。负值是更高的优先级，最小为-20，其正值与 “nice” 值的意义相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># renice -5 586                      # 更强的优先级</span><br><span class="line">586: old priority 0, new priority -5</span><br></pre></td></tr></table></figure>
<p>使用 nice 命令启动一个已定义优先级的进程。 正值为低优先级，负值为高优先级。确定你知道 /usr/bin/nice 或者使用 shell 内置命令(# which nice)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># nice -n -5 top                     # 更高优先级(/usr/bin/nice)</span><br><span class="line"># nice -n 5 top                      # 更低优先级(/usr/bin/nice)</span><br><span class="line"># nice +5 top                        # tcsh 内置 nice 命令(同上)</span><br></pre></td></tr></table></figure>
<p>nice 可以影响 CPU 的调度，另一个实用命令 ionice 可以调度磁盘 IO。This is very useful for intensive IO application which can bring a machine to its knees while still in a lower priority. 此命令仅可在 Linux (AFAIK) 上使用。你可以选择一个类型(idle - best effort - real time)，它的 man 页很短并有很好的解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ionice c3 -p123                    # 给 pid 123 设置为 idle 类型</span><br><span class="line"># ionice -c2 -n0 firefox             # 用 best effort 类型运行 firefox 并且设为高优先级</span><br><span class="line"># ionice -c3 -p$$                    # 将当前的进程(shell)的磁盘 IO 调度设置为 idle </span><br><span class="line">类型</span><br></pre></td></tr></table></figure>
<p>例中最后一条命令对于编译(或调试)一个大型项目会非常有用。每一个运行于此 shell 的命令都会有一个较低的优先级，但并不妨碍这个系统。$$ 是你 shell 的 pid (试试 echo $$)。</p>
<h2 id="前台-后台"><a href="#前台-后台" class="headerlink" title="前台/后台"></a>前台/后台</h2><p>当一个进程在 shell 中已运行，可以使用 [Ctrl]-[Z] (^Z), bg 和 fg 来 调入调出前后台。举个例子：启动 2 个进程，调入后台。使用 jobs 列出后台列表，然后再调入一个进程到前台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ping cb.vu &gt; ping.log</span><br><span class="line">^Z                                   # ping 使用 [Ctrl]-[Z] 来暂停(停止) </span><br><span class="line"># bg                                 # 调入后台继续运行</span><br><span class="line"># jobs -l                            # 后台进程列表</span><br><span class="line">[1]  - 36232 Running                       ping cb.vu &gt; ping.log</span><br><span class="line">[2]  + 36233 Suspended (tty output)        top</span><br><span class="line"># fg %2                              # 让进程 2 返回到前台运行</span><br></pre></td></tr></table></figure>
<p>使用 nohup 开启一个持续运行的进程直到 shell 被关闭(避免挂断)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># nohup ping -i 60 &gt; ping.log &amp;</span><br></pre></td></tr></table></figure>
<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><p>top 程序用来实时显示系统中各个进程的运行信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br></pre></td></tr></table></figure>
<p>当 top 在运行的时候，按下 h 键会显示帮助画面。常用键如下：</p>
<ul>
<li>u [用户名] 只显示属于此用户的进程。使用 + 或者空白可以查看所有用户</li>
<li>k [PID] 结束 PID 进程</li>
<li>1 显示所有进程状态信息(只有Linux)</li>
<li>R 将当前排序倒转</li>
</ul>
<h2 id="Kill命令与信号"><a href="#Kill命令与信号" class="headerlink" title="Kill命令与信号"></a>Kill命令与信号</h2><p>使用 kill 或 killall 终止或发送一个信号给进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ping -i 60 cb.vu &gt; ping.log &amp;</span><br><span class="line">[1] 4712</span><br><span class="line"># kill -s TERM 4712                  # 同 kill -15 4712</span><br><span class="line"># killall -1 httpd                   # 发送 HUP 信号终止进程 httpd</span><br><span class="line"># pkill -9 http                      # 发送 TERM 信号终止包含 http 的进程</span><br><span class="line"># pkill -TERM -u www                 # 发送 TERM 信号终止 www 所有者进程</span><br><span class="line"># fuser -k -TERM -m /home            # 终止所有访问 /home 的进程(卸载该分区前)</span><br></pre></td></tr></table></figure>
<p>下面是一些重要的信号：</p>
<p>1       HUP (挂起)<br>2       INT (中断)<br>3       QUIT (退出)<br>9       KILL (KILL 信号不能被捕捉，不能被忽略。)<br>15     TERM (软件终止信号)</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>磁盘信息 | Boot | 磁盘使用情况 | 已打开的文件 | 挂载/重挂 | 挂载 SMB | 挂载映像文件 | Burn ISO | Create image | Memory disk | Disk performance</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>用 chmod 和 chown 更改访问权限和所有权。对于所有用户的默认掩码(umask)可以在 /etc/profile (Linux) 或 /etc/login.conf (FreeBSD) 中修改。其默认掩码(umask)通常为 022。掩码可以和777做减法，从而得到755的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 --x 执行                           # Mode 764 = 执行/读/写 | 读/写 | 读</span><br><span class="line">2 -w- 写                             # |---所有者|---用户组|---其他用户|</span><br><span class="line">4 r-- 读</span><br><span class="line">  ugo=a                              u=所有者, g=用户组, o=其他用户, a=所有用户</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># chmod [OPTION] MODE[,MODE] FILE    # MODE 可以是 [ugoa]*([-+=]([rwxXst]))</span><br><span class="line"># chmod 640 /var/log/maillog         # 更改 maillog 访问权限为 -rw-r-----</span><br><span class="line"># chmod u=rw,g=r,o= /var/log/maillog # 同上</span><br><span class="line"># chmod -R o-r /home/*               # 递归去除所有其他用户的可读权限</span><br><span class="line"># chmod u+s /path/to/prog            # 在可执行位设置 SUID (知道你在干什么!)</span><br><span class="line"># find / -perm -u+s -print           # 查找所有设置过 SUID 位的程序</span><br><span class="line"># chown user:group /path/to/file     # 改变文件的所有者和文件关联的组</span><br><span class="line"># chgrp group /path/to/file          # 改变文件关联的组</span><br><span class="line"># chmod 640 `find ./ -type f -print` # Change permissions to 640 for all files</span><br><span class="line"># chmod 751 `find ./ -type d -print` # Change permissions to 751 for all directories</span><br></pre></td></tr></table></figure>
<h2 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># diskinfo -v /dev/ad2               # 显示磁盘信息(扇区/大小) (FreeBSD)</span><br><span class="line"># hdparm -I /dev/sda                 # 显示 IDE/ATA 磁盘信息 (Linux)</span><br><span class="line"># fdisk /dev/ad2                     # 显示和修改磁盘分区表</span><br><span class="line"># smartctl -a /dev/ad2               # 显示磁盘检测信息</span><br></pre></td></tr></table></figure>
<h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><p>FreeBSD</p>
<p>如果新内核不能引导，要引导一个旧内核，停止启动倒计时，做如下动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># unload</span><br><span class="line"># load kernel.old</span><br><span class="line"># boot</span><br></pre></td></tr></table></figure>
<p>系统挂载点/磁盘使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount | column -t                  # 显示系统已挂载分区情况</span><br><span class="line"># df                                 # 显示磁盘剩余空间和挂载的设备</span><br><span class="line"># cat /proc/partitions               # 显示所有设备的所有分区(Linux)</span><br></pre></td></tr></table></figure>
<p>磁盘使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># du -sh *                           # 列出当前目录下所有文件夹大小</span><br><span class="line"># du -csh                            # 当前目录下所有目录大小总数</span><br><span class="line"># du -ks * | sort -n -r              # 由大到小排序显示目录大小</span><br><span class="line"># ls -lSr                            # 由小到大显示文件列表</span><br></pre></td></tr></table></figure>
<h2 id="谁打开了那些文件"><a href="#谁打开了那些文件" class="headerlink" title="谁打开了那些文件"></a>谁打开了那些文件</h2><p>对于找出哪些文件阻止卸载分区并给出有代表性的错误是有帮助的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># umount /home/</span><br><span class="line">umount: unmount of /home             # 不能卸载，因为有一个文件锁定了 home</span><br><span class="line">   failed: Device busy</span><br></pre></td></tr></table></figure>
<p>FreeBSD 和大多数 Unix</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># fstat -f /home                     # 对于一个挂载点</span><br><span class="line"># fstat -p PID                       # 对于一个应用程序进程 ID</span><br><span class="line"># fstat -u user                      # 对于一个用户</span><br></pre></td></tr></table></figure>
<p>查找已打开日志文件(或其他已打开文件)， 比如 Xorg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ps ax | grep Xorg | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">1252</span><br><span class="line"># fstat -p 1252</span><br><span class="line">USER     CMD          PID   FD MOUNT      INUM MODE         SZ|DV R/W</span><br><span class="line">root     Xorg        1252 root /             2 drwxr-xr-x     512  r</span><br><span class="line">root     Xorg        1252 text /usr     216016 -rws--x--x  1679848 r</span><br><span class="line">root     Xorg        1252    0 /var     212042 -rw-r--r--   56987  w</span><br></pre></td></tr></table></figure>
<p>在 /var 中的只有一个 inum 为 212042 的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># find -x /var -inum 212042</span><br><span class="line">/var/log/Xorg.0.log</span><br></pre></td></tr></table></figure>
<p>Linux</p>
<p>使用 fuser 或 lsof 在一个挂载点中查找已打开的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># fuser -m /home                     # 列出访问 /home 的进程</span><br><span class="line"># lsof /home</span><br><span class="line">COMMAND   PID    USER   FD   TYPE DEVICE    SIZE     NODE NAME</span><br><span class="line">tcsh    29029 eedcoba  cwd    DIR   0,18   12288  1048587 /home/eedcoba (guam:/home)</span><br><span class="line">lsof    29140 eedcoba  cwd    DIR   0,18   12288  1048587 /home/eedcoba (guam:/home)</span><br></pre></td></tr></table></figure>
<p>关于一个应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps ax | grep Xorg | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">3324</span><br><span class="line"># lsof -p 3324</span><br><span class="line">COMMAND   PID    USER   FD   TYPE DEVICE    SIZE    NODE NAME</span><br><span class="line">Xorg    3324 root    0w   REG        8,6   56296      12492 /var/log/Xorg.0.log</span><br></pre></td></tr></table></figure>
<p>关于单个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># lsof /var/log/Xorg.0.log</span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE  SIZE  NODE NAME</span><br><span class="line">Xorg    3324 root    0w   REG    8,6 56296 12492 /var/log/Xorg.0.log</span><br></pre></td></tr></table></figure>
<h2 id="挂载-重挂载一个文件系统"><a href="#挂载-重挂载一个文件系统" class="headerlink" title="挂载/重挂载一个文件系统"></a>挂载/重挂载一个文件系统</h2><p>举个 cdrom 的例子。如果已经列于 /etc/fstab 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount /cdrom</span><br></pre></td></tr></table></figure>
<p>或在 /dev/ 中查找设备，亦或使用 dmesg 命令<br>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount -v -t cd9660 /dev/cd0c /mnt  # cdrom</span><br><span class="line"># mount_cd9660 /dev/wcd0c /cdrom     # 另外一个方法</span><br><span class="line"># mount -v -t msdos /dev/fd0c /mnt   # 软驱</span><br></pre></td></tr></table></figure>
<p>/etc/fstab 中的一条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Device                Mountpoint      FStype  Options         Dump    Pass#</span><br><span class="line">/dev/acd0               /cdrom          cd9660  ro,noauto       0       0</span><br></pre></td></tr></table></figure>
<p>要允许用户做这些，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sysctl vfs.usermount=1  # 或者在 /etc/sysctl.conf 中插入一条 &quot;vfs.usermount=1&quot;</span><br></pre></td></tr></table></figure>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount -t auto /dev/cdrom /mnt/cdrom   # 典型的 cdrom 挂载命令</span><br><span class="line"># mount /dev/hdc -t iso9660 -r /cdrom   # IDE</span><br><span class="line"># mount /dev/sdc0 -t iso9660 -r /cdrom  # SCSI</span><br></pre></td></tr></table></figure>
<p>/etc/fstab 中的条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/cdrom   /media/cdrom  subfs noauto,fs=cdfss,ro,procuid,nosuid,nodev,exec 0 0</span><br></pre></td></tr></table></figure>
<p>用 Linux 挂载一个 FreeBSD 分区</p>
<p>用 fdisk 查找分区号，这通常是 root 分区，但也可能是其他 BSD slice。如果 FreeBSD 有许多 slice，他们不列于同一个 fdisk 分区表中，但可见于 /dev/sda<em> 或 /dev/hda</em> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># fdisk /dev/sda                     # 查找 FreeBSD 分区</span><br><span class="line">/dev/sda3   *        5357        7905    20474842+  a5  FreeBSD</span><br><span class="line"># mount -t ufs -o ufstype=ufs2,ro /dev/sda3 /mnt</span><br><span class="line">/dev/sda10 = /tmp; /dev/sda11 /usr   # 其他 slice</span><br></pre></td></tr></table></figure>
<p>重挂载</p>
<p>不用卸载一个设备来重挂载。 对 fsck 来说是必须的。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount -o remount,ro /              # Linux</span><br><span class="line"># mount -o ro /                      # FreeBSD</span><br></pre></td></tr></table></figure>
<p>从 cdrom 拷贝原始数据进一个 iso 映像文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/cd0c of=file.iso</span><br></pre></td></tr></table></figure>
<h2 id="给即时烧录-on-the-fly-添加-swap"><a href="#给即时烧录-on-the-fly-添加-swap" class="headerlink" title="给即时烧录(on-the-fly)添加 swap"></a>给即时烧录(on-the-fly)添加 swap</h2><p>假设你需要很多的 swap (即刻)，如一个 2GB 文件 /swap2gb (只限 Linux)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/zero of=/swap2gb bs=1024k count=2000</span><br><span class="line"># mkswap /swap2gb                    # 创建交换区</span><br><span class="line"># swapon /swap2gb                    # 激活这个 swap。现在可以使用了</span><br><span class="line"># swapoff /swap2gb                   # 当使用完毕，释放这个 swap</span><br><span class="line"># rm /swap2gb</span><br></pre></td></tr></table></figure>
<h2 id="挂载一个-SMB-共享"><a href="#挂载一个-SMB-共享" class="headerlink" title="挂载一个 SMB 共享"></a>挂载一个 SMB 共享</h2><p>假设我们要访问计算机 smbserver 上的名叫 myshare 的 SMB 共享，在 window PC 上键入的地址是 \smbserver\myshare\。我挂载到 /mnt/smbshare 上。注意 cifs 必须是 IP 或 DNS 名，不是 Windows 名字。<br>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># smbclient -U user -I 192.168.16.229 -L //smbshare/    # 列出共享</span><br><span class="line"># mount -t smbfs -o username=winuser //smbserver/myshare /mnt/smbshare</span><br><span class="line"># mount -t cifs -o username=winuser,password=winpwd //192.168.16.229/myshare /mnt/share</span><br></pre></td></tr></table></figure>
<p>此外，mount.cifs 软件包可以存储认证到一个文件中。例如，/home/user/.smb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=winuser</span><br><span class="line">password=winpwd</span><br></pre></td></tr></table></figure>
<p>现在可以像下面那样挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t cifs -o credentials=/home/user/.smb //192.168.16.229/myshare /mnt/smbshare</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<p>使用 -I 来获取 IP (或 DNS 名）；smbserver 是 Windows 名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># smbutil view -I 192.168.16.229 //winuser@smbserver    # 列出共享</span><br><span class="line"># mount_smbfs -I 192.168.16.229 //winuser@smbserver/myshare /mnt/smbshare</span><br></pre></td></tr></table></figure>
<h2 id="挂载镜像文件"><a href="#挂载镜像文件" class="headerlink" title="挂载镜像文件"></a>挂载镜像文件</h2><p>Linux loop-back</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount -t iso9660 -o loop file.iso /mnt                # 挂载 CD 镜像文件</span><br><span class="line"># mount -t ext3 -o loop file.img /mnt                   # 用 ext3 文件系统挂载镜像文件</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<p>用于存储设备 (如果需要做 # kldload md.ko 动作)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mdconfig -a -t vnode -f file.iso -u 0</span><br><span class="line"># mount -t cd9660 /dev/md0 /mnt</span><br><span class="line"># umount /mnt; mdconfig -d -u 0                         # 清除 md 设备</span><br></pre></td></tr></table></figure>
<p>用于虚拟节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vnconfig /dev/vn0c file.iso; mount -t cd9660 /dev/vn0c /mnt</span><br><span class="line"># umount /mnt; vnconfig -u /dev/vn0c                    # 清除 vn 设备</span><br></pre></td></tr></table></figure>
<p>Solaris and FreeBSD</p>
<p>用于 loop-back 文件接口或 lofi：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># lofiadm -a file.iso</span><br><span class="line"># mount -F hsfs -o ro /dev/lofi/1 /mnt</span><br><span class="line"># umount /mnt; lofiadm -d /dev/lofi/1                   # 清除 lofi 设备</span><br></pre></td></tr></table></figure>
<h2 id="创建并刻录-ISO-镜像文件"><a href="#创建并刻录-ISO-镜像文件" class="headerlink" title="创建并刻录 ISO 镜像文件"></a>创建并刻录 ISO 镜像文件</h2><p>这将会拷贝 CD 或者 DVD 的扇区。当不用 conv=notrunc，镜像文件会等于 CD 内容大小而非 CD 容量大小。看下面和 dd 例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/hdc of=/tmp/mycd.iso bs=2048 conv=notrunc</span><br></pre></td></tr></table></figure>
<p>使用 mkisofs 把目录中所有文件创建成 CD/DVD 镜像文件。克服文件名限制：-r 开启 Rock Ridge 扩展用于 Unix 系统，-J 开启 Joliet 扩展用于微软系统。-L 允许 ISO9660 文件名第一个字符为句点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkisofs -J -L -r -V TITLE -o imagefile.iso /path/to/dir</span><br></pre></td></tr></table></figure>
<p>对于 FreeBSD，mkisofs 可以到 port 的 sysutils/cdrtools 中找到。<br>刻录 ISO 镜像文件</p>
<p>FreeBSD</p>
<p>FreeBSD 默认情况下没有在 ATAPI 驱动上启用 DMA。DMA 可用 sysctl 命令启用，其参数如下，或者在 /boot/loader.conf 中添加如下条目：<br>hw.ata.ata_dma=”1”<br>hw.ata.atapi_dma=”1”<br>burncd 用于 ATAPI 驱动(burncd 为基本系统的一部分)，cdrecord (在 sysutils/cdrtools 中)用于 SCSI 驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># burncd -f /dev/acd0 data imagefile.iso fixate      # ATAPI 驱动</span><br><span class="line"># cdrecord -scanbus                  # 查找 burner 设备描述符(如 1,0,0)</span><br><span class="line"># cdrecord dev=1,0,0 imagefile.iso</span><br></pre></td></tr></table></figure>
<p>Linux</p>
<p>对于 Linux，同样使用 cdrecord 如上文所述。此外，它还可以使用本地 ATAPI 接口查找设备描述符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cdrecord dev=ATAPI -scanbus</span><br></pre></td></tr></table></figure>
<p>然后同上面一样烧录 CD/DVD。<br>dvd+rw-tools</p>
<p>dvd+rw-tools 工具包(FreeBSD: ports/sysutils/dvd+rw-tools)可以做上面的一切，其还包括 growisofs 工具来刻录 CD 或 DVD。本实例所引用的 DVD 设备 /dev/dvd 可能是指向 /dev/scd0 (Linux)的符号连接，或者 /dev/cd0 (FreeBSD)，或者 /dev/rcd0c (NetBSD/OpenBSD)，或者 /dev/rdsk/c0t1d0s2 (Solaris)。对于本实例 FreeBSD 手册 18.7 章 上有一份很好的文档。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -dvd-compat 选项将完结光盘，光盘便不可再附加数据</span><br><span class="line"># growisofs -dvd-compat -Z /dev/dvd=imagefile.iso     # 刻录已存在的 iso 镜像文件</span><br><span class="line"># growisofs -dvd-compat -Z /dev/dvd -J -R /p/to/data  # 直接刻录</span><br></pre></td></tr></table></figure>
<p>转换 Nero .nrg 文件成 .iso</p>
<p>Nero 简单的添加了 300KB 的头到一个常规的 iso 镜像文件中。我们可用 dd 工具来去除它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dd bs=1k if=imagefile.nrg of=imagefile.iso skip=300</span><br></pre></td></tr></table></figure>
<p>转换 bin/cue 镜像成 .iso</p>
<p>bchunk 程序可以做到这一点。在 FreeBSD 中，它在 port 的 sysutils/bchunk 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bchunk imagefile.bin imagefile.cue imagefile.iso</span><br></pre></td></tr></table></figure>
<h2 id="创建基于文件的镜像文件"><a href="#创建基于文件的镜像文件" class="headerlink" title="创建基于文件的镜像文件"></a>创建基于文件的镜像文件</h2><p>举个例子，一个使用文件 /usr/vdisk.img 的 1GB 分区。这里我们使用 vnode 0,但也可为 1。<br>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/random of=/usr/vdisk.img bs=1K count=1M</span><br><span class="line"># mdconfig -a -t vnode -f /usr/vdisk.img -u 0         # 创建设备 /dev/md1</span><br><span class="line"># bsdlabel -w /dev/md0</span><br><span class="line"># newfs /dev/md0c</span><br><span class="line"># mount /dev/md0c /mnt</span><br><span class="line"># umount /mnt; mdconfig -d -u 0; rm /usr/vdisk.img    # 清除 md 设备</span><br></pre></td></tr></table></figure>
<p>这个基于文件的镜像文件可以在 /etc/rc.conf 和 /etc/fstab 中配置成启动期间自动挂载。可用 # /etc/rc.d/mdconfig start (先用 # mdconfig -d -u 0 命令删除 md0 设备) 测试你的设置。<br>需要注意的是，那个自动设置仅工作于这个基于文件的镜像文件不在 root 分区中。原因是 /etc/rc.d/mdconfig 脚本早于启动就执行了，并且 root 分区仍然是只读的。脚本 /etc/rc.d/mdconfig2 之后，镜像文件将位于 root 分区外挂载。<br>/boot/loader.conf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md_load=&quot;YES&quot;</span><br></pre></td></tr></table></figure>
<p>/etc/rc.conf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mdconfig_md0=&quot;-t vnode -f /usr/vdisk.img&quot;          # /usr 不在 root 分区中</span><br></pre></td></tr></table></figure>
<p>/etc/fstab: (行后的两个 0 0 很重要，它告诉 fsck 忽略这个设备,现在还不存在。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/md0                /usr/vdisk      ufs     rw              0       0</span><br></pre></td></tr></table></figure>
<p>也可能在增加镜像文件的大小之后，如增大到 300MB。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># umount /mnt; mdconfig -d -u 0</span><br><span class="line"># dd if=/dev/zero bs=1m count=300 &gt;&gt; /usr/vdisk.img</span><br><span class="line"># mdconfig -a -t vnode -f /usr/vdisk.img -u 0</span><br><span class="line"># growfs /dev/md0</span><br><span class="line"># mount /dev/md0c /mnt                                # 文件分区现在为 300MB</span><br></pre></td></tr></table></figure></p>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/zero of=/usr/vdisk.img bs=1024k count=1024</span><br><span class="line"># mkfs.ext3 /usr/vdisk.img</span><br><span class="line"># mount -o loop /usr/vdisk.img /mnt</span><br><span class="line"># umount /mnt; rm /usr/vdisk.img                      # 清楚</span><br></pre></td></tr></table></figure>
<p>Linux with losetup</p>
<p>/dev/zero 比 urandom 更快，但对于加密来说却不够安全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/urandom of=/usr/vdisk.img bs=1024k count=1024</span><br><span class="line"># losetup /dev/loop0 /usr/vdisk.img                   # 创建并联结 /dev/loop0</span><br><span class="line"># mkfs.ext3 /dev/loop0</span><br><span class="line"># mount /dev/loop0 /mnt</span><br><span class="line"># losetup -a                                          # 查看已经挂载的 loop 设备</span><br><span class="line"># umount /mnt</span><br><span class="line"># losetup -d /dev/loop0                               # Detach</span><br><span class="line"># rm /usr/vdisk.img</span><br></pre></td></tr></table></figure>
<h2 id="创建基于内存的文件系统"><a href="#创建基于内存的文件系统" class="headerlink" title="创建基于内存的文件系统"></a>创建基于内存的文件系统</h2><p>基于内存的文件系统对于重量级 IO 应用程序来说非常快。怎样创建一个挂载到 /memdisk 的 64M 分区：<br>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount_mfs -o rw -s 64M md /memdisk</span><br><span class="line"># umount /memdisk; mdconfig -d -u 0                   # 清除该 md 设备</span><br><span class="line">md     /memdisk     mfs     rw,-s64M    0   0         # /etc/fstab 条目</span><br></pre></td></tr></table></figure>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t tmpfs -osize=64m tmpfs /memdisk</span><br></pre></td></tr></table></figure>
<h2 id="磁盘性能"><a href="#磁盘性能" class="headerlink" title="磁盘性能"></a>磁盘性能</h2><p>在 ad4s3c (/home) 分区上读写一个 1GB 的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># time dd if=/dev/ad4s3c of=/dev/null bs=1024k count=1000</span><br><span class="line"># time dd if=/dev/zero bs=1024k count=1000 of=/home/1Gb.file</span><br><span class="line"># hdparm -tT /dev/hda      # 仅限 Linux</span><br></pre></td></tr></table></figure>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>路由 | 额外 IP | 更改 MAC 地址 | 端口 | 防火墙 | IP 转发 | NAT | DNS | DHCP | 通信量 | QoS | NIS</p>
<p>调试 (也可看流量分析)</p>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ethtool eth0              # 显示以太网状态(replaces mii-diag)</span><br><span class="line"># ethtool -s eth0 speed 100 duplex full # 把网卡 eth0 速度改为 100兆/秒，采用全双工</span><br><span class="line"># ethtool -s eth0 autoneg off # 禁用自动协商模式</span><br><span class="line"># ethtool -p eth1           # 闪烁网络接口 LED 灯 - 如果支持的话，非常实用</span><br><span class="line"># ip link show              # 在 Linux 上显示所有网络接口(同 ifconfig 类似)</span><br><span class="line"># ip link set eth0 up       # 使设备激活(或Down掉)。同 &quot;ifconfig eth0 up&quot;</span><br><span class="line"># ip addr show              # 在 Linux 上显示所有 IP 地址(与 ifconfig 类似)</span><br><span class="line"># ip neigh show             # 与 arp -a 类似</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all             禁止ping通</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all             解除ping通</span><br></pre></td></tr></table></figure>
<p>其他系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig fxp0             # 查看 &quot;media&quot; 字段(FreeBSD)</span><br><span class="line"># arp -a                    # 查看路由(或主机) ARP 条目(所有系统)</span><br><span class="line"># ping cb.vu                # 第一个要试的事情...</span><br><span class="line"># traceroute cb.vu          # 列印到目的地的路由路径</span><br><span class="line"># ifconfig fxp0 media 100baseTX mediaopt full-duplex # 100兆/秒 全双工(FreeBSD)</span><br><span class="line"># netstat -s                # 对每个网络协议做系统级分析</span><br></pre></td></tr></table></figure>
<p>另一些命令，虽然不总是默认安装，但很好找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># arping 192.168.16.254     # 在网络层上 Ping</span><br><span class="line"># tcptraceroute -f 5 cb.vu  # 使用 tcp 替换 icmp 来跟踪，透过防火墙</span><br></pre></td></tr></table></figure>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>列印路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># route -n                  # Linux 或使用 &quot;ip route&quot;</span><br><span class="line"># netstat -rn               # Linux, BSD 和 UNIX</span><br><span class="line"># route print               # Windows</span><br></pre></td></tr></table></figure>
<p>添加删除路由</p>
<p>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># route add 212.117.0.0/16 192.168.1.1</span><br><span class="line"># route delete 212.117.0.0/16</span><br><span class="line"># route add default 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>永久的添加路由可在 /etc/rc.conf 配置文件中设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static_routes=&quot;myroute&quot;</span><br><span class="line">route_myroute=&quot;-net 212.117.0.0/16 192.168.1.1&quot;</span><br></pre></td></tr></table></figure>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># route add -net 192.168.20.0 netmask 255.255.255.0 gw 192.168.16.254</span><br><span class="line"># ip route add 192.168.20.0/24 via 192.168.16.254       # 等同于上面命令</span><br><span class="line"># route add -net 192.168.20.0 netmask 255.255.255.0 dev eth0</span><br><span class="line"># route add default gw 192.168.51.254</span><br><span class="line"># ip route add default via 192.168.51.254 dev eth0      # 等同于上面命令</span><br><span class="line"># route delete -net 192.168.20.0 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<p>Solaris</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># route add -net 192.168.20.0 -netmask 255.255.255.0 192.168.16.254</span><br><span class="line"># route add default 192.168.51.254 1                    # 1 = 通过此路由跳数减 1</span><br><span class="line"># route change default 192.168.50.254 1</span><br></pre></td></tr></table></figure>
<p>永久条目配置在 /etc/defaultrouter 中。</p>
<p>Windows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Route add 192.168.50.0 mask 255.255.255.0 192.168.51.253</span><br><span class="line"># Route add 0.0.0.0 mask 0.0.0.0 192.168.51.254</span><br></pre></td></tr></table></figure>
<p>使用 add -p 来是路由设置永久有效。</p>
<h2 id="配置额外的-IP-地址"><a href="#配置额外的-IP-地址" class="headerlink" title="配置额外的 IP 地址"></a>配置额外的 IP 地址</h2><p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 192.168.50.254 netmask 255.255.255.0       # 第一个 IP</span><br><span class="line"># ifconfig eth0:0 192.168.51.254 netmask 255.255.255.0     # 第二个 IP</span><br><span class="line"># ip addr add 192.168.50.254/24 dev eth0                   # 等价命令</span><br><span class="line"># ip addr add 192.168.51.254/24 dev eth0 label eth0:1</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig fxp0 inet 192.168.50.254/24                     # 第一个 IP</span><br><span class="line"># ifconfig fxp0 alias 192.168.51.254 netmask 255.255.255.0 # 第二个 IP</span><br></pre></td></tr></table></figure>
<p>永久条目设置在 /etc/rc.conf 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig_fxp0=&quot;inet 192.168.50.254  netmask 255.255.255.0&quot;</span><br><span class="line">ifconfig_fxp0_alias0=&quot;192.168.51.254 netmask 255.255.255.0&quot;</span><br></pre></td></tr></table></figure>
<p>Solaris</p>
<p>用 ifconfig -a 命令检查设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig hme0 plumb                                      # 启用网卡</span><br><span class="line"># ifconfig hme0 192.168.50.254 netmask 255.255.255.0 up    # 第一个 IP</span><br><span class="line"># ifconfig hme0:1 192.168.51.254 netmask 255.255.255.0 up  # 第二个 IP</span><br></pre></td></tr></table></figure>
<p>更改 MAC 地址</p>
<p>通常在你更改之前先停下网络接口。不要告诉我为什么你想改变 MAC 地址……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down</span><br><span class="line"># ifconfig eth0 hw ether 00:01:02:03:04:05      # Linux</span><br><span class="line"># ifconfig fxp0 link 00:01:02:03:04:05          # FreeBSD</span><br><span class="line"># ifconfig hme0 ether 00:01:02:03:04:05         # Solaris</span><br><span class="line"># sudo ifconfig en0 ether 00:01:02:03:04:05     # Mac OS X Tiger</span><br><span class="line"># sudo ifconfig en0 lladdr 00:01:02:03:04:05    # Mac OS X Leopard</span><br></pre></td></tr></table></figure>
<p>对于 Windows 已经有许多工具了。像 etherchange。或者看看 “Mac Makeup”, “smac”。<br>使用中的端口</p>
<p>监听打开的端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an | grep LISTEN</span><br><span class="line"># lsof -i                                       # 列出所有因特网连接(Linux)</span><br><span class="line"># socklist                                      # 列出打开的 socket (Linux)</span><br><span class="line"># sockstat -4                                   # 使用 socket 的应用程序列表(FreeBSD)</span><br><span class="line"># netstat -anp --udp --tcp | grep LISTEN        # Linux</span><br><span class="line"># netstat -tup                                  # 列出活跃的连接(Linux)</span><br><span class="line"># netstat -tupl                                 # 列出系统中正在监听的端口(Linux)</span><br><span class="line"># netstat -ano                                  # Windows</span><br></pre></td></tr></table></figure>
<p>防火墙</p>
<p>检查正在运行的防火墙(只是典型配置)：<br>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># iptables -L -n -v                  # 状态信息</span><br><span class="line">Open the iptables firewall</span><br><span class="line"># iptables -P INPUT       ACCEPT     # 打开所有</span><br><span class="line"># iptables -P FORWARD     ACCEPT</span><br><span class="line"># iptables -P OUTPUT      ACCEPT</span><br><span class="line"># iptables -Z                        # 把所有链的包及字节的计数器清空</span><br><span class="line"># iptables -F                        # 清空所有链</span><br><span class="line"># iptables -X                        # 删除所有链</span><br></pre></td></tr></table></figure>
<p>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ipfw show                          # 状态信息</span><br><span class="line"># ipfw list 65535 # 如果显示 &quot;65535 deny ip from any to any&quot;，那防火墙已被禁用</span><br><span class="line"># sysctl net.inet.ip.fw.enable=0     # 禁用</span><br><span class="line"># sysctl net.inet.ip.fw.enable=1     # 启用</span><br></pre></td></tr></table></figure>
<p>路由 IP 转发</p>
<p>Linux</p>
<p>查看然后启用 IP 转发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/net/ipv4/ip_forward     # 查看 IP 转发 0=禁用, 1=启用</span><br><span class="line"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>
<p>或者编辑 /etc/sysctl.conf：<br>net.ipv4.ip_forward = 1<br>FreeBSD</p>
<p>查看并启用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sysctl net.inet.ip.forwarding          # 查看 IP 转发 0=禁用, 1=启用</span><br><span class="line"># sysctl net.inet.ip.forwarding=1</span><br><span class="line"># sysctl net.inet.ip.fastforwarding=1    # 专用路由器或防火墙</span><br></pre></td></tr></table></figure>
<p>Permanent with entry in /etc/rc.conf:<br>gateway_enable=”YES”                     # 如果主机是网关则设置为 YES。<br>Solaris</p>
<h1 id="ndd-set-dev-ip-ip-forwarding-1-查看-IP-转发-0-禁用-1-启用"><a href="#ndd-set-dev-ip-ip-forwarding-1-查看-IP-转发-0-禁用-1-启用" class="headerlink" title="ndd -set /dev/ip ip_forwarding 1       # 查看 IP 转发 0=禁用, 1=启用"></a>ndd -set /dev/ip ip_forwarding 1       # 查看 IP 转发 0=禁用, 1=启用</h1><p>NAT - 网络地址转换</p>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE  # 激活 NAT</span><br><span class="line"># iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 20022 -j DNAT \</span><br><span class="line">--to 192.168.16.44:22           # 转发端口 20022 到内部 IP 端口(ssh)</span><br><span class="line"># iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 993:995 -j DNAT \</span><br><span class="line">--to 192.168.16.254:993:995     # 转发 993-995 范围端口</span><br><span class="line"># ip route flush cache</span><br><span class="line"># iptables -L -t nat            # 查看 NAT 状态信息</span><br></pre></td></tr></table></figure>
<p>使用 -D 替换 -A 来删除端口转发。<br>FreeBSD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># natd -s -m -u -dynamic -f /etc/natd.conf -n fxp0</span><br><span class="line">Or edit /etc/rc.conf with:</span><br><span class="line">firewall_enable=&quot;YES&quot;           # 设置 YES 来启用防火墙功能</span><br><span class="line">firewall_type=&quot;open&quot;            # 防火墙类型(看 /etc/rc.firewall)</span><br><span class="line">natd_enable=&quot;YES&quot;               # 启用 natd (如果 firewall_enable == YES)。</span><br><span class="line">natd_interface=&quot;tun0&quot;           # 公共的网络接口或要使用的 IP 地址。</span><br><span class="line">natd_flags=&quot;-s -m -u -dynamic -f /etc/natd.conf&quot;</span><br></pre></td></tr></table></figure>
<p>端口转发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/natd.conf </span><br><span class="line">same_ports yes</span><br><span class="line">use_sockets yes</span><br><span class="line">unregistered_only</span><br><span class="line"># redirect_port tcp insideIP:2300-2399 3300-3399  # 端口范围</span><br><span class="line">redirect_port udp 192.168.51.103:7777 7777</span><br></pre></td></tr></table></figure>
<p>DNS</p>
<p>在 unix 上，对于所有的网络接口的 DNS 条目都存储在 /etc/resolv.conf 文件中。主机域也储存在这个文件中。最小化配置如下：<br>nameserver 78.31.70.238<br>search sleepyowl.net intern.lab<br>domain sleepyowl.net<br>检查系统域名：</p>
<h1 id="hostname-d-等同于-dnsdomainname"><a href="#hostname-d-等同于-dnsdomainname" class="headerlink" title="hostname -d                        # 等同于 dnsdomainname"></a>hostname -d                        # 等同于 dnsdomainname</h1><p>Windows</p>
<p>在 Windows 上，DNS 配置于每个网络接口。要显示配置的 DNS 和清空 DNS 缓存可是使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ipconfig /?                        # 显示帮助</span><br><span class="line"># ipconfig /all                      # 显示所有信息包括 DNS</span><br><span class="line"># ipconfig /flushdns                 # 清除 DNS 缓存</span><br></pre></td></tr></table></figure>
<p>转发查询</p>
<p>Dig 是你测试 DNS 设置的好朋友。举个例子，用于测试的 DNS 服务器为 213.133.105.2 ns.second-ns.de。查看哪个服务器客户端接收应答(简单应答).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># dig sleepyowl.net</span><br><span class="line">sleepyowl.net.          600     IN      A       78.31.70.238</span><br><span class="line">;; SERVER: 192.168.51.254#53(192.168.51.254)</span><br></pre></td></tr></table></figure>
<p>路由器 192.168.51.254 应答了，并返回了一条 A 条目(记录)。任何条目都可查询，DNS 服务器可用 @ 来选定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># dig MX google.com</span><br><span class="line"># dig @127.0.0.1 NS sun.com          # 测试本地服务器</span><br><span class="line"># dig @204.97.212.10 NS MX heise.de  # 查询外部</span><br><span class="line"># dig AXFR @ns1.xname.org cb.vu      # 查看区传送(zone transfer)</span><br></pre></td></tr></table></figure>
<p>程式 host 也很强大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host -t MX cb.vu                   # 获取邮件 MX 记录</span><br><span class="line"># host -t NS -T sun.com              # 通过 TCP 连接获取 NS 记录</span><br><span class="line"># host -a sleepyowl.net              # 获取所有</span><br></pre></td></tr></table></figure>
<p>反向查询</p>
<p>查找属于一个 IP 地址(in-addr.arpa.)的域名。可用 dig, host 和 nslookup 命令查询：</p>
<h1 id="dig-x-78-31-70-238"><a href="#dig-x-78-31-70-238" class="headerlink" title="dig -x 78.31.70.238"></a>dig -x 78.31.70.238</h1><h1 id="host-78-31-70-238"><a href="#host-78-31-70-238" class="headerlink" title="host 78.31.70.238"></a>host 78.31.70.238</h1><h1 id="nslookup-78-31-70-238"><a href="#nslookup-78-31-70-238" class="headerlink" title="nslookup 78.31.70.238"></a>nslookup 78.31.70.238</h1><p>/etc/hosts</p>
<p>单个主机可以配置于文件 /etc/hosts 来代替本地正在运行的 named 反向域名查询。格式很简单，举个例子：<br>78.31.70.238   sleepyowl.net   sleepyowl<br>对于 hosts 文件和 DNS 查询之间的优先级，可在 /etc/nsswitch.conf 和 /etc/host.conf 中配置 order 名称解析。这个文件同样存在于 Windows 上，通常在：<br>C:\WINDOWS\SYSTEM32\DRIVERS\ETC<br>DHCP</p>
<p>Linux</p>
<p>一些发行版(SuSE)使用 dhcpcd 作为客户端。默认网络接口是 eth0。</p>
<h1 id="dhcpcd-n-eth0-触发更新-并不总是可以工作"><a href="#dhcpcd-n-eth0-触发更新-并不总是可以工作" class="headerlink" title="dhcpcd -n eth0           # 触发更新(并不总是可以工作)"></a>dhcpcd -n eth0           # 触发更新(并不总是可以工作)</h1><h1 id="dhcpcd-k-eth0-释放并关闭"><a href="#dhcpcd-k-eth0-释放并关闭" class="headerlink" title="dhcpcd -k eth0           # 释放并关闭"></a>dhcpcd -k eth0           # 释放并关闭</h1><p>租约(lease)的全部信息存储在：<br>/var/lib/dhcpcd/dhcpcd-eth0.info<br>FreeBSD</p>
<p>FreeBSD (和 Debian) 使用 dhclient。要配置一个网络接口(如：bge0)运行：</p>
<h1 id="dhclient-bge0"><a href="#dhclient-bge0" class="headerlink" title="dhclient bge0"></a>dhclient bge0</h1><p>租约(lease)的全部信息存储在：<br>/var/db/dhclient.leases.bge0<br>使用<br>/etc/dhclient.conf<br>设置 prepend 选项或强制不同的选项：</p>
<h1 id="cat-etc-dhclient-conf"><a href="#cat-etc-dhclient-conf" class="headerlink" title="cat /etc/dhclient.conf"></a>cat /etc/dhclient.conf</h1><p>interface “rl0” {<br>    prepend domain-name-servers 127.0.0.1;<br>    default domain-name “sleepyowl.net”;<br>    supersede domain-name “sleepyowl.net”;<br>}<br>Windows</p>
<p>dhcp 租约(lease)使用 ipconfig 来更新：</p>
<h1 id="ipconfig-renew-更新所有适配器"><a href="#ipconfig-renew-更新所有适配器" class="headerlink" title="ipconfig /renew          # 更新所有适配器"></a>ipconfig /renew          # 更新所有适配器</h1><h1 id="ipconfig-renew-LAN-更新名叫-“LAN”-的适配器"><a href="#ipconfig-renew-LAN-更新名叫-“LAN”-的适配器" class="headerlink" title="ipconfig /renew LAN      # 更新名叫 “LAN” 的适配器"></a>ipconfig /renew LAN      # 更新名叫 “LAN” 的适配器</h1><h1 id="ipconfig-release-WLAN-释放名叫-“WLAN”-的适配器"><a href="#ipconfig-release-WLAN-释放名叫-“WLAN”-的适配器" class="headerlink" title="ipconfig /release WLAN   # 释放名叫 “WLAN” 的适配器"></a>ipconfig /release WLAN   # 释放名叫 “WLAN” 的适配器</h1><p>是的，这是一个使用简单名称重新命名你的适配器的好主意！<br>通信量分析(Traffic analysis)</p>
<p>Bmon 是一个小的流量监控控制台，而且可以显示不同的网络接口的流量。<br>用 tcpdump 嗅探(sniff)</p>
<h1 id="tcpdump-nl-i-bge0-not-port-ssh-and-src-192-168-16-121-or-192-168-16-54"><a href="#tcpdump-nl-i-bge0-not-port-ssh-and-src-192-168-16-121-or-192-168-16-54" class="headerlink" title="tcpdump -nl -i bge0 not port ssh and src (192.168.16.121 or 192.168.16.54)"></a>tcpdump -nl -i bge0 not port ssh and src (192.168.16.121 or 192.168.16.54)</h1><h1 id="tcpdump-l-gt-dump-amp-amp-tail-f-dump-缓冲输出"><a href="#tcpdump-l-gt-dump-amp-amp-tail-f-dump-缓冲输出" class="headerlink" title="tcpdump -l &gt; dump &amp;&amp; tail -f dump               # 缓冲输出"></a>tcpdump -l &gt; dump &amp;&amp; tail -f dump               # 缓冲输出</h1><h1 id="tcpdump-i-rl0-w-traffic-rl0-把数据报文写入二进制文件"><a href="#tcpdump-i-rl0-w-traffic-rl0-把数据报文写入二进制文件" class="headerlink" title="tcpdump -i rl0 -w traffic.rl0                   # 把数据报文写入二进制文件"></a>tcpdump -i rl0 -w traffic.rl0                   # 把数据报文写入二进制文件</h1><h1 id="tcpdump-r-traffic-rl0-从文件读取数据报文-也可以使用-ethereal"><a href="#tcpdump-r-traffic-rl0-从文件读取数据报文-也可以使用-ethereal" class="headerlink" title="tcpdump -r traffic.rl0                          # 从文件读取数据报文(也可以使用 ethereal)"></a>tcpdump -r traffic.rl0                          # 从文件读取数据报文(也可以使用 ethereal)</h1><h1 id="tcpdump-port-80-两个经典命令"><a href="#tcpdump-port-80-两个经典命令" class="headerlink" title="tcpdump port 80                                 # 两个经典命令"></a>tcpdump port 80                                 # 两个经典命令</h1><h1 id="tcpdump-host-google-com"><a href="#tcpdump-host-google-com" class="headerlink" title="tcpdump host google.com"></a>tcpdump host google.com</h1><h1 id="tcpdump-i-eth0-X-port-110-or-143-查看端口-110-POP-或-143-IMAP-的数据报文"><a href="#tcpdump-i-eth0-X-port-110-or-143-查看端口-110-POP-或-143-IMAP-的数据报文" class="headerlink" title="tcpdump -i eth0 -X port (110 or 143)          # 查看端口 110(POP) 或 143(IMAP)的数据报文"></a>tcpdump -i eth0 -X port (110 or 143)          # 查看端口 110(POP) 或 143(IMAP)的数据报文</h1><h1 id="tcpdump-n-i-eth0-icmp-只捕获-ping"><a href="#tcpdump-n-i-eth0-icmp-只捕获-ping" class="headerlink" title="tcpdump -n -i eth0 icmp                         # 只捕获 ping"></a>tcpdump -n -i eth0 icmp                         # 只捕获 ping</h1><h1 id="tcpdump-i-eth0-s-0-A-port-80-grep-GET-s-0-为全部包-A-为-ASCII"><a href="#tcpdump-i-eth0-s-0-A-port-80-grep-GET-s-0-为全部包-A-为-ASCII" class="headerlink" title="tcpdump -i eth0 -s 0 -A port 80 | grep GET      # -s 0 为全部包, -A 为 ASCII"></a>tcpdump -i eth0 -s 0 -A port 80 | grep GET      # -s 0 为全部包, -A 为 ASCII</h1><p>另一些重要选项：<br>-A     显示每个包清晰文本(除了报头)<br>-X     显示包的 ASCII 文本<br>-l     使标准输出变为缓冲行形式<br>-D     显示所有可用网络接口<br>对于 Windows 可以使用 www.winpcap.org。使用 windump -D 来列出网络接口。<br>用 nmap 扫描</p>
<p>Nmap 是一个用于 OS 探测的端口扫描工具，她通常在许多发行版上有安装，并且同样可用于 Windows。如果你不扫描你的服务器，骇客们会为你做这些…</p>
<h1 id="nmap-cb-vu-扫描主机上所有保留的-TCP-端口"><a href="#nmap-cb-vu-扫描主机上所有保留的-TCP-端口" class="headerlink" title="nmap cb.vu               # 扫描主机上所有保留的 TCP 端口"></a>nmap cb.vu               # 扫描主机上所有保留的 TCP 端口</h1><h1 id="nmap-sP-192-168-16-0-24-找出在-0-24-上主机所使用的-IP"><a href="#nmap-sP-192-168-16-0-24-找出在-0-24-上主机所使用的-IP" class="headerlink" title="nmap -sP 192.168.16.0/24 # 找出在 0/24 上主机所使用的 IP"></a>nmap -sP 192.168.16.0/24 # 找出在 0/24 上主机所使用的 IP</h1><h1 id="nmap-sS-sV-O-cb-vu-做秘密-SYN-扫描来探测系统和系统服务的版本信息"><a href="#nmap-sS-sV-O-cb-vu-做秘密-SYN-扫描来探测系统和系统服务的版本信息" class="headerlink" title="nmap -sS -sV -O cb.vu    # 做秘密 SYN 扫描来探测系统和系统服务的版本信息"></a>nmap -sS -sV -O cb.vu    # 做秘密 SYN 扫描来探测系统和系统服务的版本信息</h1><p>PORT      STATE  SERVICE             VERSION<br>22/tcp    open   ssh                 OpenSSH 3.8.1p1 FreeBSD-20060930 (protocol 2.0)<br>25/tcp    open   smtp                Sendmail smtpd 8.13.6/8.13.6<br>80/tcp    open   http                Apache httpd 2.0.59 ((FreeBSD) DAV/2 PHP/4.<br>[…]<br>Running: FreeBSD 5.X<br>Uptime 33.120 days (since Fri Aug 31 11:41:04 2007)<br>其他非标准但好用的工具有 hping (www.hping.org)，她是一个 IP 分组组装/分析器，和 fping (fping.sourceforge.net)。fping 可以在一个循环队列(round-robin fashion)中扫描多种主机。<br>流量控制(QoS)</p>
<p>流量控制管理着一个网络的队列、流量监控、调度以及其他流量设置(traffic parameters)。以下简单实用的示例使用 Linux 和 FreeBSD 的能力来更好的利用带宽。<br>上传限制</p>
<p>DSL 或有线调制解调器有一个很长的列队来提高上传吞吐量(upload throughput)。然而用一个快速的设备(如以太网)填充这个列队将大大减少交互性。这就是限制设备上传速度有用的原因，以匹配调制解调器的实际能 力，这可以有效提高交互性。设置大约为 modem 最大速度的 90%。<br>Linux</p>
<p>给 512K 上传速度的 modem。</p>
<h1 id="tc-qdisc-add-dev-eth0-root-tbf-rate-480kbit-latency-50ms-burst-1540"><a href="#tc-qdisc-add-dev-eth0-root-tbf-rate-480kbit-latency-50ms-burst-1540" class="headerlink" title="tc qdisc add dev eth0 root tbf rate 480kbit latency 50ms burst 1540"></a>tc qdisc add dev eth0 root tbf rate 480kbit latency 50ms burst 1540</h1><h1 id="tc-s-qdisc-ls-dev-eth0-状态"><a href="#tc-s-qdisc-ls-dev-eth0-状态" class="headerlink" title="tc -s qdisc ls dev eth0                         # 状态"></a>tc -s qdisc ls dev eth0                         # 状态</h1><h1 id="tc-qdisc-del-dev-eth0-root-删除队列"><a href="#tc-qdisc-del-dev-eth0-root-删除队列" class="headerlink" title="tc qdisc del dev eth0 root                      # 删除队列"></a>tc qdisc del dev eth0 root                      # 删除队列</h1><h1 id="tc-qdisc-change-dev-eth0-root-tbf-rate-220kbit-latency-50ms-burst-1540"><a href="#tc-qdisc-change-dev-eth0-root-tbf-rate-220kbit-latency-50ms-burst-1540" class="headerlink" title="tc qdisc change dev eth0 root tbf rate 220kbit latency 50ms burst 1540"></a>tc qdisc change dev eth0 root tbf rate 220kbit latency 50ms burst 1540</h1><p>FreeBSD</p>
<p>FreeBSD 使用 dummynet 来控制带宽，其配置工具为 ipfw。Pipe 用来设置限制带宽的单位[K|M]{比特/秒|字节/秒}，0 意味着没有限制。使用同样的 pipe 数字可重新配置它。举个例子，限制上传带宽为 500K。</p>
<h1 id="kldload-dummynet-如有必要加载这个模块"><a href="#kldload-dummynet-如有必要加载这个模块" class="headerlink" title="kldload dummynet                                # 如有必要加载这个模块"></a>kldload dummynet                                # 如有必要加载这个模块</h1><h1 id="ipfw-pipe-1-config-bw-500Kbit-s-创建一个带宽限制的-pipe"><a href="#ipfw-pipe-1-config-bw-500Kbit-s-创建一个带宽限制的-pipe" class="headerlink" title="ipfw pipe 1 config bw 500Kbit/s                 # 创建一个带宽限制的 pipe"></a>ipfw pipe 1 config bw 500Kbit/s                 # 创建一个带宽限制的 pipe</h1><h1 id="ipfw-add-pipe-1-ip-from-me-to-any-转移所有上传进入这个-pipe"><a href="#ipfw-add-pipe-1-ip-from-me-to-any-转移所有上传进入这个-pipe" class="headerlink" title="ipfw add pipe 1 ip from me to any               # 转移所有上传进入这个 pipe"></a>ipfw add pipe 1 ip from me to any               # 转移所有上传进入这个 pipe</h1><p>服务质量 (Quality of service)</p>
<p>Linux</p>
<p>使用 tc 的优先级队列来优化 VoIP。在 voip-info.org 或 www.howtoforge.com 上可以看到完整的例子。假设 VoIP 使用 UDP 端口 10000:11024 并且使用 eth0 设备(也可为 ppp0 或 so)。下列命令定义了三个队列，并且用 QoS 0x1e(设置所有位) 强制 VOIP 流量到队列 1。默认流量流入队列 3，Qos Minimize-Delay 流入队列 2。</p>
<h1 id="tc-qdisc-add-dev-eth0-root-handle-1-prio-priomap-2-2-2-2-2-2-2-2-1-1-1-1-1-1-1-0"><a href="#tc-qdisc-add-dev-eth0-root-handle-1-prio-priomap-2-2-2-2-2-2-2-2-1-1-1-1-1-1-1-0" class="headerlink" title="tc qdisc add dev eth0 root handle 1: prio priomap 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 0"></a>tc qdisc add dev eth0 root handle 1: prio priomap 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 0</h1><h1 id="tc-qdisc-add-dev-eth0-parent-1-1-handle-10-sfq"><a href="#tc-qdisc-add-dev-eth0-parent-1-1-handle-10-sfq" class="headerlink" title="tc qdisc add dev eth0 parent 1:1 handle 10: sfq"></a>tc qdisc add dev eth0 parent 1:1 handle 10: sfq</h1><h1 id="tc-qdisc-add-dev-eth0-parent-1-2-handle-20-sfq"><a href="#tc-qdisc-add-dev-eth0-parent-1-2-handle-20-sfq" class="headerlink" title="tc qdisc add dev eth0 parent 1:2 handle 20: sfq"></a>tc qdisc add dev eth0 parent 1:2 handle 20: sfq</h1><h1 id="tc-qdisc-add-dev-eth0-parent-1-3-handle-30-sfq"><a href="#tc-qdisc-add-dev-eth0-parent-1-3-handle-30-sfq" class="headerlink" title="tc qdisc add dev eth0 parent 1:3 handle 30: sfq"></a>tc qdisc add dev eth0 parent 1:3 handle 30: sfq</h1><h1 id="tc-filter-add-dev-eth0-protocol-ip-parent-1-prio-1-u32"><a href="#tc-filter-add-dev-eth0-protocol-ip-parent-1-prio-1-u32" class="headerlink" title="tc filter add dev eth0 protocol ip parent 1: prio 1 u32 \"></a>tc filter add dev eth0 protocol ip parent 1: prio 1 u32 \</h1><p>  match ip dport 10000 0x3C00 flowid 1:1          # 使用服务端端口范围<br>  match ip dst 123.23.0.1 flowid 1:1              # 或/和使用服务器 IP<br>状态和移除：</p>
<h1 id="tc-s-qdisc-ls-dev-eth0-queue-status"><a href="#tc-s-qdisc-ls-dev-eth0-queue-status" class="headerlink" title="tc -s qdisc ls dev eth0                         # queue status"></a>tc -s qdisc ls dev eth0                         # queue status</h1><h1 id="tc-qdisc-del-dev-eth0-root-delete-all-QoS"><a href="#tc-qdisc-del-dev-eth0-root-delete-all-QoS" class="headerlink" title="tc qdisc del dev eth0 root                      # delete all QoS"></a>tc qdisc del dev eth0 root                      # delete all QoS</h1><p>计算端口范围和掩码 (mask)</p>
<p>用你所计算的端口掩码来定义 tc 过滤器的端口范围。查询 2^N 端口范围结尾，推断范围并转换成十六进制。这就是你的掩码 (mask)。例如 10000 -&gt; 11024，它的范围是 1024。</p>
<h1 id="2-13-8192-lt-10000-lt-2-14-16384-结尾是-2-14-16384"><a href="#2-13-8192-lt-10000-lt-2-14-16384-结尾是-2-14-16384" class="headerlink" title="2^13 (8192) &lt; 10000 &lt; 2^14 (16384)              # 结尾是 2^14 = 16384"></a>2^13 (8192) &lt; 10000 &lt; 2^14 (16384)              # 结尾是 2^14 = 16384</h1><h1 id="echo-“obase-16-2-14-1024”-bc-掩码是-0x3C00"><a href="#echo-“obase-16-2-14-1024”-bc-掩码是-0x3C00" class="headerlink" title="echo “obase=16;(2^14)-1024” | bc                # 掩码是 0x3C00"></a>echo “obase=16;(2^14)-1024” | bc                # 掩码是 0x3C00</h1><p>FreeBSD</p>
<p>假设最大连接带宽为 500Kbit/s，我们使用优先级 100:10:1 定义 3 个队列给 VoIP:ssh:剩余所有。</p>
<h1 id="ipfw-pipe-1-config-bw-500Kbit-s"><a href="#ipfw-pipe-1-config-bw-500Kbit-s" class="headerlink" title="ipfw pipe 1 config bw 500Kbit/s"></a>ipfw pipe 1 config bw 500Kbit/s</h1><h1 id="ipfw-queue-1-config-pipe-1-weight-100"><a href="#ipfw-queue-1-config-pipe-1-weight-100" class="headerlink" title="ipfw queue 1 config pipe 1 weight 100"></a>ipfw queue 1 config pipe 1 weight 100</h1><h1 id="ipfw-queue-2-config-pipe-1-weight-10"><a href="#ipfw-queue-2-config-pipe-1-weight-10" class="headerlink" title="ipfw queue 2 config pipe 1 weight 10"></a>ipfw queue 2 config pipe 1 weight 10</h1><h1 id="ipfw-queue-3-config-pipe-1-weight-1"><a href="#ipfw-queue-3-config-pipe-1-weight-1" class="headerlink" title="ipfw queue 3 config pipe 1 weight 1"></a>ipfw queue 3 config pipe 1 weight 1</h1><h1 id="ipfw-add-10-queue-1-proto-udp-dst-port-10000-11024"><a href="#ipfw-add-10-queue-1-proto-udp-dst-port-10000-11024" class="headerlink" title="ipfw add 10 queue 1 proto udp dst-port 10000-11024"></a>ipfw add 10 queue 1 proto udp dst-port 10000-11024</h1><h1 id="ipfw-add-11-queue-1-proto-udp-dst-ip-123-23-0-1-或-和使用服务器-IP"><a href="#ipfw-add-11-queue-1-proto-udp-dst-ip-123-23-0-1-或-和使用服务器-IP" class="headerlink" title="ipfw add 11 queue 1 proto udp dst-ip 123.23.0.1 # 或/和使用服务器 IP"></a>ipfw add 11 queue 1 proto udp dst-ip 123.23.0.1 # 或/和使用服务器 IP</h1><h1 id="ipfw-add-20-queue-2-dsp-port-ssh"><a href="#ipfw-add-20-queue-2-dsp-port-ssh" class="headerlink" title="ipfw add 20 queue 2 dsp-port ssh"></a>ipfw add 20 queue 2 dsp-port ssh</h1><h1 id="ipfw-add-30-queue-3-from-me-to-any-剩余所有"><a href="#ipfw-add-30-queue-3-from-me-to-any-剩余所有" class="headerlink" title="ipfw add 30 queue 3 from me to any              # 剩余所有"></a>ipfw add 30 queue 3 from me to any              # 剩余所有</h1><p>状态和移除：</p>
<h1 id="ipfw-list-规则信息"><a href="#ipfw-list-规则信息" class="headerlink" title="ipfw list                                       # 规则信息"></a>ipfw list                                       # 规则信息</h1><h1 id="ipfw-pipe-list-管道信息"><a href="#ipfw-pipe-list-管道信息" class="headerlink" title="ipfw pipe list                                  # 管道信息"></a>ipfw pipe list                                  # 管道信息</h1><h1 id="ipfw-flush-删除除默认外所有规则"><a href="#ipfw-flush-删除除默认外所有规则" class="headerlink" title="ipfw flush                                      # 删除除默认外所有规则"></a>ipfw flush                                      # 删除除默认外所有规则</h1><p>NIS 调试</p>
<p>一些可工作在已配置好的 NIS 客户端上的命令：</p>
<h1 id="ypwhich-获取提供-NIS-服务的服务器名"><a href="#ypwhich-获取提供-NIS-服务的服务器名" class="headerlink" title="ypwhich                  # 获取提供 NIS 服务的服务器名"></a>ypwhich                  # 获取提供 NIS 服务的服务器名</h1><h1 id="domainname-已配置的-NIS-域名"><a href="#domainname-已配置的-NIS-域名" class="headerlink" title="domainname               # 已配置的 NIS 域名"></a>domainname               # 已配置的 NIS 域名</h1><h1 id="ypcat-group-列印-NIS-映射-group"><a href="#ypcat-group-列印-NIS-映射-group" class="headerlink" title="ypcat group              # 列印 NIS 映射 group"></a>ypcat group              # 列印 NIS 映射 group</h1><h1 id="cd-var-yp-amp-amp-make-重建-yp-数据库"><a href="#cd-var-yp-amp-amp-make-重建-yp-数据库" class="headerlink" title="cd /var/yp &amp;&amp; make       # 重建 yp 数据库"></a>cd /var/yp &amp;&amp; make       # 重建 yp 数据库</h1><p>ypbind 正在运行吗？</p>
<h1 id="ps-auxww-grep-ypbind"><a href="#ps-auxww-grep-ypbind" class="headerlink" title="ps auxww | grep ypbind"></a>ps auxww | grep ypbind</h1><p>/usr/sbin/ypbind -s -m -S servername1,servername2   # FreeBSD<br>/usr/sbin/ypbind           # Linux</p>
<h1 id="yppoll-passwd-byname"><a href="#yppoll-passwd-byname" class="headerlink" title="yppoll passwd.byname"></a>yppoll passwd.byname</h1><p>Map passwd.byname has order number 1190635041. Mon Sep 24 13:57:21 2007<br>The master server is servername.domain.net.<br>Linux</p>
<h1 id="cat-etc-yp-conf"><a href="#cat-etc-yp-conf" class="headerlink" title="cat /etc/yp.conf"></a>cat /etc/yp.conf</h1><p>ypserver servername<br>domain domain.net broadcast<br>SSH SCP</p>
<p>公钥认证 | 指纹 | SCP | 隧道(Tunneling)</p>
<p>Public key authentication</p>
<p>使用公钥认证而不是密码连接主机。方法是附加你的公钥文件到远程主机。本例中我们用客户端产生的 key 从 host-client 连接到 host-server。<br>使用 ssh-keygen 生成密钥对。私钥放在 ~/.ssh/id_dsa，公钥在 ~/.ssh/id_dsa.pub。<br>拷贝你的公钥到服务器的 ~/.ssh/authorized_keys2。</p>
<h1 id="ssh-keygen-t-dsa-N-‘’"><a href="#ssh-keygen-t-dsa-N-‘’" class="headerlink" title="ssh-keygen -t dsa -N ‘’"></a>ssh-keygen -t dsa -N ‘’</h1><h1 id="cat-ssh-id-dsa-pub-ssh-you-host-server-“cat-gt-gt-ssh-authorized-keys2”"><a href="#cat-ssh-id-dsa-pub-ssh-you-host-server-“cat-gt-gt-ssh-authorized-keys2”" class="headerlink" title="cat ~/.ssh/id_dsa.pub | ssh you@host-server “cat - &gt;&gt; ~/.ssh/authorized_keys2”"></a>cat ~/.ssh/id_dsa.pub | ssh you@host-server “cat - &gt;&gt; ~/.ssh/authorized_keys2”</h1><p>使用来自 ssh.com 的 Windows 客户端</p>
<p>ssh.com 的非商业性版本的客户端可下载自它主 FTP 站点：ftp.ssh.com/pub/ssh/。 用 ssh.com 客户端产生的密钥需要在 OpenSSH 服务器上进行转换。可以使用 ssh-keygen 命令来完成。<br>使用 ssh.com 客户端创建一对密钥：Settings - User Authentication - Generate New….<br>我使用 DSA 密钥类型；密钥长度为 2048。<br>拷贝 ssh.com 客户端产生的公钥到服务器的 ~/.ssh 目录。<br>她的密钥对在 C:\Documents and Settings\%USERNAME%\Application Data\SSH\UserKeys。<br>在服务器上使用 ssh-keygen 转换公钥：</p>
<h1 id="cd-ssh"><a href="#cd-ssh" class="headerlink" title="cd ~/.ssh"></a>cd ~/.ssh</h1><h1 id="ssh-keygen-i-f-keyfilename-pub-gt-gt-authorized-keys2"><a href="#ssh-keygen-i-f-keyfilename-pub-gt-gt-authorized-keys2" class="headerlink" title="ssh-keygen -i -f keyfilename.pub &gt;&gt; authorized_keys2"></a>ssh-keygen -i -f keyfilename.pub &gt;&gt; authorized_keys2</h1><p>注意： 我们使用 DSA 密钥，使用 RSA 密钥也是可以的。这个密钥不受密码保护。<br>在 Windows 上使用 Putty</p>
<p>Putty 是一个简单并且自由的(MIT许可) ssh Windows 客户端。<br>使用 puTTYgen 程序创建密钥对。<br>保存密钥对(比如：C:\Documents and Settings\%USERNAME%.ssh).<br>拷贝公钥到服务器的 ~/.ssh 目录：</p>
<h1 id="scp-ssh-puttykey-pub-root-192-168-51-254-ssh"><a href="#scp-ssh-puttykey-pub-root-192-168-51-254-ssh" class="headerlink" title="scp .ssh/puttykey.pub root@192.168.51.254:.ssh/"></a>scp .ssh/puttykey.pub root@192.168.51.254:.ssh/</h1><p>使用 ssh-keygen 在 OpenSSH 服务器上转换这个公钥：</p>
<h1 id="cd-ssh-1"><a href="#cd-ssh-1" class="headerlink" title="cd ~/.ssh"></a>cd ~/.ssh</h1><h1 id="ssh-keygen-i-f-puttykey-pub-gt-gt-authorized-keys2"><a href="#ssh-keygen-i-f-puttykey-pub-gt-gt-authorized-keys2" class="headerlink" title="ssh-keygen -i -f puttykey.pub &gt;&gt; authorized_keys2"></a>ssh-keygen -i -f puttykey.pub &gt;&gt; authorized_keys2</h1><p>在 Putty 中设置指向私钥的位置：Connection - SSH - Auth<br>检查指纹</p>
<p>在首次连接时，SSH 会请求保存不知道的主机指纹。要避免中间人(man-in-the-middle)攻击，服务器的管理员可以发送密钥指纹给客户端，来让其在首次登陆时验证服务器的真实性。使用 ssh-keygen -l 获取服务器的指纹：</p>
<h1 id="ssh-keygen-l-f-etc-ssh-ssh-host-rsa-key-pub-RSA-密钥"><a href="#ssh-keygen-l-f-etc-ssh-ssh-host-rsa-key-pub-RSA-密钥" class="headerlink" title="ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub      # RSA 密钥"></a>ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub      # RSA 密钥</h1><p>2048 61:33:be:9b:ae:6c:36:31:fd:83:98:b7:99:2d:9f:cd /etc/ssh/ssh_host_rsa_key.pub</p>
<h1 id="ssh-keygen-l-f-etc-ssh-ssh-host-dsa-key-pub-DSA-密钥-默认"><a href="#ssh-keygen-l-f-etc-ssh-ssh-host-dsa-key-pub-DSA-密钥-默认" class="headerlink" title="ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub      # DSA 密钥(默认)"></a>ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub      # DSA 密钥(默认)</h1><p>2048 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee /etc/ssh/ssh_host_dsa_key.pub<br>现在客户端在连接到服务器时可验证其服务器的真实性：</p>
<h1 id="ssh-linda"><a href="#ssh-linda" class="headerlink" title="ssh linda"></a>ssh linda</h1><p>The authenticity of host ‘linda (192.168.16.54)’ can’t be established.<br>DSA key fingerprint is 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee.<br>Are you sure you want to continue connecting (yes/no)? yes<br>安全文件传输</p>
<p>一些简单的命令：</p>
<h1 id="scp-file-txt-host-two-tmp"><a href="#scp-file-txt-host-two-tmp" class="headerlink" title="scp file.txt host-two:/tmp"></a>scp file.txt host-two:/tmp</h1><h1 id="scp-joe-host-two-www-html-www-tmp"><a href="#scp-joe-host-two-www-html-www-tmp" class="headerlink" title="scp joe@host-two:/www/*.html /www/tmp"></a>scp joe@host-two:/www/*.html /www/tmp</h1><h1 id="scp-r-joe-host-two-www-www-tmp"><a href="#scp-r-joe-host-two-www-www-tmp" class="headerlink" title="scp -r joe@host-two:/www /www/tmp"></a>scp -r joe@host-two:/www /www/tmp</h1><p>在 Konqueror 或 Midnight 控制台中，用地址 fish://user@gate 来访问远程文件系统是可行的，就是比较慢而已。<br>此外，也可以用基于 SCP 文件系统客户端的 sshfs 来挂载一个远程目录。看 fuse sshfs.<br>隧道(Tunneling)</p>
<p>SSH 隧道可以让你通过 SSH 连接进行端口转发(转发/反向隧道)，从而确保了传输及端口访问的安全。它只能工作在 TCP 协议上。通常端口转发命令如下(也可看 ssh 和 NAT 实例)：</p>
<h1 id="ssh-L-localport-desthost-destport-user-gate-gate-为目标主机网关"><a href="#ssh-L-localport-desthost-destport-user-gate-gate-为目标主机网关" class="headerlink" title="ssh -L localport:desthost:destport user@gate  # gate 为目标主机网关"></a>ssh -L localport:desthost:destport user@gate  # gate 为目标主机网关</h1><h1 id="ssh-R-destport-desthost-localport-user-gate-转发你的-localport-到目标端口"><a href="#ssh-R-destport-desthost-localport-user-gate-转发你的-localport-到目标端口" class="headerlink" title="ssh -R destport:desthost:localport user@gate  # 转发你的 localport 到目标端口"></a>ssh -R destport:desthost:localport user@gate  # 转发你的 localport 到目标端口</h1><h1 id="ssh-X-user-gate-转发-X-程序"><a href="#ssh-X-user-gate-转发-X-程序" class="headerlink" title="ssh -X user@gate   # 转发 X 程序"></a>ssh -X user@gate   # 转发 X 程序</h1><p>这将会连接到 gate 并转发端口到目标主机 desthost:destport。注意 desthost 为 gate 中的目标主机名。因此，如果连接到了 gate，那么 desthost 就是 localhost。也可以做更多的端口转发。<br>在 gate 上直接转发</p>
<p>假设我们想访问在 gate 上运行的 CVS(2401端口) 和 HTTP(80端口)。下面是个简单的例子，desthost 就是 localhost，我们使用本的端口 8080 代替 80 端口，所以我们不需要 root 权限。一旦 ssh session 打开，二个服务就都可在本地端口访问。</p>
<h1 id="ssh-L-2401-localhost-2401-L-8080-localhost-80-user-gate"><a href="#ssh-L-2401-localhost-2401-L-8080-localhost-80-user-gate" class="headerlink" title="ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate"></a>ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate</h1><p>转发 Netbios 和远程桌面到第二个服务器</p>
<p>假设有一台在 gate 后面没有运行 ssh 的 Winodws SMB 服务器。我们需要访问 SMB 共享和远程桌面。</p>
<h1 id="ssh-L-139-smbserver-139-L-3388-smbserver-3389-user-gate"><a href="#ssh-L-139-smbserver-139-L-3388-smbserver-3389-user-gate" class="headerlink" title="ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate"></a>ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate</h1><p>现在这个 SMB 共享可以使用 \127.0.0.1\ 访问，但只能在本地共享关闭的情况下，因为本的共享也是在 139 端口监听的。<br>保持本的共享也是可行的，因此我们需要为这个通道使用新 IP 地址来新建一个虚拟设备，SMB 共享将会使用此地址连接。此外，本地 RDP 已经在 3389 端口监听了，所以我们选择端口 3388。对于这个例子，让我们使用一个虚拟 IP 地址 10.1.1.1。<br>对于 Putty 上使用源端口=10.1.1.1:139。它可以创建多重回路(multiple loop)设备和通道。在 Windows 2000 上，只有 Putty 为我工作。<br>对于 ssh.com 的客户端，要禁用 “Allow local connections only”。因为 ssh.com 客户端绑定了所有地址，所以只能连接单个共享。<br>现在用 IP 地址 10.1.1.1 创建回路(loopback)接口：</p>
<h1 id="系统-gt-控制面板-gt-添加硬件-是，我已经连接了此硬件-Y-添加新的硬件设备-在列表最下面-。"><a href="#系统-gt-控制面板-gt-添加硬件-是，我已经连接了此硬件-Y-添加新的硬件设备-在列表最下面-。" class="headerlink" title="系统-&gt;控制面板-&gt;添加硬件 # 是，我已经连接了此硬件(Y) # 添加新的硬件设备(在列表最下面)。"></a>系统-&gt;控制面板-&gt;添加硬件 # 是，我已经连接了此硬件(Y) # 添加新的硬件设备(在列表最下面)。</h1><h1 id="安装我手动选择的硬件-网络适配器-Microsoft-Microsoft-Loopback-Adapter。"><a href="#安装我手动选择的硬件-网络适配器-Microsoft-Microsoft-Loopback-Adapter。" class="headerlink" title="安装我手动选择的硬件 # 网络适配器 # Microsoft , Microsoft Loopback Adapter。"></a>安装我手动选择的硬件 # 网络适配器 # Microsoft , Microsoft Loopback Adapter。</h1><p>配置这个假设备的 IP 地址为 10.1.1.1，掩码 255.255.255.0，没有网关。<br>高级-&gt;WINS，开启 LMHOSTS 查询；禁用 TCP/IP 上的 NetBIOS。</p>
<h1 id="启用-Microsoft-网络客户端。-禁用-Microsoft-网络文件和打印机共享"><a href="#启用-Microsoft-网络客户端。-禁用-Microsoft-网络文件和打印机共享" class="headerlink" title="启用 Microsoft 网络客户端。# 禁用 Microsoft 网络文件和打印机共享"></a>启用 Microsoft 网络客户端。# 禁用 Microsoft 网络文件和打印机共享</h1><p>做完这些之后我有重启。现在用 \10.1.1.1 连接 SMB 共享和用 10.1.1.1:3388 连接远程桌面。<br>调试</p>
<p>如果不能工作：<br>端口有没有转发：运行控制台运行 netstat -an 命令并查看有没有 0.0.0.0:139 或者 10.1.1.1:139<br>有没有 telnet 到 10.1.1.1 139？<br>你需要打开 “本地端口接受其他主机连接”。<br>“Microsoft 网络文件和打印机共享” 有没有被禁用？<br>在 NAT 后面连接两个客户端</p>
<p>假设两个客户端在一个 NAT 网关后面，cliadmin 客户端要连接到 cliuser 客户端(目的地)，两者都可用 ssh 登录到正在运行 sshd 的 gate 上。你不需要 root 权限，只要端口大于 1024 即可。我们在 gate 上使用 2022 端口。而且，由于 gate 使用与本地，所以网关端口不是必须的。<br>开启 cliuser 客户端(从目标到 gate)：</p>
<h1 id="ssh-R-2022-localhost-22-user-gate-转发客户端-22-端口到-gate-2022-端口"><a href="#ssh-R-2022-localhost-22-user-gate-转发客户端-22-端口到-gate-2022-端口" class="headerlink" title="ssh -R 2022:localhost:22 user@gate            # 转发客户端 22 端口到 gate:2022 端口"></a>ssh -R 2022:localhost:22 user@gate            # 转发客户端 22 端口到 gate:2022 端口</h1><p>开启 cliadmin 客户端(从主机到 gate)：</p>
<h1 id="ssh-L-3022-localhost-2022-admin-gate-转发客户端-3022-端口到-gate-2022-端口"><a href="#ssh-L-3022-localhost-2022-admin-gate-转发客户端-3022-端口到-gate-2022-端口" class="headerlink" title="ssh -L 3022:localhost:2022 admin@gate         # 转发客户端 3022 端口到 gate:2022 端口"></a>ssh -L 3022:localhost:2022 admin@gate         # 转发客户端 3022 端口到 gate:2022 端口</h1><p>现在 admin 可以直接连接 cliuser 客户端：</p>
<h1 id="ssh-p-3022-admin-localhost-local-3022-gt-gate-2022-gt-client-22"><a href="#ssh-p-3022-admin-localhost-local-3022-gt-gate-2022-gt-client-22" class="headerlink" title="ssh -p 3022 admin@localhost                   # local:3022 -&gt; gate:2022 -&gt; client:22"></a>ssh -p 3022 admin@localhost                   # local:3022 -&gt; gate:2022 -&gt; client:22</h1><p>在 NAT 后面的 VNC 连接</p>
<p>假设一个在 NAT 后面，监听在端口 5900 上可被访问的 Windows VNC 客户端。<br>开启 cliwin 客户端到 gate：</p>
<h1 id="ssh-R-15900-localhost-5900-user-gate"><a href="#ssh-R-15900-localhost-5900-user-gate" class="headerlink" title="ssh -R 15900:localhost:5900 user@gate"></a>ssh -R 15900:localhost:5900 user@gate</h1><p>开启 cliadmin 客户端(从主机到 gate)：</p>
<h1 id="ssh-L-5900-localhost-15900-admin-gate"><a href="#ssh-L-5900-localhost-15900-admin-gate" class="headerlink" title="ssh -L 5900:localhost:15900 admin@gate"></a>ssh -L 5900:localhost:15900 admin@gate</h1><p>现在 admin 直接连接到 VNC 客户端：</p>
<h1 id="vncconnect-display-0-localhost"><a href="#vncconnect-display-0-localhost" class="headerlink" title="vncconnect -display :0 localhost"></a>vncconnect -display :0 localhost</h1><p>使用 SSH 建立 VPN</p>
<p>自 4.3 版开始，OpenSSH 可以使用 tun/tap 设备来加密一个隧道。其非常类似于基于 TLS 的 VPN 解决方案(像 OpenVPN)。对于 SSH 的一个优势是，她不需要安装和配置额外的软件。另外隧道使用 SSH 认证(像共享密钥)。 其缺点是，对于一个缓慢的连接， 其传输效率较低。并且这个隧道依赖于单个(易断的) TCP 链接。这个技术对于快速设置一个基于 IP 的 VPN 来说非常有用。她对于用单个 TCP 端口转发没有限制，并且在所有 3/4 层 协议像 ICMP、TCP/UDP 等上都可用。不管怎么样，下面这些选择在 sshd_conf 文件中是必须的：<br>PermitRootLogin yes<br>PermitTunnel yes<br>单个 P2P 连接</p>
<p>这里，我们用点对点隧道连接 hclient 和 hserver 两个主机。这个连接是从 hclient 开始到 hserver 的，并且是用 root 来做。这个通道的连接点是 10.0.1.1(服务端)和 10.0.1.2(客户端)，然后我们创建设备 tun5(当然也可以是其它数字)。这个过程非常简单：<br>使用 SSH 的通道选项 -w 来连接<br>设置隧道的 IP 地址。服务端和客户端各一次。<br>连接到服务端</p>
<p>连接始于客户端,然后再服务端执行命令。<br>Linux上的服务端</p>
<p>cli&gt;# ssh -w5:5 root@hserver<br>srv&gt;# ifconfig tun5 10.0.1.1 netmask 255.255.255.252   # 在服务端 shell 上执行<br>FreeBSD上的服务端</p>
<p>cli&gt;# ssh -w5:5 root@hserver<br>srv&gt;# ifconfig tun5 10.0.1.1 10.0.1.2                  # 在服务端 shell 上执行<br>连接到客户端</p>
<p>在客户端上执行命令：<br>cli&gt;# ifconfig tun5 10.0.1.2 netmask 255.255.255.252   # Linux上的客户端<br>cli&gt;# ifconfig tun5 10.0.1.2 10.0.1.1                  # FreeBSD上的客户端<br>现在两个主机都连上了，并且可以在任何 3/4 层协议上使用此通道 IP 地址透明的通讯。<br>连接两个网络</p>
<p>除上面的 p2p 设置外，一个更有用的是SSH VPN 用两个 gate 连接两个私有网络。假设有这样一个例子，netA 为 192.168.51.0/24 还有 netB 为 192.168.16.0/24。设置过程同上面相似，我们只需要添加 routing。如果 gate 不同于默认网关，那在私有网络接口上必须开启 NAT。<br>192.168.51.0/24 (netA)|gateA &lt;-&gt; gateB|192.168.16.0/24 (netB)<br>使用隧道选项 -w 连接 SSH。<br>配置隧道的 IP 地址。服务端和客户端各一次。<br>为两个网络添加 routing。<br>如果需要，在 gate 的私有网络接口上开启 NAT。<br>设置是从 netA 中的 gasteA 开始的.<br>连接 gateA 到 gateB</p>
<p>连接从 gateA 开始，命令执行于 gateB。<br>Linux 上的 gateB</p>
<p>gateA&gt;# ssh -w5:5 root@gateB<br>gateB&gt;# ifconfig tun5 10.0.1.1 netmask 255.255.255.252 # 在 gateB 的 shell 中执行<br>gateB&gt;# route add -net 192.168.51.0 netmask 255.255.255.0 dev tun5<br>gateB&gt;# echo 1 &gt; /proc/sys/net/ipv4/ip_forward         # 如果不是默认网关<br>gateB&gt;# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<br>FreeBSD 上的 gateB</p>
<p>gateA&gt;# ssh -w5:5 root@gateB                          # 创建 tun5 设备<br>gateB&gt;# ifconfig tun5 10.0.1.1 10.0.1.2               # 在 gateB 的 shell 中执行<br>gateB&gt;# route add 192.168.51.0/24 10.0.1.2<br>gateB&gt;# sysctl net.inet.ip.forwarding=1               # 如果不是默认网关<br>gateB&gt;# natd -s -m -u -dynamic -n fxp0                # 看 NAT<br>gateA&gt;# sysctl net.inet.ip.fw.enable=1<br>配置 gateA</p>
<p>在 gateA 上执行命令：<br>Linux 上的 gateA</p>
<p>gateA&gt;# ifconfig tun5 10.0.1.2 netmask 255.255.255.252<br>gateA&gt;# route add -net 192.168.16.0 netmask 255.255.255.0 dev tun5<br>gateA&gt;# echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br>gateA&gt;# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<br>FreeBSD 上的 gateA</p>
<p>gateA&gt;# ifconfig tun5 10.0.1.2 10.0.1.1<br>gateA&gt;# route add 192.168.16.0/24 10.0.1.2<br>gateA&gt;# sysctl net.inet.ip.forwarding=1<br>gateA&gt;# natd -s -m -u -dynamic -n fxp0                # 看 NAT<br>gateA&gt;# sysctl net.inet.ip.fw.enable=1<br>现在两个私有网络都可以通过 SSH VPN 来透明的连接。如果 gate 不是默认网关，那么 IP 转发和 NAT 设置都是必须的。在这种情况下，客户端将不知道在哪里转发响应(response)，并且 NAT 必须是开启的。<br>RSYNC</p>
<p>Rsync 差不多可以代替 cp 和 scp，此外，断点续传是重启有效的。尾部的斜杠也有着不同的意思，请阅读 man 页面……这里有一些例子：<br>拷贝目录中所有内容：</p>
<h1 id="rsync-a-home-colin-backup-colin"><a href="#rsync-a-home-colin-backup-colin" class="headerlink" title="rsync -a /home/colin/ /backup/colin/"></a>rsync -a /home/colin/ /backup/colin/</h1><h1 id="rsync-a-var-var-bak"><a href="#rsync-a-var-var-bak" class="headerlink" title="rsync -a /var/ /var_bak/"></a>rsync -a /var/ /var_bak/</h1><h1 id="rsync-aR-–delete-during-home-user-backup-使用相对路径-看下面"><a href="#rsync-aR-–delete-during-home-user-backup-使用相对路径-看下面" class="headerlink" title="rsync -aR –delete-during /home/user/ /backup/      # 使用相对路径(看下面)"></a>rsync -aR –delete-during /home/user/ /backup/      # 使用相对路径(看下面)</h1><p>同之前一样，但使用了压缩和网络。Rsync 使用 SSH 进行传输，并且使用 SSH 密钥，如果设置的话。和 SCP 一样使用 “:”。一个典型的拷贝：</p>
<h1 id="rsync-axSRzv-home-user-user-server-backup-user"><a href="#rsync-axSRzv-home-user-user-server-backup-user" class="headerlink" title="rsync -axSRzv /home/user/ user@server:/backup/user/"></a>rsync -axSRzv /home/user/ user@server:/backup/user/</h1><p>排除在 /home/user/ 中任何 tmp 目录，并且保持相对目录层次结构，远程目录的结构就是 /backup/home/user/。典型的用于备份的命令。</p>
<h1 id="rsync-azR-–exclude-tmp-home-user-user-server-backup"><a href="#rsync-azR-–exclude-tmp-home-user-user-server-backup" class="headerlink" title="rsync -azR –exclude /tmp/ /home/user/ user@server:/backup/"></a>rsync -azR –exclude /tmp/ /home/user/ user@server:/backup/</h1><p>SSH 连接使用端口 20022：</p>
<h1 id="rsync-az-e-‘ssh-p-20022’-home-colin-user-server-backup-colin"><a href="#rsync-az-e-‘ssh-p-20022’-home-colin-user-server-backup-colin" class="headerlink" title="rsync -az -e ‘ssh -p 20022’ /home/colin/ user@server:/backup/colin/"></a>rsync -az -e ‘ssh -p 20022’ /home/colin/ user@server:/backup/colin/</h1><p>使用 rsync 守护进程(使用”::”)是很快的，但没有透过 SSH 加密。 位置 /backup 定义在了配置文件 /etc/rsyncd.conf 中。变量 RSYNC_PASSWORD 可以设置用来免除手动输入密码。</p>
<h1 id="rsync-axSRz-home-ruser-hostname-rmodule-backup"><a href="#rsync-axSRz-home-ruser-hostname-rmodule-backup" class="headerlink" title="rsync -axSRz /home/ ruser@hostname::rmodule/backup/"></a>rsync -axSRz /home/ ruser@hostname::rmodule/backup/</h1><h1 id="rsync-axSRz-ruser-hostname-rmodule-backup-home-回拷贝"><a href="#rsync-axSRz-ruser-hostname-rmodule-backup-home-回拷贝" class="headerlink" title="rsync -axSRz ruser@hostname::rmodule/backup/ /home/    # 回拷贝"></a>rsync -axSRz ruser@hostname::rmodule/backup/ /home/    # 回拷贝</h1><p>一些重要选项：<br>-a, –archive 归档模式，等于 -rlptgoD (非 -H)<br>-r, –recursive 对子目录以递归模式处理<br>-R, –relative 使用相对路径名<br>-H, –hard-links 保留硬链结<br>-S, –sparse 对稀疏文件进行特殊处理以节省DST的空间<br>-x, –one-file-system 不跨越文件系统边界<br>–exclude=PATTERN 指定排除不需要传输的文件模式<br>–delete-during 传输期间删除<br>–delete-after 传输结束以后再删除<br>在 Windows 上使用 Rsync</p>
<p>可以通过 cygwin 或 独立打包的 cwrsync 来在 Windows 上运行 rsync。这对于自动备份来说非常方便。只装其中一个(不是两个)， 然后添加路径到 Windows 系统变量中：# 控制面板 -&gt; 系统 -&gt; 高级标签，环境变量按钮。编辑 “Path” 添加 rsync 的安装路径，比如：C:\Program Files\cwRsync\bin 或者 C:\cygwin\bin。这可以让 rsync 和 ssh 可用于 Windows 命令窗口中。<br>公钥认证</p>
<p>Rsync 是自动使用 SSH 隧道的，因此在服务端使用 SSH 认证。自动备份可免受用户的影响，rsync 命令对于使用 SSH 公钥认证可以不需要密码。<br>下面所有的命令都可在 windows 控制台中执行。在控制台(开始 -&gt; 运行 -&gt; cmd)中像在 SSH 中描述的那样创建和上传密钥，根据你的情况改变 “user” 和 “server”。如果文件 authorized_keys2 不存在，拷贝 id_dsa.pub 成 authorized_keys2 并上传它。</p>
<h1 id="ssh-keygen-t-dsa-N-‘’-创建密钥对"><a href="#ssh-keygen-t-dsa-N-‘’-创建密钥对" class="headerlink" title="ssh-keygen -t dsa -N ‘’                   # 创建密钥对"></a>ssh-keygen -t dsa -N ‘’                   # 创建密钥对</h1><h1 id="rsync-user-server-ssh-authorized-keys2-从服务器拷贝本地文件"><a href="#rsync-user-server-ssh-authorized-keys2-从服务器拷贝本地文件" class="headerlink" title="rsync user@server:.ssh/authorized_keys2 . # 从服务器拷贝本地文件"></a>rsync user@server:.ssh/authorized_keys2 . # 从服务器拷贝本地文件</h1><h1 id="cat-id-dsa-pub-gt-gt-authorized-keys2-或者使用编辑器添加这个公钥"><a href="#cat-id-dsa-pub-gt-gt-authorized-keys2-或者使用编辑器添加这个公钥" class="headerlink" title="cat id_dsa.pub &gt;&gt; authorized_keys2        # 或者使用编辑器添加这个公钥"></a>cat id_dsa.pub &gt;&gt; authorized_keys2        # 或者使用编辑器添加这个公钥</h1><h1 id="rsync-authorized-keys2-user-server-ssh-拷贝文件回服务器"><a href="#rsync-authorized-keys2-user-server-ssh-拷贝文件回服务器" class="headerlink" title="rsync authorized_keys2 user@server:.ssh/  # 拷贝文件回服务器"></a>rsync authorized_keys2 user@server:.ssh/  # 拷贝文件回服务器</h1><h1 id="del-authorized-keys2-删除本地拷贝"><a href="#del-authorized-keys2-删除本地拷贝" class="headerlink" title="del authorized_keys2                      # 删除本地拷贝"></a>del authorized_keys2                      # 删除本地拷贝</h1><p>现在测试一下(在同一行里面):<br>rsync -rv “/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/“ \<br>‘user@server:My\ Documents/‘<br>自动备份</p>
<p>使用批处理文件自动备份并添加到任务计划(程序 -&gt; 附件 -&gt; 系统工具 -&gt; 任务计划)。举个例子，创建批处理文件 backup.bat 取代 user@server。<br>@ECHO OFF<br>REM rsync the directory My Documents<br>SETLOCAL<br>SET CWRSYNCHOME=C:\PROGRAM FILES\CWRSYNC<br>SET CYGWIN=nontsec<br>SET CWOLDPATH=%PATH%<br>REM uncomment the next line when using cygwin<br>SET PATH=%CWRSYNCHOME%\BIN;%PATH%<br>echo Press Control-C to abort<br>rsync -av “/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/“ \<br>‘user@server:My\ Documents/‘<br>pause<br>SUDO</p>
<p>Sudo 可以给用户一些超级用户的权限而不需要 root 密码。Sudo 对于一个服务器和工作站混合的多用户环境来说非常有用。使用 sudo 运行命令：</p>
<h1 id="sudo-etc-init-d-dhcpd-restart-用-root-权限运行-rc-脚本"><a href="#sudo-etc-init-d-dhcpd-restart-用-root-权限运行-rc-脚本" class="headerlink" title="sudo /etc/init.d/dhcpd restart            # 用 root 权限运行 rc 脚本"></a>sudo /etc/init.d/dhcpd restart            # 用 root 权限运行 rc 脚本</h1><h1 id="sudo-u-sysadmin-whoami-使用其他用户运行命令"><a href="#sudo-u-sysadmin-whoami-使用其他用户运行命令" class="headerlink" title="sudo -u sysadmin whoami                   # 使用其他用户运行命令"></a>sudo -u sysadmin whoami                   # 使用其他用户运行命令</h1><p>配置</p>
<p>Sudo 的配置在 /etc/sudoers 中，并且只能用 visudo 编辑。其基本语法是(列表是以逗号分隔的)：<br>user hosts = (runas) commands          # 在 /etc/sudoers 中<br>users 一个或多个用户或是%用户组(像 %wheel) 来获得权限<br>hosts 主机列表(或 ALL)<br>runas 列出用户以何种身份(或 ALL)来执行命令，放在 ( ) 内！<br>commands 列出可被 users 以 runas 或 root 权限运行的命令(或 ALL)<br>另外一些关键字可以定义别名，他们是 User_Alias, Host_Alias, Runas_Alias 和 Cmnd_Alias。这对于一些较大的设置比较有用。下面是 sudoers 例子：</p>
<h1 id="cat-etc-sudoers"><a href="#cat-etc-sudoers" class="headerlink" title="cat /etc/sudoers"></a>cat /etc/sudoers</h1><h1 id="主机别名"><a href="#主机别名" class="headerlink" title="主机别名"></a>主机别名</h1><p>Host_Alias   DMZ     = 212.118.81.40/28<br>Host_Alias   DESKTOP = work1, work2</p>
<h1 id="用户别名-和-runas-别名"><a href="#用户别名-和-runas-别名" class="headerlink" title="用户别名 和 runas 别名"></a>用户别名 和 runas 别名</h1><p>User_Alias   ADMINS  = colin, luca, admin<br>User_Alias   DEVEL   = joe, jack, julia<br>Runas_Alias  DBA     = oracle,pgsql</p>
<h1 id="命令别名，其值为全路径命令"><a href="#命令别名，其值为全路径命令" class="headerlink" title="命令别名，其值为全路径命令"></a>命令别名，其值为全路径命令</h1><p>Cmnd_Alias   SYSTEM  = /sbin/reboot,/usr/bin/kill,/sbin/halt,/sbin/shutdown,/etc/init.d/<br>Cmnd_Alias   PW      = /usr/bin/passwd [A-z]*, !/usr/bin/passwd root # Not root pwd!<br>Cmnd_Alias   DEBUG   = /usr/sbin/tcpdump,/usr/bin/wireshark,/usr/bin/nmap</p>
<h1 id="一个真实的规则"><a href="#一个真实的规则" class="headerlink" title="一个真实的规则"></a>一个真实的规则</h1><p>root,ADMINS  ALL     = (ALL) NOPASSWD: ALL    # ADMINS 别名中的用户可做任何事情不需要密码<br>DEVEL        DESKTOP = (ALL) NOPASSWD: ALL    # 开发人员可在 DESKTOP 别名的主机上做任何事情<br>DEVEL        DMZ     = (ALL) NOPASSWD: DEBUG  # 开发人员可以在 DMZ 别名的主机上使用 DEBUG 别名中的命令</p>
<h1 id="用户-sysadmin-可以在-DMZ-服务器上执行一些命令"><a href="#用户-sysadmin-可以在-DMZ-服务器上执行一些命令" class="headerlink" title="用户 sysadmin 可以在 DMZ 服务器上执行一些命令"></a>用户 sysadmin 可以在 DMZ 服务器上执行一些命令</h1><p>sysadmin     DMZ     = (ALL) NOPASSWD: SYSTEM,PW,DEBUG<br>sysadmin     ALL,!DMZ = (ALL) NOPASSWD: ALL   # 可以在非 DMZ 主机上做任何事情<br>%dba         ALL     = (DBA) ALL              # 用户组 dba 可以运行 DBA 别名中用户权限的所有命令</p>
<h1 id="所有用户可以在-DESKTOP-别名的主机上-挂载-卸载-CD-ROM"><a href="#所有用户可以在-DESKTOP-别名的主机上-挂载-卸载-CD-ROM" class="headerlink" title="所有用户可以在 DESKTOP 别名的主机上 挂载/卸载 CD-ROM"></a>所有用户可以在 DESKTOP 别名的主机上 挂载/卸载 CD-ROM</h1><p>ALL          DESKTOP = NOPASSWD: /sbin/mount /cdrom,/sbin/umount /cdrom<br>文件加密</p>
<p>单个文件</p>
<p>加密和解密：</p>
<h1 id="openssl-des-salt-in-file-out-file-des"><a href="#openssl-des-salt-in-file-out-file-des" class="headerlink" title="openssl des -salt -in file -out file.des"></a>openssl des -salt -in file -out file.des</h1><h1 id="openssl-des-d-salt-in-file-des-out-file"><a href="#openssl-des-d-salt-in-file-des-out-file" class="headerlink" title="openssl des -d -salt -in file.des -out file"></a>openssl des -d -salt -in file.des -out file</h1><p>那个 file 可以是归档文件(tar archive)。<br>归档并加密整个目录</p>
<h1 id="tar-cf-directory-openssl-des-salt-out-directory-tar-des-加密"><a href="#tar-cf-directory-openssl-des-salt-out-directory-tar-des-加密" class="headerlink" title="tar -cf - directory | openssl des -salt -out directory.tar.des      # 加密"></a>tar -cf - directory | openssl des -salt -out directory.tar.des      # 加密</h1><h1 id="openssl-des-d-salt-in-directory-tar-des-tar-x-解密"><a href="#openssl-des-d-salt-in-directory-tar-des-tar-x-解密" class="headerlink" title="openssl des -d -salt -in directory.tar.des | tar -x                 # 解密"></a>openssl des -d -salt -in directory.tar.des | tar -x                 # 解密</h1><p>压缩归档并加密整个目录</p>
<h1 id="tar-zcf-directory-openssl-des-salt-out-directory-tar-gz-des-加密"><a href="#tar-zcf-directory-openssl-des-salt-out-directory-tar-gz-des-加密" class="headerlink" title="tar -zcf - directory | openssl des -salt -out directory.tar.gz.des  # 加密"></a>tar -zcf - directory | openssl des -salt -out directory.tar.gz.des  # 加密</h1><h1 id="openssl-des-d-salt-in-directory-tar-gz-des-tar-xz-解密"><a href="#openssl-des-d-salt-in-directory-tar-gz-des-tar-xz-解密" class="headerlink" title="openssl des -d -salt -in directory.tar.gz.des | tar -xz             # 解密"></a>openssl des -d -salt -in directory.tar.gz.des | tar -xz             # 解密</h1><p>在使用-k mysecretpassword后，des会取消交互式的密码请求。不过，这非常不安全。<br>使用des3代替des来获得更强的加密(Triple-DES Cipher)。这同样会消耗更多的CPU。<br>GPG</p>
<p>GnuPG 是众所周知的对邮件或任何数据进行加密和签名的软件。此外，gpg 还提供高级密钥管理系统。此章节只涵盖了文件加密，没有邮件加密、签名或者信任网络(Web-Of-Trust)。<br>单纯的加密是一个对称式的加密算法(symmetric cipher)。在本例中，文件是用一个秘密来加密的，任何人知道了这个密码都可以对其进行解密，因此就不需要密钥。Gpg 添加后缀 “.gpg” 到已加密的文件名。</p>
<h1 id="gpg-c-file-使用密码加密文件"><a href="#gpg-c-file-使用密码加密文件" class="headerlink" title="gpg -c file                        # 使用密码加密文件"></a>gpg -c file                        # 使用密码加密文件</h1><h1 id="gpg-file-gpg-文件解密-选项-o-其他文件"><a href="#gpg-file-gpg-文件解密-选项-o-其他文件" class="headerlink" title="gpg file.gpg                       # 文件解密(选项 -o 其他文件)"></a>gpg file.gpg                       # 文件解密(选项 -o 其他文件)</h1><p>使用密钥</p>
<p>对于更详细的请看 GPG 快速上手 和 GPG/PGP 基础，特别是 gnupg 文档。<br>密钥对(私钥，公钥)为非对称加密技术。 要点如下：<br>你的公钥是用来给别人加密文件的并且只有你作为接收者才可以解密(甚至不是一个人加密的文件也可以解密)。公钥是公开的也就意味着可以分发。<br>用你的密码加密的私钥用来解密用你的公钥加密的文件。这个密钥必须保持安全。因为如果遗失了私钥或者密码，那么所有的文件都是使用你的公钥加密的。<br>多个密钥文件被称为密钥环(keyrings)，她可以包含一个以上的密钥。<br>首先生成密钥对。使用默认就行，但你至少要输入你的全名、邮件地址和可选注释。该注释对于创建相同的名字和邮件地址的多个密钥来说非常有用。此外，你应该使用”口令(passphrase)”，而不是简单的密码。</p>
<h1 id="gpg-–gen-key-这需要一些时间"><a href="#gpg-–gen-key-这需要一些时间" class="headerlink" title="gpg –gen-key                      # 这需要一些时间"></a>gpg –gen-key                      # 这需要一些时间</h1><p>在 Unix 上密钥存储在 ~/.gnupg/ 中，在 Windows 上通常存储在<br>C:/Documents and Settings/%USERNAME%/Application Data/gnupg/ 中。<br>~/.gnupg/pubring.gpg                 # 包含你的公钥和所有其他导入的信息<br>~/.gnupg/secring.gpg                 # 可包含多个私钥<br>常用选项的简短描述：<br>-e 加密数据<br>-d 解密数据<br>-r 为某个收件者加密(‘全名’ 或者 ‘email@domain’)<br>-a 输出经过 ascii 封装的密钥<br>-o 指定输出文件<br>本实例使用’Your Name’ 和 ‘Alice’ 作为密钥的 email 或 全名 或 部分名字的参考。举个例子，我可以使用 ‘Colin’ or ‘c@cb.vu’ 给我的密钥 [Colin Barschel (cb.vu) <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#99;&#x40;&#x63;&#x62;&#x2e;&#118;&#x75;">&#99;&#x40;&#x63;&#x62;&#x2e;&#118;&#x75;</a>]。<br>只用于个人的加密</p>
<p>不需要导出/导入任何密钥，因为你都已经有了。</p>
<h1 id="gpg-e-r-‘Your-Name’-file-使用你的公钥加密"><a href="#gpg-e-r-‘Your-Name’-file-使用你的公钥加密" class="headerlink" title="gpg -e -r ‘Your Name’ file                  # 使用你的公钥加密"></a>gpg -e -r ‘Your Name’ file                  # 使用你的公钥加密</h1><h1 id="gpg-o-file-d-file-gpg-解密。使用-o-指定输出文件"><a href="#gpg-o-file-d-file-gpg-解密。使用-o-指定输出文件" class="headerlink" title="gpg -o file -d file.gpg                     # 解密。使用 -o 指定输出文件"></a>gpg -o file -d file.gpg                     # 解密。使用 -o 指定输出文件</h1><p>用密钥加密-解密</p>
<p>首先你需要导出给别人使用的公钥。并且你需要导入来自 Alice 她所加密文件的公钥。你可以用简单的 ascii 文档或者使用公钥服务器来保存这些密钥。<br>举个例子，Alice 导出她的公钥，然后你导入它，之后你就可以加密一个文件给她。这个加密文件只有 Alice 可以解密。</p>
<h1 id="gpg-a-o-alicekey-asc-–export-‘Alice’-Alice-导出她的公钥到-ascii-文件中"><a href="#gpg-a-o-alicekey-asc-–export-‘Alice’-Alice-导出她的公钥到-ascii-文件中" class="headerlink" title="gpg -a -o alicekey.asc –export ‘Alice’               # Alice 导出她的公钥到 ascii 文件中"></a>gpg -a -o alicekey.asc –export ‘Alice’               # Alice 导出她的公钥到 ascii 文件中</h1><h1 id="gpg-–send-keys-–keyserver-subkeys-pgp-net-KEYID-Alice-把她的公钥放入一个服务器"><a href="#gpg-–send-keys-–keyserver-subkeys-pgp-net-KEYID-Alice-把她的公钥放入一个服务器" class="headerlink" title="gpg –send-keys –keyserver subkeys.pgp.net KEYID     # Alice 把她的公钥放入一个服务器"></a>gpg –send-keys –keyserver subkeys.pgp.net KEYID     # Alice 把她的公钥放入一个服务器</h1><h1 id="gpg-–import-alicekey-asc-你导入她的密钥到你的公钥环-pubring-中"><a href="#gpg-–import-alicekey-asc-你导入她的密钥到你的公钥环-pubring-中" class="headerlink" title="gpg –import alicekey.asc                             # 你导入她的密钥到你的公钥环(pubring)中"></a>gpg –import alicekey.asc                             # 你导入她的密钥到你的公钥环(pubring)中</h1><h1 id="gpg-–search-keys-–keyserver-subkeys-pgp-net-‘Alice’-或者从一个服务器中获取他的公钥"><a href="#gpg-–search-keys-–keyserver-subkeys-pgp-net-‘Alice’-或者从一个服务器中获取他的公钥" class="headerlink" title="gpg –search-keys –keyserver subkeys.pgp.net ‘Alice’ # 或者从一个服务器中获取他的公钥"></a>gpg –search-keys –keyserver subkeys.pgp.net ‘Alice’ # 或者从一个服务器中获取他的公钥</h1><p>一旦这些公钥导入后，加密或解密一个文件会非常简单：</p>
<h1 id="gpg-e-r-‘Alice’-file-给-Alice-加密文件"><a href="#gpg-e-r-‘Alice’-file-给-Alice-加密文件" class="headerlink" title="gpg -e -r ‘Alice’ file                      # 给 Alice 加密文件"></a>gpg -e -r ‘Alice’ file                      # 给 Alice 加密文件</h1><h1 id="gpg-d-file-gpg-o-file-解密-Alice-给你的加密文件"><a href="#gpg-d-file-gpg-o-file-解密-Alice-给你的加密文件" class="headerlink" title="gpg -d file.gpg -o file                     # 解密 Alice 给你的加密文件"></a>gpg -d file.gpg -o file                     # 解密 Alice 给你的加密文件</h1><p>密钥管理</p>
<h1 id="gpg-–list-keys-列出所有公钥并查看其-KEYID"><a href="#gpg-–list-keys-列出所有公钥并查看其-KEYID" class="headerlink" title="gpg –list-keys                             # 列出所有公钥并查看其 KEYID"></a>gpg –list-keys                             # 列出所有公钥并查看其 KEYID</h1><pre><code>KEYID 跟在 &apos;/&apos; 后面 比如：pub   1024D/D12B77CE 它的 KEYID 是 D12B77CE
</code></pre><h1 id="gpg-–gen-revoke-‘Your-Name’-产生一份撤销密钥证书"><a href="#gpg-–gen-revoke-‘Your-Name’-产生一份撤销密钥证书" class="headerlink" title="gpg –gen-revoke ‘Your Name’                # 产生一份撤销密钥证书"></a>gpg –gen-revoke ‘Your Name’                # 产生一份撤销密钥证书</h1><h1 id="gpg-–list-secret-keys-列出所有私钥"><a href="#gpg-–list-secret-keys-列出所有私钥" class="headerlink" title="gpg –list-secret-keys                      # 列出所有私钥"></a>gpg –list-secret-keys                      # 列出所有私钥</h1><h1 id="gpg-–delete-keys-NAME-从本的密钥环中删除一个公钥"><a href="#gpg-–delete-keys-NAME-从本的密钥环中删除一个公钥" class="headerlink" title="gpg –delete-keys NAME                      # 从本的密钥环中删除一个公钥"></a>gpg –delete-keys NAME                      # 从本的密钥环中删除一个公钥</h1><h1 id="gpg-–delete-secret-key-NAME-从本的密钥环中删除一个私钥"><a href="#gpg-–delete-secret-key-NAME-从本的密钥环中删除一个私钥" class="headerlink" title="gpg –delete-secret-key NAME                # 从本的密钥环中删除一个私钥"></a>gpg –delete-secret-key NAME                # 从本的密钥环中删除一个私钥</h1><h1 id="gpg-–fingerprint-KEYID-显示-KIYID-这个密钥的指纹"><a href="#gpg-–fingerprint-KEYID-显示-KIYID-这个密钥的指纹" class="headerlink" title="gpg –fingerprint KEYID                     # 显示 KIYID 这个密钥的指纹"></a>gpg –fingerprint KEYID                     # 显示 KIYID 这个密钥的指纹</h1><h1 id="gpg-–edit-key-KEYID-编辑密钥-比如签名或者添加-删除-email"><a href="#gpg-–edit-key-KEYID-编辑密钥-比如签名或者添加-删除-email" class="headerlink" title="gpg –edit-key KEYID                        # 编辑密钥(比如签名或者添加/删除 email)"></a>gpg –edit-key KEYID                        # 编辑密钥(比如签名或者添加/删除 email)</h1><p>分区加密</p>
<p>Linux with LUKS | Linux dm-crypt only | FreeBSD GELI | FreeBSD 只使用密码</p>
<p>有(许多)其他替代方法来加密磁盘，我只呈现我所知道和使用的方法。请记住，安全只是系统还未经过实际考验而已。入侵者可以轻易通过键盘事件记录密码。此外，当已经加载了分区，其数据是可以自由访问的，并不会阻止入侵者去访问它。<br>Linux</p>
<p>这部分我们使用可用于 2.6 内核的 Linux dm-crypt (device-mapper)。在这个实例中，让我们加密 /dev/sdc1 分区，它可为任何其他分区、磁盘、USB或者用 losetup 创建的基于文件的分区。对于基于文件的分区，我们使用 /dev/loop0。看 镜像文件分区。Device mapper 利用标签来标识一个分区。我们使用 sdc1 作为此标签，但可以为任何字符串。<br>dm-crypt with LUKS</p>
<p>LUKS 和 dm-crypt 是较好的加密技术，并且可为同一个分区设置多个口令，更改密码也很方便。可简单输入 # cryptsetup –help 来测试 LUKS 是否可用。如果没有显示任何关于 LUKS 的信息，可看下面Without LUKS 的介绍。第一步如果需要的话创建一个分区：fdisk /dev/sdc。<br>创建加密分区</p>
<h1 id="dd-if-dev-urandom-of-dev-sdc1-可选"><a href="#dd-if-dev-urandom-of-dev-sdc1-可选" class="headerlink" title="dd if=/dev/urandom of=/dev/sdc1          # 可选"></a>dd if=/dev/urandom of=/dev/sdc1          # 可选</h1><h1 id="cryptsetup-y-luksFormat-dev-sdc1-这破坏了在-sdc1-上的数据"><a href="#cryptsetup-y-luksFormat-dev-sdc1-这破坏了在-sdc1-上的数据" class="headerlink" title="cryptsetup -y luksFormat /dev/sdc1       # 这破坏了在 sdc1 上的数据"></a>cryptsetup -y luksFormat /dev/sdc1       # 这破坏了在 sdc1 上的数据</h1><h1 id="cryptsetup-luksOpen-dev-sdc1-sdc1"><a href="#cryptsetup-luksOpen-dev-sdc1-sdc1" class="headerlink" title="cryptsetup luksOpen /dev/sdc1 sdc1"></a>cryptsetup luksOpen /dev/sdc1 sdc1</h1><h1 id="mkfs-ext3-dev-mapper-sdc1-创建-ext3-文件系统"><a href="#mkfs-ext3-dev-mapper-sdc1-创建-ext3-文件系统" class="headerlink" title="mkfs.ext3 /dev/mapper/sdc1               # 创建 ext3 文件系统"></a>mkfs.ext3 /dev/mapper/sdc1               # 创建 ext3 文件系统</h1><h1 id="mount-t-ext3-dev-mapper-sdc1-mnt"><a href="#mount-t-ext3-dev-mapper-sdc1-mnt" class="headerlink" title="mount -t ext3 /dev/mapper/sdc1 /mnt"></a>mount -t ext3 /dev/mapper/sdc1 /mnt</h1><h1 id="umount-mnt"><a href="#umount-mnt" class="headerlink" title="umount /mnt"></a>umount /mnt</h1><h1 id="cryptsetup-luksClose-sdc1-Detach-已加密的分区"><a href="#cryptsetup-luksClose-sdc1-Detach-已加密的分区" class="headerlink" title="cryptsetup luksClose sdc1                # Detach 已加密的分区"></a>cryptsetup luksClose sdc1                # Detach 已加密的分区</h1><p>Attach</p>
<h1 id="cryptsetup-luksOpen-dev-sdc1-sdc1-1"><a href="#cryptsetup-luksOpen-dev-sdc1-sdc1-1" class="headerlink" title="cryptsetup luksOpen /dev/sdc1 sdc1"></a>cryptsetup luksOpen /dev/sdc1 sdc1</h1><h1 id="mount-t-ext3-dev-mapper-sdc1-mnt-1"><a href="#mount-t-ext3-dev-mapper-sdc1-mnt-1" class="headerlink" title="mount -t ext3 /dev/mapper/sdc1 /mnt"></a>mount -t ext3 /dev/mapper/sdc1 /mnt</h1><p>Detach</p>
<h1 id="umount-mnt-1"><a href="#umount-mnt-1" class="headerlink" title="umount /mnt"></a>umount /mnt</h1><h1 id="cryptsetup-luksClose-sdc1"><a href="#cryptsetup-luksClose-sdc1" class="headerlink" title="cryptsetup luksClose sdc1"></a>cryptsetup luksClose sdc1</h1><p>dm-crypt without LUKS</p>
<h1 id="cryptsetup-y-create-sdc1-dev-sdc1-或任何其他分区像-dev-loop0"><a href="#cryptsetup-y-create-sdc1-dev-sdc1-或任何其他分区像-dev-loop0" class="headerlink" title="cryptsetup -y create sdc1 /dev/sdc1      # 或任何其他分区像 /dev/loop0"></a>cryptsetup -y create sdc1 /dev/sdc1      # 或任何其他分区像 /dev/loop0</h1><h1 id="dmsetup-ls-检查一下，将显示：sdc1-254-0"><a href="#dmsetup-ls-检查一下，将显示：sdc1-254-0" class="headerlink" title="dmsetup ls                               # 检查一下，将显示：sdc1 (254, 0)"></a>dmsetup ls                               # 检查一下，将显示：sdc1 (254, 0)</h1><h1 id="mkfs-ext3-dev-mapper-sdc1-只有第一次要这么做！"><a href="#mkfs-ext3-dev-mapper-sdc1-只有第一次要这么做！" class="headerlink" title="mkfs.ext3 /dev/mapper/sdc1               # 只有第一次要这么做！"></a>mkfs.ext3 /dev/mapper/sdc1               # 只有第一次要这么做！</h1><h1 id="mount-t-ext3-dev-mapper-sdc1-mnt-2"><a href="#mount-t-ext3-dev-mapper-sdc1-mnt-2" class="headerlink" title="mount -t ext3 /dev/mapper/sdc1 /mnt"></a>mount -t ext3 /dev/mapper/sdc1 /mnt</h1><h1 id="umount-mnt-2"><a href="#umount-mnt-2" class="headerlink" title="umount /mnt/"></a>umount /mnt/</h1><h1 id="cryptsetup-remove-sdc1-Detach-已加密的分区"><a href="#cryptsetup-remove-sdc1-Detach-已加密的分区" class="headerlink" title="cryptsetup remove sdc1                   # Detach 已加密的分区"></a>cryptsetup remove sdc1                   # Detach 已加密的分区</h1><p>这样做等同于(非 mkfs 部分) re-attach 分区。如果密码不正确，mount 命令将会失败。对于这个例子，只要简单的移除 sdc1 (cryptsetup remove sdc1)并重建即可。<br>FreeBSD</p>
<p>两个流行的 FreeBSD 磁盘加密模块为 gbde 和 geli。我现在使用 geli 原因是它够快并且它使用加解密硬件加速设备。详情可看 FreeBSD 使用手册 18.6。geli 模块必须已编译或加载进内核：<br>options GEOM_ELI<br>device crypto                                       # 内核配置文件中加入这两行</p>
<h1 id="echo-‘geom-eli-load-”YES”‘-gt-gt-boot-loader-conf-也可以在系统引导时加载或者做：kldload-geom-eli"><a href="#echo-‘geom-eli-load-”YES”‘-gt-gt-boot-loader-conf-也可以在系统引导时加载或者做：kldload-geom-eli" class="headerlink" title="echo ‘geom_eli_load=”YES”‘ &gt;&gt; /boot/loader.conf   # 也可以在系统引导时加载或者做：kldload geom_eli"></a>echo ‘geom_eli_load=”YES”‘ &gt;&gt; /boot/loader.conf   # 也可以在系统引导时加载或者做：kldload geom_eli</h1><p>使用密码和密钥</p>
<p>我为一个典型的磁盘加密使用这些设置，其使用了一个口令和一个加密主密钥(master key)的密钥。这意味着你需要密码和生产的密钥 /root/ad1.key 来 attach 分区。主密钥存储在这个加密分区中并且不可见。看下面为 USB 或 映像文件的加密设置。<br>创建加密分区</p>
<h1 id="dd-if-dev-random-of-root-ad1-key-bs-64-count-1-加密主密钥的密钥"><a href="#dd-if-dev-random-of-root-ad1-key-bs-64-count-1-加密主密钥的密钥" class="headerlink" title="dd if=/dev/random of=/root/ad1.key bs=64 count=1  # 加密主密钥的密钥"></a>dd if=/dev/random of=/root/ad1.key bs=64 count=1  # 加密主密钥的密钥</h1><h1 id="geli-init-s-4096-K-root-ad1-key-dev-ad1-对于磁盘也可用-s-8192"><a href="#geli-init-s-4096-K-root-ad1-key-dev-ad1-对于磁盘也可用-s-8192" class="headerlink" title="geli init -s 4096 -K /root/ad1.key /dev/ad1       # 对于磁盘也可用 -s 8192"></a>geli init -s 4096 -K /root/ad1.key /dev/ad1       # 对于磁盘也可用 -s 8192</h1><h1 id="geli-attach-k-root-ad1-key-dev-ad1-将-dev-ad1-与所生成的密钥-root-ad1-key-关联"><a href="#geli-attach-k-root-ad1-key-dev-ad1-将-dev-ad1-与所生成的密钥-root-ad1-key-关联" class="headerlink" title="geli attach -k /root/ad1.key /dev/ad1             # 将 /dev/ad1 与所生成的密钥 /root/ad1.key 关联"></a>geli attach -k /root/ad1.key /dev/ad1             # 将 /dev/ad1 与所生成的密钥 /root/ad1.key 关联</h1><h1 id="dd-if-dev-random-of-dev-ad1-eli-bs-1m-可选，需要很长时间"><a href="#dd-if-dev-random-of-dev-ad1-eli-bs-1m-可选，需要很长时间" class="headerlink" title="dd if=/dev/random of=/dev/ad1.eli bs=1m           # 可选，需要很长时间"></a>dd if=/dev/random of=/dev/ad1.eli bs=1m           # 可选，需要很长时间</h1><h1 id="newfs-dev-ad1-eli-创建文件系统"><a href="#newfs-dev-ad1-eli-创建文件系统" class="headerlink" title="newfs /dev/ad1.eli                                # 创建文件系统"></a>newfs /dev/ad1.eli                                # 创建文件系统</h1><h1 id="mount-dev-ad1-eli-mnt"><a href="#mount-dev-ad1-eli-mnt" class="headerlink" title="mount /dev/ad1.eli /mnt"></a>mount /dev/ad1.eli /mnt</h1><p>Attach</p>
<h1 id="geli-attach-k-root-ad1-key-dev-ad1"><a href="#geli-attach-k-root-ad1-key-dev-ad1" class="headerlink" title="geli attach -k /root/ad1.key /dev/ad1"></a>geli attach -k /root/ad1.key /dev/ad1</h1><h1 id="fsck-ny-t-ffs-dev-ad1-eli-检查文件系统"><a href="#fsck-ny-t-ffs-dev-ad1-eli-检查文件系统" class="headerlink" title="fsck -ny -t ffs /dev/ad1.eli                      # 检查文件系统"></a>fsck -ny -t ffs /dev/ad1.eli                      # 检查文件系统</h1><h1 id="mount-dev-ad1-eli-mnt-1"><a href="#mount-dev-ad1-eli-mnt-1" class="headerlink" title="mount /dev/ad1.eli /mnt"></a>mount /dev/ad1.eli /mnt</h1><p>Detach</p>
<p>Detach 步骤会在关机时自动完成。</p>
<h1 id="umount-mnt-3"><a href="#umount-mnt-3" class="headerlink" title="umount /mnt"></a>umount /mnt</h1><h1 id="geli-detach-dev-ad1-eli"><a href="#geli-detach-dev-ad1-eli" class="headerlink" title="geli detach /dev/ad1.eli"></a>geli detach /dev/ad1.eli</h1><p>/etc/fstab</p>
<p>加密分区在 /etc/fstab 中配置成自动加载。系统启动时会询问加密分区的密码。对于本例下列设置是必须的：</p>
<h1 id="grep-geli-etc-rc-conf"><a href="#grep-geli-etc-rc-conf" class="headerlink" title="grep geli /etc/rc.conf"></a>grep geli /etc/rc.conf</h1><p>geli_devices=”ad1”<br>geli_ad1_flags=”-k /root/ad1.key”</p>
<h1 id="grep-geli-etc-fstab"><a href="#grep-geli-etc-fstab" class="headerlink" title="grep geli /etc/fstab"></a>grep geli /etc/fstab</h1><p>/dev/ad1.eli         /home/private              ufs             rw      0       0<br>仅用密码</p>
<p>加密一个 USB stick 或者映像文件使用密码而不是密钥来得更方便。这种情况下，没有必要随身携带额外的密钥文件。所做步骤同上面非常相似，只是不需要密钥文件。让我们来加密一个 1 GB 的映像文件/cryptedfile。</p>
<h1 id="dd-if-dev-zero-of-cryptedfile-bs-1M-count-1000-1-GB-文件"><a href="#dd-if-dev-zero-of-cryptedfile-bs-1M-count-1000-1-GB-文件" class="headerlink" title="dd if=/dev/zero of=/cryptedfile bs=1M count=1000  # 1 GB 文件"></a>dd if=/dev/zero of=/cryptedfile bs=1M count=1000  # 1 GB 文件</h1><h1 id="mdconfig-at-vnode-f-cryptedfile"><a href="#mdconfig-at-vnode-f-cryptedfile" class="headerlink" title="mdconfig -at vnode -f /cryptedfile"></a>mdconfig -at vnode -f /cryptedfile</h1><h1 id="geli-init-dev-md0-仅用密码加密"><a href="#geli-init-dev-md0-仅用密码加密" class="headerlink" title="geli init /dev/md0                                # 仅用密码加密"></a>geli init /dev/md0                                # 仅用密码加密</h1><h1 id="geli-attach-dev-md0"><a href="#geli-attach-dev-md0" class="headerlink" title="geli attach /dev/md0"></a>geli attach /dev/md0</h1><h1 id="newfs-U-m-0-dev-md0-eli"><a href="#newfs-U-m-0-dev-md0-eli" class="headerlink" title="newfs -U -m 0 /dev/md0.eli"></a>newfs -U -m 0 /dev/md0.eli</h1><h1 id="mount-dev-md0-eli-mnt"><a href="#mount-dev-md0-eli-mnt" class="headerlink" title="mount /dev/md0.eli /mnt"></a>mount /dev/md0.eli /mnt</h1><h1 id="umount-dev-md0-eli"><a href="#umount-dev-md0-eli" class="headerlink" title="umount /dev/md0.eli"></a>umount /dev/md0.eli</h1><h1 id="geli-detach-md0-eli"><a href="#geli-detach-md0-eli" class="headerlink" title="geli detach md0.eli"></a>geli detach md0.eli</h1><p>现在可以把这个映像文件加载成仅需密码的文件系统。</p>
<h1 id="mdconfig-at-vnode-f-cryptedfile-1"><a href="#mdconfig-at-vnode-f-cryptedfile-1" class="headerlink" title="mdconfig -at vnode -f /cryptedfile"></a>mdconfig -at vnode -f /cryptedfile</h1><h1 id="geli-attach-dev-md0-1"><a href="#geli-attach-dev-md0-1" class="headerlink" title="geli attach /dev/md0"></a>geli attach /dev/md0</h1><h1 id="mount-dev-md0-eli-mnt-1"><a href="#mount-dev-md0-eli-mnt-1" class="headerlink" title="mount /dev/md0.eli /mnt"></a>mount /dev/md0.eli /mnt</h1><p>SSL 认证</p>
<p>所谓的 SSL/TLS 认证是加密的公钥认证，它由一个公用密钥和私用密钥组成。证书用来认证终端和加密数据的。例如，用在 web 服务器(https)或者邮件服务器(imaps)。<br>步骤</p>
<p>我们需要一个证书颁发机构来签署我们的证书。这一步通常由供应商提供，如 Thawte、Verisign等。不过，我们也可以创建我们自己的。<br>创建一个证书签发申请(signing request)。这个申请需要一个已经包含所有必需的信息的未签署证书(公共部分)。该证书申请通常发送到认证供应商去签署。这一步同样也在本地机器上创建了私钥。<br>证书颁发机构签署证书。<br>如果有需要，加入证书和密钥到单个文件来给应用程序使用(web 服务器、邮件服务器等）。<br>配置 OpenSSL</p>
<p>我们使用 /usr/local/certs 作为这个例子的目录或者根据你的设置相应的编辑 /etc/ssl/openssl.cnf 文件，因此你知道文件将创建在哪里。以下是 openssl.cnf 的相关部分：<br>[ CA_default ]<br>dir             = /usr/local/certs/CA       # 保存所有信息的文件夹<br>certs           = $dir/certs                # 已生成证书的默认保存目录<br>crl_dir         = $dir/crl                  # 生成的证书撤销列表(CRL)的默认保存目录<br>database        = $dir/index.txt            # 保存已签发证书的文本数据库文件<br>确保所有目录已经创建</p>
<h1 id="mkdir-p-usr-local-certs-CA"><a href="#mkdir-p-usr-local-certs-CA" class="headerlink" title="mkdir -p /usr/local/certs/CA"></a>mkdir -p /usr/local/certs/CA</h1><h1 id="cd-usr-local-certs-CA"><a href="#cd-usr-local-certs-CA" class="headerlink" title="cd /usr/local/certs/CA"></a>cd /usr/local/certs/CA</h1><h1 id="mkdir-certs-crl-newcerts-private"><a href="#mkdir-certs-crl-newcerts-private" class="headerlink" title="mkdir certs crl newcerts private"></a>mkdir certs crl newcerts private</h1><h1 id="echo-“01”-gt-serial-仅当-serial-不存在时"><a href="#echo-“01”-gt-serial-仅当-serial-不存在时" class="headerlink" title="echo “01” &gt; serial                        # 仅当 serial 不存在时"></a>echo “01” &gt; serial                        # 仅当 serial 不存在时</h1><h1 id="touch-index-txt"><a href="#touch-index-txt" class="headerlink" title="touch index.txt"></a>touch index.txt</h1><p>创建一个认证授权</p>
<p>如果你没有来自供应商的认证授权，你必须创建你自己的。如果打算去供应商签署申请，那么这个步骤不是必须的。创建认证授权 (CA)：</p>
<h1 id="openssl-req-new-x509-days-730-config-etc-ssl-openssl-cnf"><a href="#openssl-req-new-x509-days-730-config-etc-ssl-openssl-cnf" class="headerlink" title="openssl req -new -x509 -days 730 -config /etc/ssl/openssl.cnf \"></a>openssl req -new -x509 -days 730 -config /etc/ssl/openssl.cnf \</h1><p>-keyout CA/private/cakey.pem -out CA/cacert.pem<br>创建证书签发申请</p>
<p>要创建一个新证书(比如给邮件服务器或 web 服务器)，首先用其私钥创建证书申请。如果你的应用程序不支持加密的私钥(比如 UW-IMAP 就不支持)，那么就用 -nodes 来禁用加密。</p>
<h1 id="openssl-req-new-keyout-newkey-pem-out-newreq-pem"><a href="#openssl-req-new-keyout-newkey-pem-out-newreq-pem" class="headerlink" title="openssl req -new -keyout newkey.pem -out newreq.pem \"></a>openssl req -new -keyout newkey.pem -out newreq.pem \</h1><p>-config /etc/ssl/openssl.cnf</p>
<h1 id="openssl-req-nodes-new-keyout-newkey-pem-out-newreq-pem"><a href="#openssl-req-nodes-new-keyout-newkey-pem-out-newreq-pem" class="headerlink" title="openssl req -nodes -new -keyout newkey.pem -out newreq.pem \"></a>openssl req -nodes -new -keyout newkey.pem -out newreq.pem \</h1><p>-config /etc/ssl/openssl.cnf                # 不对这个密钥加密<br>签署证书</p>
<p>该证书申请由 CA 签发确认，这个步骤通常由供应商完成。注意：在下面命令中替换 “servername” 成你的服务器名称。</p>
<h1 id="cat-newreq-pem-newkey-pem-gt-new-pem"><a href="#cat-newreq-pem-newkey-pem-gt-new-pem" class="headerlink" title="cat newreq.pem newkey.pem &gt; new.pem"></a>cat newreq.pem newkey.pem &gt; new.pem</h1><h1 id="openssl-ca-policy-policy-anything-out-servernamecert-pem"><a href="#openssl-ca-policy-policy-anything-out-servernamecert-pem" class="headerlink" title="openssl ca -policy policy_anything -out servernamecert.pem \"></a>openssl ca -policy policy_anything -out servernamecert.pem \</h1><p>-config /etc/ssl/openssl.cnf -infiles new.pem</p>
<h1 id="mv-newkey-pem-servernamekey-pem"><a href="#mv-newkey-pem-servernamekey-pem" class="headerlink" title="mv newkey.pem servernamekey.pem"></a>mv newkey.pem servernamekey.pem</h1><p>现在，servernamekey.pem 就是私钥，servernamecert.pem 就为服务器的证书。<br>创建联合认证(united certificate)</p>
<p>IMAP 服务器想要私钥和服务器证书在同一个文件中。通常，这还是比较容易处理的，但是该文件要保证安全! Apache 也可以处理好它。创建一个包含证书和密钥的文件 servername.pem 。<br>用文本编辑器打开私钥文件(servernamekey.pem)，并拷贝私钥到 “servername.pem” 文件中去。<br>服务器证书(servernamecert.pem)也做同样的动作。<br>最后 servername.pem 文件应该看起来像这样：</p>
<p>—–BEGIN RSA PRIVATE KEY—–<br>MIICXQIBAAKBgQDutWy+o/XZ/[…]qK5LqQgT3c9dU6fcR+WuSs6aejdEDDqBRQ<br>—–END RSA PRIVATE KEY—–<br>—–BEGIN CERTIFICATE—–<br>MIIERzCCA7CgAwIBAgIBBDANB[…]iG9w0BAQQFADCBxTELMAkGA1UEBhMCREUx<br>—–END CERTIFICATE—–<br>现在我们的 /usr/local/certs/ 目录中有了这些；<br>CA/private/cakey.pem (CA 服务器私钥)<br>CA/cacert.pem (CA 服务器公钥)<br>certs/servernamekey.pem (服务器私钥)<br>certs/servernamecert.pem (服务器已签署的证书)<br>certs/servername.pem (私钥和服务器证书)<br>要保证私钥的安全!<br>查看证书信息</p>
<p>要查看证书信息，只要这么做：</p>
<h1 id="openssl-x509-text-in-servernamecert-pem-显示证书信息"><a href="#openssl-x509-text-in-servernamecert-pem-显示证书信息" class="headerlink" title="openssl x509 -text -in servernamecert.pem      # 显示证书信息"></a>openssl x509 -text -in servernamecert.pem      # 显示证书信息</h1><h1 id="openssl-req-noout-text-in-server-csr-显示申请信息"><a href="#openssl-req-noout-text-in-server-csr-显示申请信息" class="headerlink" title="openssl req -noout -text -in server.csr        # 显示申请信息"></a>openssl req -noout -text -in server.csr        # 显示申请信息</h1><h1 id="openssl-s-client-connect-cb-vu-443-检查-web-服务器认证信息"><a href="#openssl-s-client-connect-cb-vu-443-检查-web-服务器认证信息" class="headerlink" title="openssl s_client -connect cb.vu:443            # 检查 web 服务器认证信息"></a>openssl s_client -connect cb.vu:443            # 检查 web 服务器认证信息</h1><p>CVS</p>
<p>服务器设置 | CVS 测试 | SSH 隧道 | CVS 使用</p>
<p>服务器设置</p>
<p>CVS 环境初始化</p>
<p>决定主 repository 将要创建和重置的 cvs 根目录。比如 /usr/local/cvs (根)：</p>
<h1 id="mkdir-p-usr-local-cvs"><a href="#mkdir-p-usr-local-cvs" class="headerlink" title="mkdir -p /usr/local/cvs"></a>mkdir -p /usr/local/cvs</h1><h1 id="setenv-CVSROOT-usr-local-cvs-设置-CVSROOT-环境变量-本地"><a href="#setenv-CVSROOT-usr-local-cvs-设置-CVSROOT-环境变量-本地" class="headerlink" title="setenv CVSROOT /usr/local/cvs      # 设置 CVSROOT 环境变量(本地)"></a>setenv CVSROOT /usr/local/cvs      # 设置 CVSROOT 环境变量(本地)</h1><h1 id="cvs-init-创建所有初始化-CVS-配置文件"><a href="#cvs-init-创建所有初始化-CVS-配置文件" class="headerlink" title="cvs init                           # 创建所有初始化 CVS 配置文件"></a>cvs init                           # 创建所有初始化 CVS 配置文件</h1><h1 id="cd-root"><a href="#cd-root" class="headerlink" title="cd /root"></a>cd /root</h1><h1 id="cvs-checkout-CVSROOT-签出配置文件来修改他们"><a href="#cvs-checkout-CVSROOT-签出配置文件来修改他们" class="headerlink" title="cvs checkout CVSROOT               # 签出配置文件来修改他们"></a>cvs checkout CVSROOT               # 签出配置文件来修改他们</h1><h1 id="cd-CVSROOT"><a href="#cd-CVSROOT" class="headerlink" title="cd CVSROOT"></a>cd CVSROOT</h1><p>edit config ( fine as it is)</p>
<h1 id="cvs-commit-config"><a href="#cvs-commit-config" class="headerlink" title="cvs commit config"></a>cvs commit config</h1><p>cat &gt;&gt; writers                       # 创建 writers 文件 (也可为 readers)<br>colin<br>^D                                   # 使用 [Control][D] 退出编辑</p>
<h1 id="cvs-add-writers-添加文件-writers-进-repository"><a href="#cvs-add-writers-添加文件-writers-进-repository" class="headerlink" title="cvs add writers                    # 添加文件 writers 进 repository"></a>cvs add writers                    # 添加文件 writers 进 repository</h1><h1 id="cvs-edit-checkoutlist"><a href="#cvs-edit-checkoutlist" class="headerlink" title="cvs edit checkoutlist"></a>cvs edit checkoutlist</h1><h1 id="cat-gt-gt-checkoutlist"><a href="#cat-gt-gt-checkoutlist" class="headerlink" title="cat &gt;&gt; checkoutlist"></a>cat &gt;&gt; checkoutlist</h1><p>writers<br>^D                                   # 使用 [Control][D] 退出编辑</p>
<h1 id="cvs-commit-提交所有配置更改"><a href="#cvs-commit-提交所有配置更改" class="headerlink" title="cvs commit                         # 提交所有配置更改"></a>cvs commit                         # 提交所有配置更改</h1><p>添加一个 readers 文件，如果你要区分读写权限的话。注意： 不要在主 cvs 中直接编辑文件，而应该签出要编辑的文件，修改完成后再签入。我们所做的文件 writers 用来定义可写权限。<br>下面有三种流行的方式去访问 CVS。前两个不需要任何进一步的配置。看 CVSROOT 部分的实例了解如何使用它们：<br>直接本的访问文件系统。用户需要有足够的权限来直接访问 CVS，除了要登录到操作系统，没有进一步的验证。然而这仅对本地 repository 才有用。<br>使用 ext 协议通过 ssh 来远程访问。任何有 ssh shell 账户和在 CVS 服务器上可读写权限的都可直接使用 ext 协议通过 ssh 来访问 CVS，而不需要任何额外的隧道。没有服务器来处理运行在 CVS 上的验证工作。ssh 登录会去验证。<br>用 pserver 来远程访问。这是对于有较大用户量的首选方法，用户由 CVS 的 pserver 通过一个专门的密码数据库来验证，因此不需要本地用户帐户。这种设置在下面会有说明。<br>用 inetd 设置网络</p>
<p>如果不需要网络访问，CVS 可以运行于本地。对于远程访问，在 /etc/inetd.conf (Suse 为 /etc/xinetd.d/cvs)中配置如下行，可让守护进程 inetd 启动 pserver：<br>cvspserver  stream  tcp  nowait  cvs  /usr/bin/cvs  cvs \<br>–allow-root=/usr/local/cvs pserver<br>这是个用来阻断从 internet 访问 cvs 端口的好方法，可使用 ssh 隧道来远程的访问 repository。<br>单独认证</p>
<p>CVS 用户可能不是操作系统的一部分(即不是本地用户)。这其实可从安全的角度去看。简单的添加一个叫 passwd (in the CVSROOT directory) 的文件，其包含 crypt 格式的用户登录名和密码。这也可以使用 apache 的 htpasswd 工具来完成。<br>注意：这个 passwd 文件仅仅是文件，可以在 CVSROOT 中直接编辑。它不能被签出。更多信息请用 htpasswd –help</p>
<h1 id="htpasswd-cb-passwd-user1-password1-c-创建文件"><a href="#htpasswd-cb-passwd-user1-password1-c-创建文件" class="headerlink" title="htpasswd -cb passwd user1 password1  # -c 创建文件"></a>htpasswd -cb passwd user1 password1  # -c 创建文件</h1><h1 id="htpasswd-b-passwd-user2-password2"><a href="#htpasswd-b-passwd-user2-password2" class="headerlink" title="htpasswd -b passwd user2 password2"></a>htpasswd -b passwd user2 password2</h1><p>现在添加 :cvs 到每行的结尾处，用来告诉 cvs 服务器更改用户到 cvs (或任何你正在运行的 cvs 服务器下)。它看起来像这样：</p>
<h1 id="cat-passwd"><a href="#cat-passwd" class="headerlink" title="cat passwd"></a>cat passwd</h1><p>user1:xsFjhU22u8Fuo:cvs<br>user2:vnefJOsnnvToM:cvs<br>测试它</p>
<p>测试作为一般用户登录(比如我)</p>
<h1 id="cvs-d-pserver-colin-192-168-50-254-usr-local-cvs-login"><a href="#cvs-d-pserver-colin-192-168-50-254-usr-local-cvs-login" class="headerlink" title="cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs login"></a>cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs login</h1><p>Logging in to :pserver:colin@192.168.50.254:2401/usr/local/cvs<br>CVS password:</p>
<p>CVSROOT 变量</p>
<p>这是个环境变量用来指定 repository 的位置。对于本地使用，该变量只需设置成 repository 的目录。对于通过网络使用，传输协议必须指定。使用 setenv CVSROOT string (csh, tcsh shell) 或者 export CVSROOT=string ( sh, bash shell) 设置 CVSROOT 环境变量。</p>
<h1 id="setenv-CVSROOT-pserver-cvsdirectory"><a href="#setenv-CVSROOT-pserver-cvsdirectory" class="headerlink" title="setenv CVSROOT :pserver:@:/cvsdirectory"></a>setenv CVSROOT :pserver:<username>@<host>:/cvsdirectory</host></username></h1><p>For example:</p>
<h1 id="setenv-CVSROOT-usr-local-cvs-仅限本的使用"><a href="#setenv-CVSROOT-usr-local-cvs-仅限本的使用" class="headerlink" title="setenv CVSROOT /usr/local/cvs                               # 仅限本的使用"></a>setenv CVSROOT /usr/local/cvs                               # 仅限本的使用</h1><h1 id="setenv-CVSROOT-local-usr-local-cvs-同上"><a href="#setenv-CVSROOT-local-usr-local-cvs-同上" class="headerlink" title="setenv CVSROOT :local:/usr/local/cvs                        # 同上"></a>setenv CVSROOT :local:/usr/local/cvs                        # 同上</h1><h1 id="setenv-CVSROOT-ext-user-cvsserver-usr-local-cvs-通过-SSH-直接访问"><a href="#setenv-CVSROOT-ext-user-cvsserver-usr-local-cvs-通过-SSH-直接访问" class="headerlink" title="setenv CVSROOT :ext:user@cvsserver:/usr/local/cvs           # 通过 SSH 直接访问"></a>setenv CVSROOT :ext:user@cvsserver:/usr/local/cvs           # 通过 SSH 直接访问</h1><h1 id="setenv-CVS-RSH-ssh-ext-协议访问"><a href="#setenv-CVS-RSH-ssh-ext-协议访问" class="headerlink" title="setenv CVS_RSH ssh                                          # ext 协议访问"></a>setenv CVS_RSH ssh                                          # ext 协议访问</h1><h1 id="setenv-CVSROOT-pserver-user-cvsserver-254-usr-local-cvs-通过-pserver-网络访问"><a href="#setenv-CVSROOT-pserver-user-cvsserver-254-usr-local-cvs-通过-pserver-网络访问" class="headerlink" title="setenv CVSROOT :pserver:user@cvsserver.254:/usr/local/cvs   # 通过 pserver 网络访问"></a>setenv CVSROOT :pserver:user@cvsserver.254:/usr/local/cvs   # 通过 pserver 网络访问</h1><p>一旦登录成功就可导入一个新项目进 repository：cd 进入你的项目根目录<br>cvs import <module name=""> <vendor tag=""> <initial tag=""><br>cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs import MyProject MyCompany START<br>在 repository 中有个名叫 MyProject 新项目(之后用来签出)。CVS 会导入当前目录的内容进新项目。</initial></vendor></module></p>
<p>签出：</p>
<h1 id="cvs-d-pserver-colin-192-168-50-254-usr-local-cvs-checkout-MyProject"><a href="#cvs-d-pserver-colin-192-168-50-254-usr-local-cvs-checkout-MyProject" class="headerlink" title="cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs checkout MyProject"></a>cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs checkout MyProject</h1><p>或者</p>
<h1 id="setenv-CVSROOT-pserver-colin-192-168-50-254-usr-local-cvs"><a href="#setenv-CVSROOT-pserver-colin-192-168-50-254-usr-local-cvs" class="headerlink" title="setenv CVSROOT :pserver:colin@192.168.50.254:/usr/local/cvs"></a>setenv CVSROOT :pserver:colin@192.168.50.254:/usr/local/cvs</h1><h1 id="cvs-checkout-MyProject"><a href="#cvs-checkout-MyProject" class="headerlink" title="cvs checkout MyProject"></a>cvs checkout MyProject</h1><p>通过 SSH 隧道访问 CVS</p>
<p>我们需要两个 shell 来做这个。在第一个 shell 中，我们连接到 cvs 服务器并对 cvs 连接进行端口转发(port-forward)。在第二个 shell 中，我们就像在本地一样使用 cvs。<br>在 shell 1:</p>
<h1 id="ssh-L2401-localhost-2401-colin-cvs-server-直接连接到-cvs-服务器。或："><a href="#ssh-L2401-localhost-2401-colin-cvs-server-直接连接到-cvs-服务器。或：" class="headerlink" title="ssh -L2401:localhost:2401 colin@cvs_server   # 直接连接到 cvs 服务器。或："></a>ssh -L2401:localhost:2401 colin@cvs_server   # 直接连接到 cvs 服务器。或：</h1><h1 id="ssh-L2401-cvs-server-2401-colin-gateway-使用一个网关间接连接到-cvs-服务器"><a href="#ssh-L2401-cvs-server-2401-colin-gateway-使用一个网关间接连接到-cvs-服务器" class="headerlink" title="ssh -L2401:cvs_server:2401 colin@gateway     # 使用一个网关间接连接到 cvs 服务器"></a>ssh -L2401:cvs_server:2401 colin@gateway     # 使用一个网关间接连接到 cvs 服务器</h1><p>在 shell 2:</p>
<h1 id="setenv-CVSROOT-pserver-colin-localhost-usr-local-cvs"><a href="#setenv-CVSROOT-pserver-colin-localhost-usr-local-cvs" class="headerlink" title="setenv CVSROOT :pserver:colin@localhost:/usr/local/cvs"></a>setenv CVSROOT :pserver:colin@localhost:/usr/local/cvs</h1><h1 id="cvs-login"><a href="#cvs-login" class="headerlink" title="cvs login"></a>cvs login</h1><p>Logging in to :pserver:colin@localhost:2401/usr/local/cvs<br>CVS password:</p>
<h1 id="cvs-checkout-MyProject-src"><a href="#cvs-checkout-MyProject-src" class="headerlink" title="cvs checkout MyProject/src"></a>cvs checkout MyProject/src</h1><p>CVS 命令及其使用</p>
<p>导入</p>
<p>该 import 命令用来添加整个目录，它必须运行于要导入的目录中。比如，目录 /devel/ 包含的所有文件和子目录要导入。该目录名在 CVS 中(模块)将会称为 “myapp”。</p>
<h1 id="cvs-import-options-directory-name-vendor-tag-release-tag"><a href="#cvs-import-options-directory-name-vendor-tag-release-tag" class="headerlink" title="cvs import [options] directory-name vendor-tag release-tag"></a>cvs import [options] directory-name vendor-tag release-tag</h1><h1 id="cd-devel-必须在该目录中来导入"><a href="#cd-devel-必须在该目录中来导入" class="headerlink" title="cd /devel                          # 必须在该目录中来导入"></a>cd /devel                          # 必须在该目录中来导入</h1><h1 id="cvs-import-myapp-Company-R1-0-修订-release-标签可以为任何单个单词"><a href="#cvs-import-myapp-Company-R1-0-修订-release-标签可以为任何单个单词" class="headerlink" title="cvs import myapp Company R1_0      # 修订(release)标签可以为任何单个单词"></a>cvs import myapp Company R1_0      # 修订(release)标签可以为任何单个单词</h1><p>在添加了一个新目录 “/devel/tools/“ 后，也可这么导入。</p>
<h1 id="cd-devel-tools"><a href="#cd-devel-tools" class="headerlink" title="cd /devel/tools"></a>cd /devel/tools</h1><h1 id="cvs-import-myapp-tools-Company-R1-0"><a href="#cvs-import-myapp-tools-Company-R1-0" class="headerlink" title="cvs import myapp/tools Company R1_0"></a>cvs import myapp/tools Company R1_0</h1><p>签出、更新和提交</p>
<h1 id="cvs-co-myapp-tools-仅会签出-tools-目录"><a href="#cvs-co-myapp-tools-仅会签出-tools-目录" class="headerlink" title="cvs co myapp/tools                 # 仅会签出 tools 目录"></a>cvs co myapp/tools                 # 仅会签出 tools 目录</h1><h1 id="cvs-co-r-R1-1-myapp-签出修订版本为-R1-1-的-myapp-sticky"><a href="#cvs-co-r-R1-1-myapp-签出修订版本为-R1-1-的-myapp-sticky" class="headerlink" title="cvs co -r R1_1 myapp               # 签出修订版本为 R1_1 的 myapp (sticky)"></a>cvs co -r R1_1 myapp               # 签出修订版本为 R1_1 的 myapp (sticky)</h1><h1 id="cvs-q-d-update-P-典型的-CVS-更新"><a href="#cvs-q-d-update-P-典型的-CVS-更新" class="headerlink" title="cvs -q -d update -P                # 典型的 CVS 更新"></a>cvs -q -d update -P                # 典型的 CVS 更新</h1><h1 id="cvs-update-A-重置所有-sticky-标签-或日期、选项"><a href="#cvs-update-A-重置所有-sticky-标签-或日期、选项" class="headerlink" title="cvs update -A                      # 重置所有 sticky 标签(或日期、选项)"></a>cvs update -A                      # 重置所有 sticky 标签(或日期、选项)</h1><h1 id="cvs-add-newfile-添加一个新文件"><a href="#cvs-add-newfile-添加一个新文件" class="headerlink" title="cvs add newfile                    # 添加一个新文件"></a>cvs add newfile                    # 添加一个新文件</h1><h1 id="cvs-add-kb-newfile-添加一个二进制文件"><a href="#cvs-add-kb-newfile-添加一个二进制文件" class="headerlink" title="cvs add -kb newfile                # 添加一个二进制文件"></a>cvs add -kb newfile                # 添加一个二进制文件</h1><h1 id="cvs-commit-file1-file2-仅提交这两个文件"><a href="#cvs-commit-file1-file2-仅提交这两个文件" class="headerlink" title="cvs commit file1 file2             # 仅提交这两个文件"></a>cvs commit file1 file2             # 仅提交这两个文件</h1><h1 id="cvs-commit-m-“message”-提交所有更改并为这个更改添加日志消息"><a href="#cvs-commit-m-“message”-提交所有更改并为这个更改添加日志消息" class="headerlink" title="cvs commit -m “message”            # 提交所有更改并为这个更改添加日志消息"></a>cvs commit -m “message”            # 提交所有更改并为这个更改添加日志消息</h1><p>创建一个 patch</p>
<p>It is best to create and apply a patch from the working development directory related to the project, or from within the source directory.</p>
<h1 id="cd-devel-project"><a href="#cd-devel-project" class="headerlink" title="cd /devel/project"></a>cd /devel/project</h1><h1 id="diff-Naur-olddir-newdir-gt-patchfile-Create-a-patch-from-a-directory-or-a-file"><a href="#diff-Naur-olddir-newdir-gt-patchfile-Create-a-patch-from-a-directory-or-a-file" class="headerlink" title="diff -Naur olddir newdir &gt; patchfile # Create a patch from a directory or a file"></a>diff -Naur olddir newdir &gt; patchfile # Create a patch from a directory or a file</h1><h1 id="diff-Naur-oldfile-newfile-gt-patchfile"><a href="#diff-Naur-oldfile-newfile-gt-patchfile" class="headerlink" title="diff -Naur oldfile newfile &gt; patchfile"></a>diff -Naur oldfile newfile &gt; patchfile</h1><p>应用一个 patch</p>
<p>Sometimes it is necessary to strip a directory level from the patch, depending how it was created. In case of difficulties, simply look at the first lines of the patch and try -p0, -p1 or -p2.</p>
<h1 id="cd-devel-project-1"><a href="#cd-devel-project-1" class="headerlink" title="cd /devel/project"></a>cd /devel/project</h1><h1 id="patch-–dry-run-p0-lt-patchfile-Test-the-path-without-applying-it"><a href="#patch-–dry-run-p0-lt-patchfile-Test-the-path-without-applying-it" class="headerlink" title="patch –dry-run -p0 &lt; patchfile    # Test the path without applying it"></a>patch –dry-run -p0 &lt; patchfile    # Test the path without applying it</h1><h1 id="patch-p0-lt-patchfile"><a href="#patch-p0-lt-patchfile" class="headerlink" title="patch -p0 &lt; patchfile"></a>patch -p0 &lt; patchfile</h1><h1 id="patch-p1-lt-patchfile-strip-off-the-1st-level-from-the-path"><a href="#patch-p1-lt-patchfile-strip-off-the-1st-level-from-the-path" class="headerlink" title="patch -p1 &lt; patchfile              # strip off the 1st level from the path"></a>patch -p1 &lt; patchfile              # strip off the 1st level from the path</h1><p>SVN</p>
<p>Server setup | SVN+SSH | SVN over http | SVN usage</p>
<p>Subversion (SVN) is a version control system designed to be the successor of CVS (Concurrent Versions System). The concept is similar to CVS, but many shortcomings where improved. See also the SVN book.<br>Server setup</p>
<p>The initiation of the repository is fairly simple (here for example /home/svn/ must exist):</p>
<h1 id="svnadmin-create-–fs-type-fsfs-home-svn-project1"><a href="#svnadmin-create-–fs-type-fsfs-home-svn-project1" class="headerlink" title="svnadmin create –fs-type fsfs /home/svn/project1"></a>svnadmin create –fs-type fsfs /home/svn/project1</h1><p>Now the access to the repository is made possible with:<br>file:// Direct file system access with the svn client with. This requires local permissions on the file system.<br>svn:// or svn+ssh:// Remote access with the svnserve server (also over SSH). This requires local permissions on the file system.<br>http:// Remote access with webdav using apache. No local users are necessary for this method.<br>Using the local file system, it is now possible to import and then check out an existing project. Unlike with CVS it is not necessary to cd into the project directory, simply give the full path:</p>
<h1 id="svn-import-project1-file-home-svn-project1-trunk-m-‘Initial-import’"><a href="#svn-import-project1-file-home-svn-project1-trunk-m-‘Initial-import’" class="headerlink" title="svn import /project1/ file:///home/svn/project1/trunk -m ‘Initial import’"></a>svn import /project1/ file:///home/svn/project1/trunk -m ‘Initial import’</h1><h1 id="svn-checkout-file-home-svn-project1"><a href="#svn-checkout-file-home-svn-project1" class="headerlink" title="svn checkout file:///home/svn/project1"></a>svn checkout file:///home/svn/project1</h1><p>The new directory “trunk” is only a convention, this is not required.<br>Remote access with ssh</p>
<p>No special setup is required to access the repository via ssh, simply replace file:// with svn+ssh/hostname. For example:</p>
<h1 id="svn-checkout-svn-ssh-hostname-home-svn-project1"><a href="#svn-checkout-svn-ssh-hostname-home-svn-project1" class="headerlink" title="svn checkout svn+ssh://hostname/home/svn/project1"></a>svn checkout svn+ssh://hostname/home/svn/project1</h1><p>As with the local file access, every user needs an ssh access to the server (with a local account) and also read/write access. This method might be suitable for a small group. All users could belong to a subversion group which owns the repository, for example:</p>
<h1 id="groupadd-subversion"><a href="#groupadd-subversion" class="headerlink" title="groupadd subversion"></a>groupadd subversion</h1><h1 id="groupmod-A-user1-subversion"><a href="#groupmod-A-user1-subversion" class="headerlink" title="groupmod -A user1 subversion"></a>groupmod -A user1 subversion</h1><h1 id="chown-R-root-subversion-home-svn"><a href="#chown-R-root-subversion-home-svn" class="headerlink" title="chown -R root:subversion /home/svn"></a>chown -R root:subversion /home/svn</h1><h1 id="chmod-R-770-home-svn"><a href="#chmod-R-770-home-svn" class="headerlink" title="chmod -R 770 /home/svn"></a>chmod -R 770 /home/svn</h1><p>Remote access with http (apache)</p>
<p>Remote access over http (https) is the only good solution for a larger user group. This method uses the apache authentication, not the local accounts. This is a typical but small apache configuration:<br>LoadModule dav_module         modules/mod_dav.so<br>LoadModule dav_svn_module     modules/mod_dav_svn.so<br>LoadModule authz_svn_module   modules/mod_authz_svn.so    # Only for access control</p>
<p><location svn=""><br>  DAV svn</location></p>
<h1 id="any-“-svn-foo”-URL-will-map-to-a-repository-home-svn-foo"><a href="#any-“-svn-foo”-URL-will-map-to-a-repository-home-svn-foo" class="headerlink" title="any “/svn/foo” URL will map to a repository /home/svn/foo"></a>any “/svn/foo” URL will map to a repository /home/svn/foo</h1><p>  SVNParentPath /home/svn<br>  AuthType Basic<br>  AuthName “Subversion repository”<br>  AuthzSVNAccessFile /etc/apache2/svn.acl<br>  AuthUserFile /etc/apache2/svn-passwd<br>  Require valid-user<br><br>The apache server needs full access to the repository:</p>
<h1 id="chown-R-www-www-home-svn"><a href="#chown-R-www-www-home-svn" class="headerlink" title="chown -R www:www /home/svn"></a>chown -R www:www /home/svn</h1><p>Create a user with htpasswd2:</p>
<h1 id="htpasswd-c-etc-svn-passwd-user1-c-creates-the-file"><a href="#htpasswd-c-etc-svn-passwd-user1-c-creates-the-file" class="headerlink" title="htpasswd -c /etc/svn-passwd user1  # -c creates the file"></a>htpasswd -c /etc/svn-passwd user1  # -c creates the file</h1><p>Access control svn.acl example</p>
<h1 id="Default-it-read-access-“-”-would-be-default-no-access"><a href="#Default-it-read-access-“-”-would-be-default-no-access" class="headerlink" title="Default it read access. “* =” would be default no access"></a>Default it read access. “* =” would be default no access</h1><p>[/]</p>
<ul>
<li>= r<br>[groups]<br>project1-developers = joe, jack, jane<h1 id="Give-write-access-to-the-developers"><a href="#Give-write-access-to-the-developers" class="headerlink" title="Give write access to the developers"></a>Give write access to the developers</h1>[project1:]<br>@project1-developers = rw<br>SVN commands and usage</li>
</ul>
<p>See also the Subversion Quick Reference Card. Tortoise SVN is a nice Windows interface.<br>Import</p>
<p>A new project, that is a directory with some files, is imported into the repository with the import command. Import is also used to add a directory with its content to an existing project.</p>
<h1 id="svn-help-import-Get-help-for-any-command"><a href="#svn-help-import-Get-help-for-any-command" class="headerlink" title="svn help import                                # Get help for any command"></a>svn help import                                # Get help for any command</h1><pre><code># Add a new directory (with content) into the src dir on project1
</code></pre><h1 id="svn-import-project1-newdir-http-host-url-svn-project1-trunk-src-m-‘add-newdir’"><a href="#svn-import-project1-newdir-http-host-url-svn-project1-trunk-src-m-‘add-newdir’" class="headerlink" title="svn import /project1/newdir http://host.url/svn/project1/trunk/src -m ‘add newdir’"></a>svn import /project1/newdir <a href="http://host.url/svn/project1/trunk/src" target="_blank" rel="noopener">http://host.url/svn/project1/trunk/src</a> -m ‘add newdir’</h1><p>Typical SVN commands</p>
<h1 id="svn-co-http-host-url-svn-project1-trunk-Checkout-the-most-recent-version"><a href="#svn-co-http-host-url-svn-project1-trunk-Checkout-the-most-recent-version" class="headerlink" title="svn co http://host.url/svn/project1/trunk      # Checkout the most recent version"></a>svn co <a href="http://host.url/svn/project1/trunk" target="_blank" rel="noopener">http://host.url/svn/project1/trunk</a>      # Checkout the most recent version</h1><pre><code># Tags and branches are created by copying
</code></pre><h1 id="svn-mkdir-http-host-url-svn-project1-tags-Create-the-tags-directory"><a href="#svn-mkdir-http-host-url-svn-project1-tags-Create-the-tags-directory" class="headerlink" title="svn mkdir http://host.url/svn/project1/tags/   # Create the tags directory"></a>svn mkdir <a href="http://host.url/svn/project1/tags/" target="_blank" rel="noopener">http://host.url/svn/project1/tags/</a>   # Create the tags directory</h1><h1 id="svn-copy-m-“Tag-rc1-rel-”-http-host-url-svn-project1-trunk"><a href="#svn-copy-m-“Tag-rc1-rel-”-http-host-url-svn-project1-trunk" class="headerlink" title="svn copy -m “Tag rc1 rel.” http://host.url/svn/project1/trunk \"></a>svn copy -m “Tag rc1 rel.” <a href="http://host.url/svn/project1/trunk" target="_blank" rel="noopener">http://host.url/svn/project1/trunk</a> \</h1><pre><code>http://host.url/svn/project1/tags/1.0rc1
</code></pre><h1 id="svn-status-–verbose-Check-files-status-into-working-dir"><a href="#svn-status-–verbose-Check-files-status-into-working-dir" class="headerlink" title="svn status [–verbose]                         # Check files status into working dir"></a>svn status [–verbose]                         # Check files status into working dir</h1><h1 id="svn-add-src-file-h-src-file-cpp-Add-two-files"><a href="#svn-add-src-file-h-src-file-cpp-Add-two-files" class="headerlink" title="svn add src/file.h src/file.cpp                # Add two files"></a>svn add src/file.h src/file.cpp                # Add two files</h1><h1 id="svn-commit-m-‘Added-new-class-file’-Commit-the-changes-with-a-message"><a href="#svn-commit-m-‘Added-new-class-file’-Commit-the-changes-with-a-message" class="headerlink" title="svn commit -m ‘Added new class file’           # Commit the changes with a message"></a>svn commit -m ‘Added new class file’           # Commit the changes with a message</h1><h1 id="svn-ls-http-host-url-svn-project1-tags-List-all-tags"><a href="#svn-ls-http-host-url-svn-project1-tags-List-all-tags" class="headerlink" title="svn ls http://host.url/svn/project1/tags/      # List all tags"></a>svn ls <a href="http://host.url/svn/project1/tags/" target="_blank" rel="noopener">http://host.url/svn/project1/tags/</a>      # List all tags</h1><h1 id="svn-move-foo-c-bar-c-Move-rename-files"><a href="#svn-move-foo-c-bar-c-Move-rename-files" class="headerlink" title="svn move foo.c bar.c                           # Move (rename) files"></a>svn move foo.c bar.c                           # Move (rename) files</h1><h1 id="svn-delete-some-old-file-Delete-files"><a href="#svn-delete-some-old-file-Delete-files" class="headerlink" title="svn delete some_old_file                       # Delete files"></a>svn delete some_old_file                       # Delete files</h1><p>实用命令</p>
<p>less | vi | mail | tar | dd | screen | find | 混杂的</p>
<p>less</p>
<p>less 命令用来在控制台中分屏显示文本文档。它在许多发行版中可用。</p>
<h1 id="less-unixtoolbox-xhtml"><a href="#less-unixtoolbox-xhtml" class="headerlink" title="less unixtoolbox.xhtml"></a>less unixtoolbox.xhtml</h1><p>一些重要指令(^N 代表 [control]-[N])：<br>h H       显示指令的汇总列表<br>chmod -R 777 /XXX/XXX/XXX/      指定某个文件或目录开放权限<br>f ^F ^V SPACE       向前滚动一屏(或者 N 行)<br>b ^B ESC-v       向后滚动一屏(或者 N 行)<br>F       向前滚动；类似于”tail -f”<br>/pattern       向前搜索匹配该模式的行<br>?pattern       向后搜索匹配该模式的行<br>n       重复之前的搜索<br>N       反方向重复之前的搜索<br>q       退出<br>vi</p>
<p>Vi 在任何 Linux/Unix 发行安装版(gentoo 没有?)上都存在。因此，我们有必要了解一些基本的命令。Vi 有两个模式：命令模式和插入模式。使用 [ESC] 键可进入命令模式，使用 i 键可进入插入模式。如果你迷失了，可在命令模式下键入 : help。<br>编辑器 nano 和 pico 通常也都可用，而且更容易(IMHO)使用。<br>Quit</p>
<p>:w newfilename       保存文件为 newfilename<br>:wq or :x       保存并退出<br>:q!       退出但不保存<br>移动和查找</p>
<p>/string       向前查找 string<br>?string       向后查找 string<br>n       同方向重复上一次搜索命令<br>N       反方向重复上一次搜索命令<br>{       光标移至段落结尾<br>}       光标移至段落开头<br>1G       光标移至文件的第一行首<br>nG       光标移至文件的第 n 行首<br>G       光标移至文件的最后一行首<br>:%s/OLD/NEW/g       替换所有查找到的 OLD 为 NEW<br>删除文本</p>
<p>dd       删除当前行<br>D       删除光标到当前行末尾的字符<br>dw       删除单词<br>x       删除字符<br>u       回复上一次操作<br>U       回复所有此行的更改<br>mail</p>
<p>mail 命令是一个读取和发送邮件的应用程序，她通常已安装。要发送一封邮件，可以简单的输入 “mail user@domain”。其第一行为主题，然后是邮件内容。在一个新行中使用单个点(.)来结束并发送邮件。例子：</p>
<h1 id="mail-c-cb-vu"><a href="#mail-c-cb-vu" class="headerlink" title="mail c@cb.vu"></a>mail c@cb.vu</h1><p>Subject: Your text is full of typos<br>“For a moment, nothing happened. Then, after a second or so,<br>nothing continued to happen.”<br>.<br>EOT<br>#<br>这同样可用于管道：</p>
<h1 id="echo-“This-is-the-mail-body”-mail-c-cb-vu"><a href="#echo-“This-is-the-mail-body”-mail-c-cb-vu" class="headerlink" title="echo “This is the mail body” | mail c@cb.vu"></a>echo “This is the mail body” | mail c@cb.vu</h1><p>也是测试邮件服务器的简单方法。<br>tar</p>
<p>命令 tar (磁带存档) 可以为文件和目录创建档案。归档文件 .tar 是未压缩的，一个压缩过的归档文件的后缀是 .tgz 或 .tar.gz (zip) 或者 .tbz (bzip2)。不要使用绝对路径建立一个归档文件，你可能要解开这个归档文件到某个地方。一些常用命令如下：<br>创建</p>
<h1 id="cd"><a href="#cd" class="headerlink" title="cd /"></a>cd /</h1><h1 id="tar-cf-home-tar-home-归档整个-home-目录-c-为创建"><a href="#tar-cf-home-tar-home-归档整个-home-目录-c-为创建" class="headerlink" title="tar -cf home.tar home/        # 归档整个 /home 目录(c 为创建)"></a>tar -cf home.tar home/        # 归档整个 /home 目录(c 为创建)</h1><h1 id="tar-czf-home-tgz-home-等同于-zip-压缩"><a href="#tar-czf-home-tgz-home-等同于-zip-压缩" class="headerlink" title="tar -czf home.tgz home/       # 等同于 zip 压缩"></a>tar -czf home.tgz home/       # 等同于 zip 压缩</h1><h1 id="tar-cjf-home-tbz-home-等同于-bzip2-压缩"><a href="#tar-cjf-home-tbz-home-等同于-bzip2-压缩" class="headerlink" title="tar -cjf home.tbz home/       # 等同于 bzip2 压缩"></a>tar -cjf home.tbz home/       # 等同于 bzip2 压缩</h1><p>从一个目录树中只包含一个(或2个)目录，并保持相对目录结构。举个例子，/usr/local/etc 和 /usr/local/www，它们在归档文件中的第一层目录是 local/。</p>
<h1 id="tar-C-usr-czf-local-tgz-local-etc-local-www"><a href="#tar-C-usr-czf-local-tgz-local-etc-local-www" class="headerlink" title="tar -C /usr -czf local.tgz local/etc local/www"></a>tar -C /usr -czf local.tgz local/etc local/www</h1><h1 id="tar-C-usr-xzf-local-tgz-释放-local-目录到-usr"><a href="#tar-C-usr-xzf-local-tgz-释放-local-目录到-usr" class="headerlink" title="tar -C /usr -xzf local.tgz    # 释放 local 目录到 /usr"></a>tar -C /usr -xzf local.tgz    # 释放 local 目录到 /usr</h1><h1 id="cd-usr-tar-xzf-local-tgz-同上面一样"><a href="#cd-usr-tar-xzf-local-tgz-同上面一样" class="headerlink" title="cd /usr; tar -xzf local.tgz   # 同上面一样"></a>cd /usr; tar -xzf local.tgz   # 同上面一样</h1><p>释放(Extract)</p>
<h1 id="tar-tzf-home-tgz-列出归档文件中的所有文件，并不释放"><a href="#tar-tzf-home-tgz-列出归档文件中的所有文件，并不释放" class="headerlink" title="tar -tzf home.tgz             # 列出归档文件中的所有文件，并不释放"></a>tar -tzf home.tgz             # 列出归档文件中的所有文件，并不释放</h1><h1 id="tar-xf-home-tar-释放归档文件-x-为释放"><a href="#tar-xf-home-tar-释放归档文件-x-为释放" class="headerlink" title="tar -xf home.tar              # 释放归档文件(x 为释放)"></a>tar -xf home.tar              # 释放归档文件(x 为释放)</h1><h1 id="tar-xzf-home-tgz-等同于-zip-压缩"><a href="#tar-xzf-home-tgz-等同于-zip-压缩" class="headerlink" title="tar -xzf home.tgz             # 等同于 zip 压缩"></a>tar -xzf home.tgz             # 等同于 zip 压缩</h1><h1 id="tar-xjf-home-tgz-等同于-bzip2-压缩"><a href="#tar-xjf-home-tgz-等同于-bzip2-压缩" class="headerlink" title="tar -xjf home.tgz             # 等同于 bzip2 压缩"></a>tar -xjf home.tgz             # 等同于 bzip2 压缩</h1><h1 id="tar-xjf-home-tgz-home-colin-file-txt-释放单个文件"><a href="#tar-xjf-home-tgz-home-colin-file-txt-释放单个文件" class="headerlink" title="tar -xjf home.tgz home/colin/file.txt    # 释放单个文件"></a>tar -xjf home.tgz home/colin/file.txt    # 释放单个文件</h1><p>更高级的</p>
<h1 id="tar-c-dir-gzip-ssh-user-remote-‘dd-of-dir-tgz’-归档压缩-dir-目录并存储到远程主机上"><a href="#tar-c-dir-gzip-ssh-user-remote-‘dd-of-dir-tgz’-归档压缩-dir-目录并存储到远程主机上" class="headerlink" title="tar c dir/ | gzip | ssh user@remote ‘dd of=dir.tgz’ # 归档压缩 dir/ 目录并存储到远程主机上"></a>tar c dir/ | gzip | ssh user@remote ‘dd of=dir.tgz’ # 归档压缩 dir/ 目录并存储到远程主机上</h1><h1 id="tar-cvf-find-print-gt-backup-tar-归档当前目录"><a href="#tar-cvf-find-print-gt-backup-tar-归档当前目录" class="headerlink" title="tar cvf - find . -print &gt; backup.tar              # 归档当前目录"></a>tar cvf - <code>find . -print</code> &gt; backup.tar              # 归档当前目录</h1><h1 id="tar-cf-C-etc-tar-xpf-C-backup-etc-拷贝目录"><a href="#tar-cf-C-etc-tar-xpf-C-backup-etc-拷贝目录" class="headerlink" title="tar -cf - -C /etc . | tar xpf - -C /backup/etc      # 拷贝目录"></a>tar -cf - -C /etc . | tar xpf - -C /backup/etc      # 拷贝目录</h1><h1 id="tar-cf-C-etc-ssh-user-remote-tar-xpf-C-backup-etc-远程拷贝"><a href="#tar-cf-C-etc-ssh-user-remote-tar-xpf-C-backup-etc-远程拷贝" class="headerlink" title="tar -cf - -C /etc . | ssh user@remote tar xpf - -C /backup/etc      # 远程拷贝"></a>tar -cf - -C /etc . | ssh user@remote tar xpf - -C /backup/etc      # 远程拷贝</h1><h1 id="tar-czf-home-tgz-–exclude-‘-o’-–exclude-‘tmp-‘-home"><a href="#tar-czf-home-tgz-–exclude-‘-o’-–exclude-‘tmp-‘-home" class="headerlink" title="tar -czf home.tgz –exclude ‘*.o’ –exclude ‘tmp/‘ home/"></a>tar -czf home.tgz –exclude ‘*.o’ –exclude ‘tmp/‘ home/</h1><p>dd</p>
<p>程序 dd (磁盘备份(disk dump) 或 destroy disk，也可看 dd 的含义) 用来拷贝分区、磁盘或者其它拷贝。通常这么用：</p>
<h1 id="dd-if-of-bs-conv"><a href="#dd-if-of-bs-conv" class="headerlink" title="dd if= of= bs= conv="></a>dd if=<source> of=<target> bs=<byte size=""> conv=<conversion></conversion></byte></target></h1><p>重要的 conv 选项：<br>notrunc       不截短输出文件<br>noerror       出错时不停止处理(e.g. 坏扇区)<br>sync       把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐<br>默认字节大小为 512 (一个扇区)。MBR 处于磁盘的第一个扇区，之后的 63 个扇区是空的。较大的字节大小可以加快拷贝速度但也需要更多的内存。<br>备份和恢复</p>
<h1 id="dd-if-dev-hda-of-dev-hdc-bs-16065b-拷贝磁盘到磁盘-相同大小"><a href="#dd-if-dev-hda-of-dev-hdc-bs-16065b-拷贝磁盘到磁盘-相同大小" class="headerlink" title="dd if=/dev/hda of=/dev/hdc bs=16065b                # 拷贝磁盘到磁盘(相同大小)"></a>dd if=/dev/hda of=/dev/hdc bs=16065b                # 拷贝磁盘到磁盘(相同大小)</h1><h1 id="dd-if-dev-sda7-of-home-root-img-bs-4096-conv-notrunc-noerror-备份"><a href="#dd-if-dev-sda7-of-home-root-img-bs-4096-conv-notrunc-noerror-备份" class="headerlink" title="dd if=/dev/sda7 of /home/root.img bs=4096 conv=notrunc,noerror # 备份 /"></a>dd if=/dev/sda7 of /home/root.img bs=4096 conv=notrunc,noerror # 备份 /</h1><h1 id="dd-if-home-root-img-of-dev-sda7-bs-4096-conv-notrunc-noerror-恢复"><a href="#dd-if-home-root-img-of-dev-sda7-bs-4096-conv-notrunc-noerror-恢复" class="headerlink" title="dd if /home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror # 恢复 /"></a>dd if /home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror # 恢复 /</h1><h1 id="dd-bs-1M-if-dev-ad4s3e-gzip-c-gt-ad4s3e-gz-压缩备份"><a href="#dd-bs-1M-if-dev-ad4s3e-gzip-c-gt-ad4s3e-gz-压缩备份" class="headerlink" title="dd bs=1M if=/dev/ad4s3e | gzip -c &gt; ad4s3e.gz                  # 压缩备份"></a>dd bs=1M if=/dev/ad4s3e | gzip -c &gt; ad4s3e.gz                  # 压缩备份</h1><h1 id="gunzip-dc-ad4s3e-gz-dd-of-dev-ad0s3e-bs-1M-解压恢复"><a href="#gunzip-dc-ad4s3e-gz-dd-of-dev-ad0s3e-bs-1M-解压恢复" class="headerlink" title="gunzip -dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M                 # 解压恢复"></a>gunzip -dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M                 # 解压恢复</h1><h1 id="dd-bs-1M-if-dev-ad4s3e-gzip-ssh-eedcoba-fry-‘dd-of-ad4s3e-gz’-也可为远程的"><a href="#dd-bs-1M-if-dev-ad4s3e-gzip-ssh-eedcoba-fry-‘dd-of-ad4s3e-gz’-也可为远程的" class="headerlink" title="dd bs=1M if=/dev/ad4s3e | gzip | ssh eedcoba@fry ‘dd of=ad4s3e.gz’ # 也可为远程的"></a>dd bs=1M if=/dev/ad4s3e | gzip | ssh eedcoba@fry ‘dd of=ad4s3e.gz’ # 也可为远程的</h1><h1 id="gunzip-dc-ad4s3e-gz-ssh-eedcoba-host-‘dd-of-dev-ad0s3e-bs-1M’"><a href="#gunzip-dc-ad4s3e-gz-ssh-eedcoba-host-‘dd-of-dev-ad0s3e-bs-1M’" class="headerlink" title="gunzip -dc ad4s3e.gz | ssh eedcoba@host ‘dd of=/dev/ad0s3e bs=1M’"></a>gunzip -dc ad4s3e.gz | ssh eedcoba@host ‘dd of=/dev/ad0s3e bs=1M’</h1><h1 id="dd-if-dev-ad0-of-dev-ad2-skip-1-seek-1-bs-4k-conv-noerror-忽略-MBR"><a href="#dd-if-dev-ad0-of-dev-ad2-skip-1-seek-1-bs-4k-conv-noerror-忽略-MBR" class="headerlink" title="dd if=/dev/ad0 of=/dev/ad2 skip=1 seek=1 bs=4k conv=noerror    # 忽略 MBR"></a>dd if=/dev/ad0 of=/dev/ad2 skip=1 seek=1 bs=4k conv=noerror    # 忽略 MBR</h1><pre><code># 如果目标(ad2)比较小，这是必须的。
</code></pre><p>恢复</p>
<p>该 dd 命令会读取分区的每一个区块，即所有区块。对于有问题的区块，最好使用 conv=sync,noerror 选项，dd 将会跳过坏的区块并入 0。因此，这就是设置块大小等于或小于磁盘块大小的重要性。1k 大小似乎安全，用 bs=1k 来设置它。假如一个磁盘有坏扇区并且有个分区的数据要恢复，那么用 dd 工具创建一个镜像文件，挂载这个镜像文件，然后拷贝内容到新的磁盘中。如果用了 noerror 选项，dd 会跳过坏扇区并写入 0，也即坏扇区中的内容会丢失。</p>
<h1 id="dd-if-dev-hda-of-dev-null-bs-1m-检查坏扇区"><a href="#dd-if-dev-hda-of-dev-null-bs-1m-检查坏扇区" class="headerlink" title="dd if=/dev/hda of=/dev/null bs=1m                   # 检查坏扇区"></a>dd if=/dev/hda of=/dev/null bs=1m                   # 检查坏扇区</h1><h1 id="dd-bs-1k-if-dev-hda1-conv-sync-noerror-notrunc-gzip-ssh-发送到远程"><a href="#dd-bs-1k-if-dev-hda1-conv-sync-noerror-notrunc-gzip-ssh-发送到远程" class="headerlink" title="dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh \ # 发送到远程"></a>dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh \ # 发送到远程</h1><p>root@fry ‘dd of=hda1.gz bs=1k’</p>
<h1 id="dd-bs-1k-if-dev-hda1-conv-sync-noerror-notrunc-of-hda1-img-存储为一个映像文件"><a href="#dd-bs-1k-if-dev-hda1-conv-sync-noerror-notrunc-of-hda1-img-存储为一个映像文件" class="headerlink" title="dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img    # 存储为一个映像文件"></a>dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img    # 存储为一个映像文件</h1><h1 id="mount-o-loop-hda1-img-mnt-挂载这个映像文件"><a href="#mount-o-loop-hda1-img-mnt-挂载这个映像文件" class="headerlink" title="mount -o loop /hda1.img /mnt                        # 挂载这个映像文件"></a>mount -o loop /hda1.img /mnt                        # 挂载这个映像文件</h1><h1 id="rsync-ax-mnt-newdisk-拷贝到一个新磁盘"><a href="#rsync-ax-mnt-newdisk-拷贝到一个新磁盘" class="headerlink" title="rsync -ax /mnt/ /newdisk/                           # 拷贝到一个新磁盘"></a>rsync -ax /mnt/ /newdisk/                           # 拷贝到一个新磁盘</h1><h1 id="dd-if-dev-hda-of-dev-hda-刷新磁状态"><a href="#dd-if-dev-hda-of-dev-hda-刷新磁状态" class="headerlink" title="dd if=/dev/hda of=/dev/hda                          # 刷新磁状态"></a>dd if=/dev/hda of=/dev/hda                          # 刷新磁状态</h1><h1 id="上面的命令对于刷新磁盘-refresh-disk-很有用。这绝对安全，但必须先卸载磁盘。"><a href="#上面的命令对于刷新磁盘-refresh-disk-很有用。这绝对安全，但必须先卸载磁盘。" class="headerlink" title="上面的命令对于刷新磁盘(refresh disk)很有用。这绝对安全，但必须先卸载磁盘。"></a>上面的命令对于刷新磁盘(refresh disk)很有用。这绝对安全，但必须先卸载磁盘。</h1><p>删除</p>
<h1 id="dd-if-dev-zero-of-dev-hdc-删除全部数据"><a href="#dd-if-dev-zero-of-dev-hdc-删除全部数据" class="headerlink" title="dd if=/dev/zero of=/dev/hdc                         # 删除全部数据"></a>dd if=/dev/zero of=/dev/hdc                         # 删除全部数据</h1><h1 id="dd-if-dev-urandom-of-dev-hdc-更好的删除全部数据"><a href="#dd-if-dev-urandom-of-dev-hdc-更好的删除全部数据" class="headerlink" title="dd if=/dev/urandom of=/dev/hdc                      # 更好的删除全部数据"></a>dd if=/dev/urandom of=/dev/hdc                      # 更好的删除全部数据</h1><h1 id="kill-USR1-PID-查看-dd-进度-仅Linux"><a href="#kill-USR1-PID-查看-dd-进度-仅Linux" class="headerlink" title="kill -USR1 PID                                      # 查看 dd 进度(仅Linux!)"></a>kill -USR1 PID                                      # 查看 dd 进度(仅Linux!)</h1><p>MBR 技巧</p>
<p>MBR 包含了引导程序和分区表，它的大小为 512 字节。前 446 字节为引导程序，446 到 512 字节为分区表。</p>
<h1 id="dd-if-dev-sda-of-mbr-sda-bak-bs-512-count-1-完全备份-MBR"><a href="#dd-if-dev-sda-of-mbr-sda-bak-bs-512-count-1-完全备份-MBR" class="headerlink" title="dd if=/dev/sda of=/mbr_sda.bak bs=512 count=1                  # 完全备份 MBR"></a>dd if=/dev/sda of=/mbr_sda.bak bs=512 count=1                  # 完全备份 MBR</h1><h1 id="dd-if-dev-zero-of-dev-sda-bs-512-count-1-删除-MBR-和分区表"><a href="#dd-if-dev-zero-of-dev-sda-bs-512-count-1-删除-MBR-和分区表" class="headerlink" title="dd if=/dev/zero of=/dev/sda bs=512 count=1                     # 删除 MBR 和分区表"></a>dd if=/dev/zero of=/dev/sda bs=512 count=1                     # 删除 MBR 和分区表</h1><h1 id="dd-if-mbr-sda-bak-of-dev-sda-bs-512-count-1-完全恢复MBR"><a href="#dd-if-mbr-sda-bak-of-dev-sda-bs-512-count-1-完全恢复MBR" class="headerlink" title="dd if=/mbr_sda.bak of=/dev/sda bs=512 count=1                  # 完全恢复MBR"></a>dd if=/mbr_sda.bak of=/dev/sda bs=512 count=1                  # 完全恢复MBR</h1><h1 id="dd-if-mbr-sda-bak-of-dev-sda-bs-446-count-1-仅回复引导程序"><a href="#dd-if-mbr-sda-bak-of-dev-sda-bs-446-count-1-仅回复引导程序" class="headerlink" title="dd if=/mbr_sda.bak of=/dev/sda bs=446 count=1                  # 仅回复引导程序"></a>dd if=/mbr_sda.bak of=/dev/sda bs=446 count=1                  # 仅回复引导程序</h1><h1 id="dd-if-mbr-sda-bak-of-dev-sda-bs-1-count-64-skip-446-seek-446-恢复分区表"><a href="#dd-if-mbr-sda-bak-of-dev-sda-bs-1-count-64-skip-446-seek-446-恢复分区表" class="headerlink" title="dd if=/mbr_sda.bak of=/dev/sda bs=1 count=64 skip=446 seek=446 # 恢复分区表"></a>dd if=/mbr_sda.bak of=/dev/sda bs=1 count=64 skip=446 seek=446 # 恢复分区表</h1><p>screen</p>
<p>Screen 提供了两个主要功能：<br>在一个终端内运行多个终端会话(terminal session)。<br>一个已启动的程序与运行它的真实终端分离的，因此可运行于后台。真实的终端可以被关闭，还可以在稍后再重新接上(reattached)。<br>简短实例</p>
<p>开启 screen：</p>
<h1 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h1><p>在 screen 会话中，我们可以开启一个长时间运行的程序(如 top)。Detach 这个终端，之后可以从其他机器 reattach 这个相同的终端(比如通过 ssh)。</p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>现在用 Ctrl-a Ctrl-d 来 detach。Reattach 终端：</p>
<h1 id="screen-r"><a href="#screen-r" class="headerlink" title="screen -r"></a>screen -r</h1><p>或更好的：</p>
<h1 id="screen-R-D"><a href="#screen-R-D" class="headerlink" title="screen -R -D"></a>screen -R -D</h1><p>现在 attach 到这里。具体意思是：先试图恢复离线的 screen 会话。若找不到离线的 screen 会话，即建立新的 screen 会话给用户。<br>Screen 命令 (在 screen 中)</p>
<p>所有命令都以 Ctrl-a 开始。<br>Ctrl-a ? 各功能的帮助摘要<br>Ctrl-a c 创建一个新的 window (终端)<br>Ctrl-a Ctrl-n 和 Ctrl-a Ctrl-p 切换到下一个或前一个 window<br>Ctrl-a Ctrl-N N 为 0 到 9 的数字，用来切换到相对应的 window<br>Ctrl-a “ 获取所有正在运行的 window 的可导航的列表<br>Ctrl-a a 清楚错误的 Ctrl-a<br>Ctrl-a Ctrl-d 断开所有会话，会话中所有任务运行于后台<br>Ctrl-a x 用密码锁柱 screen 终端<br>当程序内部运行终端关闭并且你登出该终端时，该 screen 会话就会被终止。<br>Find</p>
<p>一些重要选项：<br>-x (BSD) -xdev (Linux)       留于同一文件系统 (fstab 中的 dev)<br>-exec cmd {} \;       执行命令并用全路径替换 {}<br>-iname       同 -name 一样，但不区分大小写<br>-ls       显示关于文件的信息(同 ls -la)<br>-size n       n 为 +-n (k M G T P)<br>-cmin n       查找系统中最后 n 分钟改变文件状态的文件</p>
<h1 id="find-type-f-perm-444-寻找所有无法读取的文件"><a href="#find-type-f-perm-444-寻找所有无法读取的文件" class="headerlink" title="find . -type f ! -perm -444        # 寻找所有无法读取的文件"></a>find . -type f ! -perm -444        # 寻找所有无法读取的文件</h1><h1 id="find-type-d-perm-111-寻找所有无法访问的目录"><a href="#find-type-d-perm-111-寻找所有无法访问的目录" class="headerlink" title="find . -type d ! -perm -111        # 寻找所有无法访问的目录"></a>find . -type d ! -perm -111        # 寻找所有无法访问的目录</h1><h1 id="find-home-user-cmin-10-print-寻找最后-10-分钟创建或修改的文件"><a href="#find-home-user-cmin-10-print-寻找最后-10-分钟创建或修改的文件" class="headerlink" title="find /home/user/ -cmin 10 -print   # 寻找最后 10 分钟创建或修改的文件"></a>find /home/user/ -cmin 10 -print   # 寻找最后 10 分钟创建或修改的文件</h1><h1 id="find-name-‘-ch-’-xargs-grep-E-‘expr’-在当前目录及子目录搜索-‘expr’-表达式"><a href="#find-name-‘-ch-’-xargs-grep-E-‘expr’-在当前目录及子目录搜索-‘expr’-表达式" class="headerlink" title="find . -name ‘*.[ch]’ | xargs grep -E ‘expr’ # 在当前目录及子目录搜索 ‘expr’ 表达式"></a>find . -name ‘*.[ch]’ | xargs grep -E ‘expr’ # 在当前目录及子目录搜索 ‘expr’ 表达式</h1><h1 id="find-name-“-core”-xargs-rm-寻找-core-垃圾并删除它们-也可试试-core"><a href="#find-name-“-core”-xargs-rm-寻找-core-垃圾并删除它们-也可试试-core" class="headerlink" title="find / -name “.core” | xargs rm   # 寻找 core 垃圾并删除它们(也可试试 core.)"></a>find / -name “<em>.core” | xargs rm   # 寻找 core 垃圾并删除它们(也可试试 core.</em>)</h1><h1 id="find-name-“-core”-print-exec-rm-另一种语法"><a href="#find-name-“-core”-print-exec-rm-另一种语法" class="headerlink" title="find / -name “*.core” -print -exec rm {} \;  # 另一种语法"></a>find / -name “*.core” -print -exec rm {} \;  # 另一种语法</h1><pre><code># 寻找图像文件并创建一个归档文件，iname 为不区分大小写。-r 为附加
</code></pre><h1 id="find-iname-“-png”-o-iname-“-jpg”-print-exec-tar-rf-images-tar"><a href="#find-iname-“-png”-o-iname-“-jpg”-print-exec-tar-rf-images-tar" class="headerlink" title="find . ( -iname “.png” -o -iname “.jpg” ) -print -exec tar -rf images.tar {} \;"></a>find . ( -iname “<em>.png” -o -iname “</em>.jpg” ) -print -exec tar -rf images.tar {} \;</h1><h1 id="find-type-f-name-“-txt”-name-README-txt-print-除-README-txt-的文件"><a href="#find-type-f-name-“-txt”-name-README-txt-print-除-README-txt-的文件" class="headerlink" title="find . -type f -name “*.txt” ! -name README.txt -print  # 除 README.txt 的文件"></a>find . -type f -name “*.txt” ! -name README.txt -print  # 除 README.txt 的文件</h1><h1 id="find-var-size-10M-exec-ls-lh-查找-gt-10-MB-的文件"><a href="#find-var-size-10M-exec-ls-lh-查找-gt-10-MB-的文件" class="headerlink" title="find /var/ -size +10M -exec ls -lh {} \;     # 查找 &gt; 10 MB 的文件"></a>find /var/ -size +10M -exec ls -lh {} \;     # 查找 &gt; 10 MB 的文件</h1><h1 id="find-var-size-10M-ls-这个更简单"><a href="#find-var-size-10M-ls-这个更简单" class="headerlink" title="find /var/ -size +10M -ls           # 这个更简单"></a>find /var/ -size +10M -ls           # 这个更简单</h1><h1 id="find-size-10M-size-50M-print"><a href="#find-size-10M-size-50M-print" class="headerlink" title="find . -size +10M -size -50M -print"></a>find . -size +10M -size -50M -print</h1><h1 id="find-usr-ports-name-work-type-d-print-exec-rm-rf-清理-port"><a href="#find-usr-ports-name-work-type-d-print-exec-rm-rf-清理-port" class="headerlink" title="find /usr/ports/ -name work -type d -print -exec rm -rf {} \;  # 清理 port"></a>find /usr/ports/ -name work -type d -print -exec rm -rf {} \;  # 清理 port</h1><pre><code># 以 SUID 查找文件；这些文件很脆弱，必须保持安全。
</code></pre><h1 id="find-type-f-user-root-perm-4000-exec-ls-l"><a href="#find-type-f-user-root-perm-4000-exec-ls-l" class="headerlink" title="find / -type f -user root -perm -4000 -exec ls -l {} \;"></a>find / -type f -user root -perm -4000 -exec ls -l {} \;</h1><p>小心 xarg 或 exec，因为当文件或目录中包含空格时可能会返回错误的结果。在有疑惑时用 “-print0 | xargs -0” 代替 “| xargs”。选项 -print0 必须在 find 命令的最后。看这个不错的 find 迷你教程.</p>
<h1 id="find-type-f-xargs-ls-l-不能工作于有空格的名字"><a href="#find-type-f-xargs-ls-l-不能工作于有空格的名字" class="headerlink" title="find . -type f | xargs ls -l       # 不能工作于有空格的名字"></a>find . -type f | xargs ls -l       # 不能工作于有空格的名字</h1><h1 id="find-type-f-print0-xargs-0-ls-l-可工作于有空格的名字"><a href="#find-type-f-print0-xargs-0-ls-l-可工作于有空格的名字" class="headerlink" title="find . -type f -print0 | xargs -0 ls -l  # 可工作于有空格的名字"></a>find . -type f -print0 | xargs -0 ls -l  # 可工作于有空格的名字</h1><h1 id="find-type-f-exec-ls-l-‘-’-或使用用于-exec-的引用-‘-’"><a href="#find-type-f-exec-ls-l-‘-’-或使用用于-exec-的引用-‘-’" class="headerlink" title="find . -type f -exec ls -l ‘{}’ \; # 或使用用于 -exec 的引用 ‘{}’"></a>find . -type f -exec ls -l ‘{}’ \; # 或使用用于 -exec 的引用 ‘{}’</h1><p>混杂的</p>
<h1 id="which-command-显示命令的全路径名"><a href="#which-command-显示命令的全路径名" class="headerlink" title="which command                      # 显示命令的全路径名"></a>which command                      # 显示命令的全路径名</h1><h1 id="time-command-显示一个命令执行完成所用的时间"><a href="#time-command-显示一个命令执行完成所用的时间" class="headerlink" title="time command                       # 显示一个命令执行完成所用的时间"></a>time command                       # 显示一个命令执行完成所用的时间</h1><h1 id="time-cat-使用-time-作为秒表，用-Ctrl-c-来停止"><a href="#time-cat-使用-time-作为秒表，用-Ctrl-c-来停止" class="headerlink" title="time cat                           # 使用 time 作为秒表，用 Ctrl-c 来停止"></a>time cat                           # 使用 time 作为秒表，用 Ctrl-c 来停止</h1><h1 id="set-grep-USER-列显当前环境变量"><a href="#set-grep-USER-列显当前环境变量" class="headerlink" title="set | grep $USER                   # 列显当前环境变量"></a>set | grep $USER                   # 列显当前环境变量</h1><h1 id="cal-3-显示三个月日历"><a href="#cal-3-显示三个月日历" class="headerlink" title="cal -3                             # 显示三个月日历"></a>cal -3                             # 显示三个月日历</h1><h1 id="date-u-–utc-–universal-MMDDhhmm-CC-YY-ss"><a href="#date-u-–utc-–universal-MMDDhhmm-CC-YY-ss" class="headerlink" title="date [-u|–utc|–universal] [MMDDhhmm[[CC]YY][.ss]]"></a>date [-u|–utc|–universal] [MMDDhhmm[[CC]YY][.ss]]</h1><h1 id="date-10022155-设置日期和时间"><a href="#date-10022155-设置日期和时间" class="headerlink" title="date 10022155                      # 设置日期和时间"></a>date 10022155                      # 设置日期和时间</h1><h1 id="whatis-grep-显示命令的简短信息"><a href="#whatis-grep-显示命令的简短信息" class="headerlink" title="whatis grep                        # 显示命令的简短信息"></a>whatis grep                        # 显示命令的简短信息</h1><h1 id="whereis-java-查询命令的的路径和标准目录"><a href="#whereis-java-查询命令的的路径和标准目录" class="headerlink" title="whereis java                       # 查询命令的的路径和标准目录"></a>whereis java                       # 查询命令的的路径和标准目录</h1><h1 id="setenv-varname-value-设置环境变量，设置变量-varname-的值为-value-csh-tcsh"><a href="#setenv-varname-value-设置环境变量，设置变量-varname-的值为-value-csh-tcsh" class="headerlink" title="setenv varname value               # 设置环境变量，设置变量 varname 的值为 value (csh/tcsh)"></a>setenv varname value               # 设置环境变量，设置变量 varname 的值为 value (csh/tcsh)</h1><h1 id="export-varname-”value”-设置环境变量，设置变量-varname-的值为-value-sh-ksh-bash"><a href="#export-varname-”value”-设置环境变量，设置变量-varname-的值为-value-sh-ksh-bash" class="headerlink" title="export varname=”value”             # 设置环境变量，设置变量 varname 的值为 value  (sh/ksh/bash)"></a>export varname=”value”             # 设置环境变量，设置变量 varname 的值为 value  (sh/ksh/bash)</h1><h1 id="pwd-显示当前工作目录"><a href="#pwd-显示当前工作目录" class="headerlink" title="pwd                                # 显示当前工作目录"></a>pwd                                # 显示当前工作目录</h1><h1 id="mkdir-p-path-to-dir-如果存在不显示错误，建立所需的上级目录"><a href="#mkdir-p-path-to-dir-如果存在不显示错误，建立所需的上级目录" class="headerlink" title="mkdir -p /path/to/dir              # 如果存在不显示错误，建立所需的上级目录"></a>mkdir -p /path/to/dir              # 如果存在不显示错误，建立所需的上级目录</h1><h1 id="mkdir-p-project-bin-src-obj-doc-html-man-pdf-debug-some-more-dirs"><a href="#mkdir-p-project-bin-src-obj-doc-html-man-pdf-debug-some-more-dirs" class="headerlink" title="mkdir -p project/{bin,src,obj,doc/{html,man,pdf},debug/some/more/dirs}"></a>mkdir -p project/{bin,src,obj,doc/{html,man,pdf},debug/some/more/dirs}</h1><h1 id="rmdir-path-to-dir-移除目录"><a href="#rmdir-path-to-dir-移除目录" class="headerlink" title="rmdir /path/to/dir                 # 移除目录"></a>rmdir /path/to/dir                 # 移除目录</h1><h1 id="rm-rf-path-to-dir-移除目录和其内容-强制"><a href="#rm-rf-path-to-dir-移除目录和其内容-强制" class="headerlink" title="rm -rf /path/to/dir                # 移除目录和其内容(强制)"></a>rm -rf /path/to/dir                # 移除目录和其内容(强制)</h1><h1 id="cp-la-dir1-dir2-存档、硬连接目录所有文件，用来替代拷贝"><a href="#cp-la-dir1-dir2-存档、硬连接目录所有文件，用来替代拷贝" class="headerlink" title="cp -la /dir1 /dir2                 # 存档、硬连接目录所有文件，用来替代拷贝"></a>cp -la /dir1 /dir2                 # 存档、硬连接目录所有文件，用来替代拷贝</h1><h1 id="cp-lpR-dir1-dir2-同上-FreeBSD"><a href="#cp-lpR-dir1-dir2-同上-FreeBSD" class="headerlink" title="cp -lpR /dir1 /dir2                # 同上 (FreeBSD)"></a>cp -lpR /dir1 /dir2                # 同上 (FreeBSD)</h1><h1 id="cp-unixtoolbox-xhtml-bak-拷贝文件成新扩展名的快速方法"><a href="#cp-unixtoolbox-xhtml-bak-拷贝文件成新扩展名的快速方法" class="headerlink" title="cp unixtoolbox.xhtml{,.bak}        # 拷贝文件成新扩展名的快速方法"></a>cp unixtoolbox.xhtml{,.bak}        # 拷贝文件成新扩展名的快速方法</h1><h1 id="mv-dir1-dir2-修改目录名"><a href="#mv-dir1-dir2-修改目录名" class="headerlink" title="mv /dir1 /dir2                     # 修改目录名"></a>mv /dir1 /dir2                     # 修改目录名</h1><p>软件安装</p>
<p>列出已安装过的软件包</p>
<h1 id="rpm-qa-列出已安装过的软件包-RH-SuSE-基于-RPM-的"><a href="#rpm-qa-列出已安装过的软件包-RH-SuSE-基于-RPM-的" class="headerlink" title="rpm -qa                            # 列出已安装过的软件包(RH, SuSE, 基于 RPM 的)"></a>rpm -qa                            # 列出已安装过的软件包(RH, SuSE, 基于 RPM 的)</h1><h1 id="dpkg-l-Debian-Ubuntu"><a href="#dpkg-l-Debian-Ubuntu" class="headerlink" title="dpkg -l                            # Debian, Ubuntu"></a>dpkg -l                            # Debian, Ubuntu</h1><h1 id="pkg-info-列出所有已安装过的软件包-FreeBSD"><a href="#pkg-info-列出所有已安装过的软件包-FreeBSD" class="headerlink" title="pkg_info                           # 列出所有已安装过的软件包(FreeBSD)"></a>pkg_info                           # 列出所有已安装过的软件包(FreeBSD)</h1><h1 id="pkg-info-W-smbd-查看-smbd-安装了那些软件包-FreeBSD"><a href="#pkg-info-W-smbd-查看-smbd-安装了那些软件包-FreeBSD" class="headerlink" title="pkg_info -W smbd                   # 查看 smbd 安装了那些软件包(FreeBSD)"></a>pkg_info -W smbd                   # 查看 smbd 安装了那些软件包(FreeBSD)</h1><h1 id="pkginfo-Solaris"><a href="#pkginfo-Solaris" class="headerlink" title="pkginfo                            # Solaris"></a>pkginfo                            # Solaris</h1><p>添加/删除软件</p>
<p>前端界面：SuSE 为 yast2/yast，Red Hat 为 redhat-config-packages。</p>
<h1 id="rpm-i-pkgname-rpm-安装软件包-RH-SuSE-基于-RPM-的"><a href="#rpm-i-pkgname-rpm-安装软件包-RH-SuSE-基于-RPM-的" class="headerlink" title="rpm -i pkgname.rpm                 # 安装软件包(RH, SuSE, 基于 RPM 的)"></a>rpm -i pkgname.rpm                 # 安装软件包(RH, SuSE, 基于 RPM 的)</h1><h1 id="rpm-e-pkgname-删除软件包"><a href="#rpm-e-pkgname-删除软件包" class="headerlink" title="rpm -e pkgname                     # 删除软件包"></a>rpm -e pkgname                     # 删除软件包</h1><p>Debian</p>
<h1 id="apt-get-update-更新源列表"><a href="#apt-get-update-更新源列表" class="headerlink" title="apt-get update                     # 更新源列表"></a>apt-get update                     # 更新源列表</h1><h1 id="apt-get-install-emacs-安装-emacs-软件包"><a href="#apt-get-install-emacs-安装-emacs-软件包" class="headerlink" title="apt-get install emacs              # 安装 emacs 软件包"></a>apt-get install emacs              # 安装 emacs 软件包</h1><h1 id="dpkg-–remove-emacs-删除-emacs-软件包"><a href="#dpkg-–remove-emacs-删除-emacs-软件包" class="headerlink" title="dpkg –remove emacs                # 删除 emacs 软件包"></a>dpkg –remove emacs                # 删除 emacs 软件包</h1><h1 id="dpkg-S-file-查找拥有该-file-的软件包"><a href="#dpkg-S-file-查找拥有该-file-的软件包" class="headerlink" title="dpkg -S file                       # 查找拥有该 file 的软件包"></a>dpkg -S file                       # 查找拥有该 file 的软件包</h1><p>Gentoo</p>
<p>Gentoo 使用 emerge 作为 “Portage” 软件包管理系统的核心。</p>
<h1 id="emerge-–sync-同步更新本地-protage-树"><a href="#emerge-–sync-同步更新本地-protage-树" class="headerlink" title="emerge –sync                      # 同步更新本地 protage 树"></a>emerge –sync                      # 同步更新本地 protage 树</h1><h1 id="emerge-u-packagename-安装或更新一个软件包"><a href="#emerge-u-packagename-安装或更新一个软件包" class="headerlink" title="emerge -u packagename              # 安装或更新一个软件包"></a>emerge -u packagename              # 安装或更新一个软件包</h1><h1 id="emerge-C-packagename-删除软件包"><a href="#emerge-C-packagename-删除软件包" class="headerlink" title="emerge -C packagename              # 删除软件包"></a>emerge -C packagename              # 删除软件包</h1><h1 id="revdep-rebuild-修复依赖关系的缺失"><a href="#revdep-rebuild-修复依赖关系的缺失" class="headerlink" title="revdep-rebuild                     # 修复依赖关系的缺失"></a>revdep-rebuild                     # 修复依赖关系的缺失</h1><p>Solaris</p>
<p><cdrom> 路径通常为 /cdrom/cdrom0.</cdrom></p>
<h1 id="pkgadd-d-Solaris-9-Product-SUNWgtar"><a href="#pkgadd-d-Solaris-9-Product-SUNWgtar" class="headerlink" title="pkgadd -d /Solaris_9/Product SUNWgtar"></a>pkgadd -d <cdrom>/Solaris_9/Product SUNWgtar</cdrom></h1><h1 id="pkgadd-d-SUNWgtar-添加下载的软件包-先要-bunzip2"><a href="#pkgadd-d-SUNWgtar-添加下载的软件包-先要-bunzip2" class="headerlink" title="pkgadd -d SUNWgtar                 # 添加下载的软件包(先要 bunzip2)"></a>pkgadd -d SUNWgtar                 # 添加下载的软件包(先要 bunzip2)</h1><h1 id="pkgrm-SUNWgtar-删除软件包"><a href="#pkgrm-SUNWgtar-删除软件包" class="headerlink" title="pkgrm SUNWgtar                     # 删除软件包"></a>pkgrm SUNWgtar                     # 删除软件包</h1><p>FreeBSD</p>
<h1 id="pkg-add-r-rsync-获取并安装-rsync"><a href="#pkg-add-r-rsync-获取并安装-rsync" class="headerlink" title="pkg_add -r rsync                   # 获取并安装 rsync"></a>pkg_add -r rsync                   # 获取并安装 rsync</h1><h1 id="pkg-delete-var-db-pkg-rsync-xx-删除-rsync-软件包"><a href="#pkg-delete-var-db-pkg-rsync-xx-删除-rsync-软件包" class="headerlink" title="pkg_delete /var/db/pkg/rsync-xx    # 删除 rsync 软件包"></a>pkg_delete /var/db/pkg/rsync-xx    # 删除 rsync 软件包</h1><p>可使用 PACKAGESITE 环境变量来设置哪里可以获取软件包。举个例子：</p>
<h1 id="export-PACKAGESITE-ftp-ftp-freebsd-org-pub-FreeBSD-ports-i386-packages-Latest"><a href="#export-PACKAGESITE-ftp-ftp-freebsd-org-pub-FreeBSD-ports-i386-packages-Latest" class="headerlink" title="export PACKAGESITE=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages/Latest/"></a>export PACKAGESITE=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages/Latest/</h1><h1 id="or-ftp-ftp-freebsd-org-pub-FreeBSD-ports-i386-packages-6-stable-Latest"><a href="#or-ftp-ftp-freebsd-org-pub-FreeBSD-ports-i386-packages-6-stable-Latest" class="headerlink" title="or ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/"></a>or ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/</h1><p>FreeBSD ports</p>
<p>Port 树 /usr/ports/ 是一个准备编译和安装的软件集。可用 portsnap 工具来跟新 port。</p>
<h1 id="portsnap-fetch-extract-当第一次运行这个命令，会创建-port-树"><a href="#portsnap-fetch-extract-当第一次运行这个命令，会创建-port-树" class="headerlink" title="portsnap fetch extract             # 当第一次运行这个命令，会创建 port 树"></a>portsnap fetch extract             # 当第一次运行这个命令，会创建 port 树</h1><h1 id="portsnap-fetch-update-跟新-port-树"><a href="#portsnap-fetch-update-跟新-port-树" class="headerlink" title="portsnap fetch update              # 跟新 port 树"></a>portsnap fetch update              # 跟新 port 树</h1><h1 id="cd-usr-ports-net-rsync-选择软件安装目录"><a href="#cd-usr-ports-net-rsync-选择软件安装目录" class="headerlink" title="cd /usr/ports/net/rsync/           # 选择软件安装目录"></a>cd /usr/ports/net/rsync/           # 选择软件安装目录</h1><h1 id="make-install-distclean-安装并清理-也可看-man-ports"><a href="#make-install-distclean-安装并清理-也可看-man-ports" class="headerlink" title="make install distclean             # 安装并清理(也可看 man ports)"></a>make install distclean             # 安装并清理(也可看 man ports)</h1><h1 id="make-package-Make-一个二进制软件包"><a href="#make-package-Make-一个二进制软件包" class="headerlink" title="make package                       # Make 一个二进制软件包"></a>make package                       # Make 一个二进制软件包</h1><p>库路径</p>
<p>由于复杂的依赖关系和运行时链接，程序难于分发或拷贝到其他系统。不过对于较少依赖关系的小程序，缺失的库可被拷贝过去。运行时库(即缺失的库)可用 ldd 和 ldconfig 来检查和管理。</p>
<h1 id="ldd-usr-bin-rsync-列出所有所需的运行时库"><a href="#ldd-usr-bin-rsync-列出所有所需的运行时库" class="headerlink" title="ldd /usr/bin/rsync                 # 列出所有所需的运行时库"></a>ldd /usr/bin/rsync                 # 列出所有所需的运行时库</h1><h1 id="ldconfig-n-path-to-libs-添加一个路径到共享库目录Add-a-path-to-the-shared-libraries-directories"><a href="#ldconfig-n-path-to-libs-添加一个路径到共享库目录Add-a-path-to-the-shared-libraries-directories" class="headerlink" title="ldconfig -n /path/to/libs/         # 添加一个路径到共享库目录Add a path to the shared libraries directories"></a>ldconfig -n /path/to/libs/         # 添加一个路径到共享库目录Add a path to the shared libraries directories</h1><h1 id="ldconfig-m-path-to-libs-FreeBSD"><a href="#ldconfig-m-path-to-libs-FreeBSD" class="headerlink" title="ldconfig -m /path/to/libs/         # FreeBSD"></a>ldconfig -m /path/to/libs/         # FreeBSD</h1><h1 id="LD-LIBRARY-PATH-设置连接库路径的环境变量"><a href="#LD-LIBRARY-PATH-设置连接库路径的环境变量" class="headerlink" title="LD_LIBRARY_PATH                    # 设置连接库路径的环境变量"></a>LD_LIBRARY_PATH                    # 设置连接库路径的环境变量</h1><p>媒体转换</p>
<p>有时候需要转换一个视频、音频文件或者文档成其他格式。<br>文本编码</p>
<p>文本编码可以得到完全错误的，特别是当语言需要某些特殊字符像 àäç。命令 iconv 可以从一个编码转换成另一个编码。</p>
<h1 id="iconv-f-t"><a href="#iconv-f-t" class="headerlink" title="iconv -f  -t  "></a>iconv -f <from_encoding> -t <to_encoding> <input_file></input_file></to_encoding></from_encoding></h1><h1 id="iconv-f-ISO8859-1-t-UTF-8-o-file-input-gt-file-utf8"><a href="#iconv-f-ISO8859-1-t-UTF-8-o-file-input-gt-file-utf8" class="headerlink" title="iconv -f ISO8859-1 -t UTF-8 -o file.input &gt; file_utf8"></a>iconv -f ISO8859-1 -t UTF-8 -o file.input &gt; file_utf8</h1><h1 id="iconv-l-列显系统所支持的字符编码"><a href="#iconv-l-列显系统所支持的字符编码" class="headerlink" title="iconv -l                           # 列显系统所支持的字符编码"></a>iconv -l                           # 列显系统所支持的字符编码</h1><p>若文档显示良好，通常都可不使用 -f 选项，iconv 会使用本地字符集(char-set)。<br>Unix - DOS 新行</p>
<p>在 Unix Shell 中转换 DOS (CR/LF) 到 Unix (LF) 新行格式。也可使用 dos2unix 和 unix2dos 工具，如果你有它们的话。</p>
<h1 id="sed-‘s-‘-dosfile-txt-gt-unixfile-txt"><a href="#sed-‘s-‘-dosfile-txt-gt-unixfile-txt" class="headerlink" title="sed ‘s/.$//‘ dosfile.txt &gt; unixfile.txt"></a>sed ‘s/.$//‘ dosfile.txt &gt; unixfile.txt</h1><p>在 Windows 环境中转换 Unix 到 Dos 新行格式。需要在 mingw 或 cygwin 中使用 sed。</p>
<h1 id="sed-n-p-unixfile-txt-gt-dosfile-txt"><a href="#sed-n-p-unixfile-txt-gt-dosfile-txt" class="headerlink" title="sed -n p unixfile.txt &gt; dosfile.txt"></a>sed -n p unixfile.txt &gt; dosfile.txt</h1><p>PDF 转换成 Jpeg 和 连接一串 PDF 文件</p>
<p>用 gs (GhostScript) 工具转换 PDF 文档的每一页成 jpeg (或 png)图像。也可以使用更短的 convert (来自 ImageMagick 或 GraphicsMagick 工具) 命令。</p>
<h1 id="gs-dBATCH-dNOPAUSE-sDEVICE-jpeg-r150-dTextAlphaBits-4-dGraphicsAlphaBits-4"><a href="#gs-dBATCH-dNOPAUSE-sDEVICE-jpeg-r150-dTextAlphaBits-4-dGraphicsAlphaBits-4" class="headerlink" title="gs -dBATCH -dNOPAUSE -sDEVICE=jpeg -r150 -dTextAlphaBits=4 -dGraphicsAlphaBits=4 \"></a>gs -dBATCH -dNOPAUSE -sDEVICE=jpeg -r150 -dTextAlphaBits=4 -dGraphicsAlphaBits=4 \</h1><p> -dMaxStripSize=8192 -sOutputFile=unixtoolbox_%d.jpg unixtoolbox.pdf</p>
<h1 id="convert-unixtoolbox-pdf-unixtoolbox-03d-png"><a href="#convert-unixtoolbox-pdf-unixtoolbox-03d-png" class="headerlink" title="convert unixtoolbox.pdf unixtoolbox-%03d.png"></a>convert unixtoolbox.pdf unixtoolbox-%03d.png</h1><h1 id="convert-jpeg-images-pdf-把所有图片转换成一份简单的-PDF-文档"><a href="#convert-jpeg-images-pdf-把所有图片转换成一份简单的-PDF-文档" class="headerlink" title="convert *.jpeg images.pdf          # 把所有图片转换成一份简单的 PDF 文档"></a>convert *.jpeg images.pdf          # 把所有图片转换成一份简单的 PDF 文档</h1><p>Ghostscript 同样可连接多个 pdf 文件成一份 PDF 文档。这仅可工作于这些 PDF 文件都 “呈现一致(well behaved)” 的情况下。</p>
<h1 id="gs-q-sPAPERSIZE-a4-dNOPAUSE-dBATCH-sDEVICE-pdfwrite-sOutputFile-all-pdf"><a href="#gs-q-sPAPERSIZE-a4-dNOPAUSE-dBATCH-sDEVICE-pdfwrite-sOutputFile-all-pdf" class="headerlink" title="gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=all.pdf \"></a>gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=all.pdf \</h1><p>file1.pdf file2.pdf …              # 在 Windows 上使用 ‘#’ 代替 ‘=’<br>视频转换</p>
<p>使用 mpeg4 编码压缩佳能数码相机视频并修复无用音质。</p>
<h1 id="mencoder-o-videoout-avi-oac-mp3lame-ovc-lavc-srate-11025"><a href="#mencoder-o-videoout-avi-oac-mp3lame-ovc-lavc-srate-11025" class="headerlink" title="mencoder -o videoout.avi -oac mp3lame -ovc lavc -srate 11025 \"></a>mencoder -o videoout.avi -oac mp3lame -ovc lavc -srate 11025 \</h1><p>-channels 1 -af-adv force=1 -lameopts preset=medium -lavcopts \<br>vcodec=msmpeg4v2:vbitrate=600 -mc 0 vidoein.AVI<br>对于声音的处理可看 sox。<br>拷贝音频光盘</p>
<p>程序 cdparanoia 可以保存音轨(FreeBSD port 在 audio/cdparanoia/)，oggenc 可编码 Ogg Vorbis 格式，lame 可转换成 mp3。</p>
<h1 id="cdparanoia-B-拷贝音轨成-wav-文件到当前目录列表-dir"><a href="#cdparanoia-B-拷贝音轨成-wav-文件到当前目录列表-dir" class="headerlink" title="cdparanoia -B                      # 拷贝音轨成 wav 文件到当前目录列表(dir)"></a>cdparanoia -B                      # 拷贝音轨成 wav 文件到当前目录列表(dir)</h1><h1 id="lame-b-256-in-wav-out-mp3-编码成-256-kb-s-的-mp3"><a href="#lame-b-256-in-wav-out-mp3-编码成-256-kb-s-的-mp3" class="headerlink" title="lame -b 256 in.wav out.mp3         # 编码成 256 kb/s 的 mp3"></a>lame -b 256 in.wav out.mp3         # 编码成 256 kb/s 的 mp3</h1><h1 id="for-i-in-wav-do-lame-b-256-i-basename-i-wav-mp3-done"><a href="#for-i-in-wav-do-lame-b-256-i-basename-i-wav-mp3-done" class="headerlink" title="for i in *.wav; do lame -b 256 $i basename $i .wav.mp3; done"></a>for i in *.wav; do lame -b 256 $i <code>basename $i .wav</code>.mp3; done</h1><h1 id="oggenc-in-wav-b-256-out-ogg-编码成-256-kb-s-的-Ogg-Vorbis"><a href="#oggenc-in-wav-b-256-out-ogg-编码成-256-kb-s-的-Ogg-Vorbis" class="headerlink" title="oggenc in.wav -b 256 out.ogg       # 编码成 256 kb/s 的 Ogg Vorbis"></a>oggenc in.wav -b 256 out.ogg       # 编码成 256 kb/s 的 Ogg Vorbis</h1><p>打印</p>
<p>打印命令 lpr</p>
<h1 id="lpr-unixtoolbox-ps-用默认打印机打印"><a href="#lpr-unixtoolbox-ps-用默认打印机打印" class="headerlink" title="lpr unixtoolbox.ps                 # 用默认打印机打印"></a>lpr unixtoolbox.ps                 # 用默认打印机打印</h1><h1 id="export-PRINTER-hp4600-更改默认打印机"><a href="#export-PRINTER-hp4600-更改默认打印机" class="headerlink" title="export PRINTER=hp4600              # 更改默认打印机"></a>export PRINTER=hp4600              # 更改默认打印机</h1><h1 id="lpr-Php4500-2-unixtoolbox-ps-指定打印机-hp4500-并打印-2-份"><a href="#lpr-Php4500-2-unixtoolbox-ps-指定打印机-hp4500-并打印-2-份" class="headerlink" title="lpr -Php4500 #2 unixtoolbox.ps     # 指定打印机 hp4500 并打印 2 份"></a>lpr -Php4500 #2 unixtoolbox.ps     # 指定打印机 hp4500 并打印 2 份</h1><h1 id="lpr-o-Duplex-DuplexNoTumble-…-启用双面打印"><a href="#lpr-o-Duplex-DuplexNoTumble-…-启用双面打印" class="headerlink" title="lpr -o Duplex=DuplexNoTumble …   # 启用双面打印"></a>lpr -o Duplex=DuplexNoTumble …   # 启用双面打印</h1><h1 id="lpr-o-PageSize-A4-Duplex-DuplexNoTumble-…"><a href="#lpr-o-PageSize-A4-Duplex-DuplexNoTumble-…" class="headerlink" title="lpr -o PageSize=A4,Duplex=DuplexNoTumble …"></a>lpr -o PageSize=A4,Duplex=DuplexNoTumble …</h1><h1 id="lpq-查看默认打印机的队列"><a href="#lpq-查看默认打印机的队列" class="headerlink" title="lpq                                # 查看默认打印机的队列"></a>lpq                                # 查看默认打印机的队列</h1><h1 id="lpq-l-Php4500-详细显示打印机队列信息"><a href="#lpq-l-Php4500-详细显示打印机队列信息" class="headerlink" title="lpq -l -Php4500                    # 详细显示打印机队列信息"></a>lpq -l -Php4500                    # 详细显示打印机队列信息</h1><h1 id="lprm-删除所有打印机内的用户打印作业"><a href="#lprm-删除所有打印机内的用户打印作业" class="headerlink" title="lprm -                             # 删除所有打印机内的用户打印作业"></a>lprm -                             # 删除所有打印机内的用户打印作业</h1><h1 id="lprm-Php4500-3186-删除作业-3186。可使用-lpq-查看作业号"><a href="#lprm-Php4500-3186-删除作业-3186。可使用-lpq-查看作业号" class="headerlink" title="lprm -Php4500 3186                 # 删除作业 3186。可使用 lpq 查看作业号"></a>lprm -Php4500 3186                 # 删除作业 3186。可使用 lpq 查看作业号</h1><h1 id="lpc-status-列印所有可用打印机"><a href="#lpc-status-列印所有可用打印机" class="headerlink" title="lpc status                         # 列印所有可用打印机"></a>lpc status                         # 列印所有可用打印机</h1><h1 id="lpc-status-hp4500-如果打印机在线，查看其状态和列队长度"><a href="#lpc-status-hp4500-如果打印机在线，查看其状态和列队长度" class="headerlink" title="lpc status hp4500                  # 如果打印机在线，查看其状态和列队长度"></a>lpc status hp4500                  # 如果打印机在线，查看其状态和列队长度</h1><p>当要打印 PDF 文件时，一些打印设备不具备处理 postscript 的能力。可以这样解决：</p>
<h1 id="gs-dSAFER-dNOPAUSE-sDEVICE-deskjet-sOutputFile-lpr-file-pdf"><a href="#gs-dSAFER-dNOPAUSE-sDEVICE-deskjet-sOutputFile-lpr-file-pdf" class="headerlink" title="gs -dSAFER -dNOPAUSE -sDEVICE=deskjet -sOutputFile=|lpr file.pdf"></a>gs -dSAFER -dNOPAUSE -sDEVICE=deskjet -sOutputFile=|lpr file.pdf</h1><p>数据库</p>
<p>PostgreSQL</p>
<p>更改 root 用户或其它用户的密码</p>
<h1 id="psql-d-template1-U-pgsql"><a href="#psql-d-template1-U-pgsql" class="headerlink" title="psql -d template1 -U pgsql"></a>psql -d template1 -U pgsql</h1><blockquote>
<p>alter user pgsql with password ‘pgsql_password’;  # pgsql 为需要更改密码的用户名<br>创建用户和数据库</p>
</blockquote>
<p>命令 createuser, dropuser, createdb 和 dropdb 等同于 SQL 命令的快捷方式。我们创建一个新用户叫 bob 和一个数据库叫 bobdb；使用数据库的超级用户 pgsql 来创建：</p>
<h1 id="createuser-U-pgsql-P-bob-P-会请求一个秘密"><a href="#createuser-U-pgsql-P-bob-P-会请求一个秘密" class="headerlink" title="createuser -U pgsql -P bob         # -P 会请求一个秘密"></a>createuser -U pgsql -P bob         # -P 会请求一个秘密</h1><h1 id="createdb-U-pgsql-O-bob-bobdb-新数据库-bobdn-的所有者是-bob"><a href="#createdb-U-pgsql-O-bob-bobdb-新数据库-bobdn-的所有者是-bob" class="headerlink" title="createdb -U pgsql -O bob bobdb     # 新数据库 bobdn 的所有者是 bob"></a>createdb -U pgsql -O bob bobdb     # 新数据库 bobdn 的所有者是 bob</h1><h1 id="dropdb-bobdb-删除数据库-bobdb"><a href="#dropdb-bobdb-删除数据库-bobdb" class="headerlink" title="dropdb bobdb                       # 删除数据库 bobdb"></a>dropdb bobdb                       # 删除数据库 bobdb</h1><h1 id="dropuser-bob-删除用户-bob"><a href="#dropuser-bob-删除用户-bob" class="headerlink" title="dropuser bob                       # 删除用户 bob"></a>dropuser bob                       # 删除用户 bob</h1><p>一般数据库认证机制配置在 pg_hba.conf 文件中。<br>允许远程访问</p>
<p>文件 $PGSQL_DATA_D/postgresql.conf 可指定绑定地址。对于 Postgres 8.x 通常为 listen_addresses = ‘*’。<br>文件 $PGSQL_DATA_D/pg_hba.conf 定义了访问控制。举例：</p>
<h1 id="TYPE-DATABASE-USER-IP-ADDRESS-IP-MASK-METHOD"><a href="#TYPE-DATABASE-USER-IP-ADDRESS-IP-MASK-METHOD" class="headerlink" title="TYPE  DATABASE    USER        IP-ADDRESS        IP-MASK          METHOD"></a>TYPE  DATABASE    USER        IP-ADDRESS        IP-MASK          METHOD</h1><p>host    bobdb       bob        212.117.81.42     255.255.255.255   password<br>host    all         all        0.0.0.0/0                           password<br>备份和恢复</p>
<p>使用 pgsql 或 postgres 用户来完成备份与恢复。下面是备份和恢复单个数据库：</p>
<h1 id="pg-dump-–clean-dbname-gt-dbname-sql-dump"><a href="#pg-dump-–clean-dbname-gt-dbname-sql-dump" class="headerlink" title="pg_dump –clean dbname &gt; dbname_sql.dump"></a>pg_dump –clean dbname &gt; dbname_sql.dump</h1><h1 id="psql-dbname-lt-dbname-sql-dump"><a href="#psql-dbname-lt-dbname-sql-dump" class="headerlink" title="psql dbname &lt; dbname_sql.dump"></a>psql dbname &lt; dbname_sql.dump</h1><p>备份和恢复所有数据库(包括用户)：</p>
<h1 id="pg-dumpall-–clean-gt-full-dump"><a href="#pg-dumpall-–clean-gt-full-dump" class="headerlink" title="pg_dumpall –clean &gt; full.dump"></a>pg_dumpall –clean &gt; full.dump</h1><h1 id="psql-f-full-dump-postgres"><a href="#psql-f-full-dump-postgres" class="headerlink" title="psql -f full.dump postgres"></a>psql -f full.dump postgres</h1><p>在这个例子中，你可以声明任意现有的数据库进行连接，但是如果你是向一个空的数据库集群装载，那么 postgres 应该是比较好的选择。<br>MySQL</p>
<p>更改 mysql root 用户或其它用户的密码</p>
<p>方法 1</p>
<h1 id="etc-init-d-mysql-stop"><a href="#etc-init-d-mysql-stop" class="headerlink" title="/etc/init.d/mysql stop"></a>/etc/init.d/mysql stop</h1><p>or</p>
<h1 id="killall-mysqld"><a href="#killall-mysqld" class="headerlink" title="killall mysqld"></a>killall mysqld</h1><h1 id="mysqld-–skip-grant-tables"><a href="#mysqld-–skip-grant-tables" class="headerlink" title="mysqld –skip-grant-tables"></a>mysqld –skip-grant-tables</h1><h1 id="mysqladmin-u-root-password-‘newpasswd’"><a href="#mysqladmin-u-root-password-‘newpasswd’" class="headerlink" title="mysqladmin -u root password ‘newpasswd’"></a>mysqladmin -u root password ‘newpasswd’</h1><h1 id="etc-init-d-mysql-start"><a href="#etc-init-d-mysql-start" class="headerlink" title="/etc/init.d/mysql start"></a>/etc/init.d/mysql start</h1><p>方法 2</p>
<h1 id="mysql-u-root-mysql"><a href="#mysql-u-root-mysql" class="headerlink" title="mysql -u root mysql"></a>mysql -u root mysql</h1><p>mysql&gt; UPDATE USER SET PASSWORD=PASSWORD(“newpassword”) where user=’root’;<br>mysql&gt; FLUSH PRIVILEGES;                           # 使用用户名替代”root”<br>mysql&gt; quit<br>创建用户和数据库</p>
<h1 id="mysql-u-root-mysql-1"><a href="#mysql-u-root-mysql-1" class="headerlink" title="mysql -u root mysql"></a>mysql -u root mysql</h1><p>mysql&gt; CREATE DATABASE bobdb;<br>mysql&gt; GRANT ALL ON <em>.</em> TO ‘bob’@’%’ IDENTIFIED BY ‘pwd’; </p>
<pre><code># 使用 localhost 替代 % 来限制网络访问
</code></pre><p>mysql&gt; DROP DATABASE bobdb;                        # 删除数据库 bobdb<br>mysql&gt; DROP USER bob;                              # 删除用户 bob<br>mysql&gt; DELETE FROM mysql.user WHERE user=’bob and host=’hostname’; </p>
<pre><code># 删除 mysql 数据库 user 表中 user=bob,host=hostname 的记录
</code></pre><p>mysql&gt; FLUSH PRIVILEGES;<br>允许远程访问</p>
<p>远程访问通常允许单个数据库，而不是所有的数据库。文件 /etc/my.cnf 包含约定的 IP 地址。通常为 bind-address = 绑定地址。</p>
<h1 id="mysql-u-root-mysql-2"><a href="#mysql-u-root-mysql-2" class="headerlink" title="mysql -u root mysql"></a>mysql -u root mysql</h1><p>mysql&gt; GRANT ALL ON bobdb.<em> TO bob@’xxx.xxx.xxx.xxx’ IDENTIFIED BY ‘PASSWORD’;<br>mysql&gt; REVOKE GRANT OPTION ON foo.</em> FROM bar@’xxx.xxx.xxx.xxx’;<br>mysql&gt; FLUSH PRIVILEGES;                  # 使用 ‘hostname’ 也可为 ‘%’ 来完全访问<br>备份和恢复</p>
<p>备份和恢复单个数据库：</p>
<h1 id="mysqldump-u-root-psecret-–add-drop-database-dbname-gt-dbname-sql-dump"><a href="#mysqldump-u-root-psecret-–add-drop-database-dbname-gt-dbname-sql-dump" class="headerlink" title="mysqldump -u root -psecret –add-drop-database dbname &gt; dbname_sql.dump"></a>mysqldump -u root -psecret –add-drop-database dbname &gt; dbname_sql.dump</h1><h1 id="mysql-u-root-psecret-D-dbname-lt-dbname-sql-dump"><a href="#mysql-u-root-psecret-D-dbname-lt-dbname-sql-dump" class="headerlink" title="mysql -u root -psecret -D dbname &lt; dbname_sql.dump"></a>mysql -u root -psecret -D dbname &lt; dbname_sql.dump</h1><p>备份和恢复所有的数据库：</p>
<h1 id="mysqldump-u-root-psecret-–add-drop-database-–all-databases-gt-full-dump"><a href="#mysqldump-u-root-psecret-–add-drop-database-–all-databases-gt-full-dump" class="headerlink" title="mysqldump -u root -psecret –add-drop-database –all-databases &gt; full.dump"></a>mysqldump -u root -psecret –add-drop-database –all-databases &gt; full.dump</h1><h1 id="mysql-u-root-psecret-lt-full-dump"><a href="#mysql-u-root-psecret-lt-full-dump" class="headerlink" title="mysql -u root -psecret &lt; full.dump"></a>mysql -u root -psecret &lt; full.dump</h1><p>这里 mysql root 的密码为 “secret”，-p 选项后面没有空格。当单独使用 -p 选项(不跟密码)，命令行提示符后会要求输入密码。<br>SQLite</p>
<p>SQLite 是一个小而强大的、独立的(self-contained)、无服务器的(serverless)、零配置的(zero-configuration) SQL 数据库。<br>备份和恢复</p>
<p>实用备份和恢复 SQLite 数据库命令。举个例子，你可以编辑备份文件来修改字段的属性和类型，然后再恢复这个数据库。这比使用 SQL 命令来得容易。对于 3.x 数据库可使用 sqlite3。</p>
<h1 id="sqlite-database-db-dump-gt-dump-sql-备份"><a href="#sqlite-database-db-dump-gt-dump-sql-备份" class="headerlink" title="sqlite database.db .dump &gt; dump.sql              # 备份"></a>sqlite database.db .dump &gt; dump.sql              # 备份</h1><h1 id="sqlite-database-db-lt-dump-sql-恢复"><a href="#sqlite-database-db-lt-dump-sql-恢复" class="headerlink" title="sqlite database.db &lt; dump.sql                    # 恢复"></a>sqlite database.db &lt; dump.sql                    # 恢复</h1><p>转换 2.x 到 3.x 数据库</p>
<p>sqlite database_v2.db .dump | sqlite3 database_v3.db<br>磁盘限额</p>
<p>磁盘限额用来限制磁盘空间大小和/或用户(或用户组)可用的文件数。The quotas are allocated on a per-file system basis and are enforced by the kernel.<br>Linux 设置</p>
<p>Quota 工具包通常已安装，其包含一些命令行工具。<br>在 fstab 中激活用户配额并重新挂载分区。如果分区正在使用，关闭所有使用的文件，或者重启系统。添加 usrquota 到 fstab 的挂载类型中，举个例子：<br>/dev/sda2     /home    reiserfs     rw,acl,user_xattr,usrquota 1 1</p>
<h1 id="mount-o-remount-home"><a href="#mount-o-remount-home" class="headerlink" title="mount -o remount /home"></a>mount -o remount /home</h1><h1 id="mount-检查-usrquota-已经激活，否则重启"><a href="#mount-检查-usrquota-已经激活，否则重启" class="headerlink" title="mount                              # 检查 usrquota 已经激活，否则重启"></a>mount                              # 检查 usrquota 已经激活，否则重启</h1><p>用 quotacheck 初始化 quota.user 文件。</p>
<h1 id="quotacheck-vum-home"><a href="#quotacheck-vum-home" class="headerlink" title="quotacheck -vum /home"></a>quotacheck -vum /home</h1><h1 id="chmod-644-home-aquota-user-让用户检查自己的配额"><a href="#chmod-644-home-aquota-user-让用户检查自己的配额" class="headerlink" title="chmod 644 /home/aquota.user        # 让用户检查自己的配额"></a>chmod 644 /home/aquota.user        # 让用户检查自己的配额</h1><p>用脚本(e.g. SuSE 的 /etc/init.d/quotad)或 quotaon 来启用限额：<br>quotaon -vu /home<br>检查配额启用情况：<br>quota -v<br>FreeBSD 设置</p>
<p>Quota 工具是 FreeBSD 基本系统的一部分，然而内核需要 quota 选项。如果不存在，新增它并重新编译内核。<br>options QUOTA<br>与 Linux 一样，添加限额到 fstab 选项(是 userquota，而不是 usrquota)中：<br>/dev/ad0s1d    /home    ufs     rw,noatime,userquota    2  2</p>
<h1 id="mount-home-重新挂载分区"><a href="#mount-home-重新挂载分区" class="headerlink" title="mount /home                        # 重新挂载分区"></a>mount /home                        # 重新挂载分区</h1><p>在 /etc/rc.conf 中启用磁盘限额并开启 quota 服务。</p>
<h1 id="grep-quotas-etc-rc-conf"><a href="#grep-quotas-etc-rc-conf" class="headerlink" title="grep quotas /etc/rc.conf"></a>grep quotas /etc/rc.conf</h1><p>enable_quotas=”YES”                  # 在启动时打开限额(或者 “NO”)<br>check_quotas=”YES”                   # 在启动时检查限额(或者 “NO”)</p>
<h1 id="etc-rc-d-quota-start"><a href="#etc-rc-d-quota-start" class="headerlink" title="/etc/rc.d/quota start"></a>/etc/rc.d/quota start</h1><p>分配限额</p>
<p>磁盘限额默认并不限制(设置为0)。用 edquota 来对单用户进行限制。一个 quota 也可给许多用户复用。虽然 quota 实现之间的文件结构不同，但其原理是相同的：限制节点(inodes)数量以及使用者可以取用的磁盘区块数量。Only change the values of soft and hard. 如果未指定，默认区块大小为 1k。使用 edquota -t 设置 grace 时间。举个例子：</p>
<h1 id="edquota-u-colin"><a href="#edquota-u-colin" class="headerlink" title="edquota -u colin"></a>edquota -u colin</h1><p>Linux</p>
<p>Disk quotas for user colin (uid 1007):<br>  Filesystem         blocks       soft       hard     inodes     soft     hard<br>  /dev/sda8            108       1000       2000          1        0        0<br>FreeBSD</p>
<p>Quotas for user colin:<br>/home: kbytes in use: 504184, limits (soft = 700000, hard = 800000)<br>   inodes in use: 1792, limits (soft = 0, hard = 0)<br>给许多用户分配限额</p>
<p>命令 edquota -p 用来复用一个 quota 给其他用户。举个例子，复用所指用户的限额给所有用户：</p>
<h1 id="edquota-p-refuser-awk-F-3-gt-499-print-1-39-etc-passwd"><a href="#edquota-p-refuser-awk-F-3-gt-499-print-1-39-etc-passwd" class="headerlink" title="edquota -p refuser awk -F: $3 &gt; 499 {print $1}&#39; /etc/passwd"></a>edquota -p refuser <code>awk -F: $3 &gt; 499 {print $1}&#39; /etc/passwd</code></h1><h1 id="edquota-p-refuser-user1-user2-复用给-2-个用户"><a href="#edquota-p-refuser-user1-user2-复用给-2-个用户" class="headerlink" title="edquota -p refuser user1 user2     # 复用给 2 个用户"></a>edquota -p refuser user1 user2     # 复用给 2 个用户</h1><p>检查</p>
<p>用户只需输入 quota (文件 quota.user 必须可读) 来可以检查他们的限额。Root 可以查看所有用户的限额。</p>
<h1 id="quota-u-colin-查看用户的限额"><a href="#quota-u-colin-查看用户的限额" class="headerlink" title="quota -u colin                     # 查看用户的限额"></a>quota -u colin                     # 查看用户的限额</h1><h1 id="repquota-home-所有用户在这个分区上的限额情况"><a href="#repquota-home-所有用户在这个分区上的限额情况" class="headerlink" title="repquota /home                     # 所有用户在这个分区上的限额情况"></a>repquota /home                     # 所有用户在这个分区上的限额情况</h1><p>SHELLS</p>
<p>许多 Linux 发行版使用 BASH Shell，BSD 使用的是 tcsh，Bourne Shell 仅用于脚本。过滤器(Filter)非常有用并且可用于管道(pipe)：<br>grep    模式匹配<br>sed     查找并替换字符串或字符<br>cut     从一个标记开始打印所指定列数据<br>sort    按字母或数字排序<br>uniq    删除一个文件中重复行<br>举个例子，一次使用所有命令：</p>
<h1 id="ifconfig-sed-‘s-g’-cut-d”-“-f1-uniq-grep-E-“-a-z0-9-”-sort-r"><a href="#ifconfig-sed-‘s-g’-cut-d”-“-f1-uniq-grep-E-“-a-z0-9-”-sort-r" class="headerlink" title="ifconfig | sed ‘s/  / /g’ | cut -d” “ -f1 | uniq | grep -E “[a-z0-9]+” | sort -r"></a>ifconfig | sed ‘s/  / /g’ | cut -d” “ -f1 | uniq | grep -E “[a-z0-9]+” | sort -r</h1><h1 id="ifconfig-sed-‘-inet-addr-d-s-s-‘-sort-t-k1-1n-k2-2n-k3-3n-k4-4n"><a href="#ifconfig-sed-‘-inet-addr-d-s-s-‘-sort-t-k1-1n-k2-2n-k3-3n-k4-4n" class="headerlink" title="ifconfig | sed ‘/.inet addr:/!d;s///;s/ .//‘|sort -t. -k1,1n -k2,2n -k3,3n -k4,4n"></a>ifconfig | sed ‘/.<em>inet addr:/!d;s///;s/ .</em>//‘|sort -t. -k1,1n -k2,2n -k3,3n -k4,4n</h1><p>sed 的模式字符串中的第一个字符是一个 tab。要在命令控制台中输入 tab，可以使用 ctrl-v ctrl-tab。<br>bash</p>
<p>Bash、sh 的重定向和管道：</p>
<h1 id="cmd-1-gt-file-重定向标准输出到-file。"><a href="#cmd-1-gt-file-重定向标准输出到-file。" class="headerlink" title="cmd 1&gt; file                         # 重定向标准输出到 file。"></a>cmd 1&gt; file                         # 重定向标准输出到 file。</h1><h1 id="cmd-2-gt-file-重定向标准错误输出到-file。"><a href="#cmd-2-gt-file-重定向标准错误输出到-file。" class="headerlink" title="cmd 2&gt; file                         # 重定向标准错误输出到 file。"></a>cmd 2&gt; file                         # 重定向标准错误输出到 file。</h1><h1 id="cmd-1-gt-gt-file-重定向标准输出并追加到-file。"><a href="#cmd-1-gt-gt-file-重定向标准输出并追加到-file。" class="headerlink" title="cmd 1&gt;&gt; file                        # 重定向标准输出并追加到 file。"></a>cmd 1&gt;&gt; file                        # 重定向标准输出并追加到 file。</h1><h1 id="cmd-amp-gt-file-重定向标准输出和标准错误输出到-file。"><a href="#cmd-amp-gt-file-重定向标准输出和标准错误输出到-file。" class="headerlink" title="cmd &amp;&gt; file                         # 重定向标准输出和标准错误输出到 file。"></a>cmd &amp;&gt; file                         # 重定向标准输出和标准错误输出到 file。</h1><h1 id="cmd-gt-file-2-gt-amp-1-重定向标准错误输出到标准输出然后重定向到-file。"><a href="#cmd-gt-file-2-gt-amp-1-重定向标准错误输出到标准输出然后重定向到-file。" class="headerlink" title="cmd &gt;file 2&gt;&amp;1                      # 重定向标准错误输出到标准输出然后重定向到 file。"></a>cmd &gt;file 2&gt;&amp;1                      # 重定向标准错误输出到标准输出然后重定向到 file。</h1><h1 id="cmd1-cmd2-cmd1-的输出通过管道连接到-cmd2-的输入"><a href="#cmd1-cmd2-cmd1-的输出通过管道连接到-cmd2-的输入" class="headerlink" title="cmd1 | cmd2                         # cmd1 的输出通过管道连接到 cmd2 的输入"></a>cmd1 | cmd2                         # cmd1 的输出通过管道连接到 cmd2 的输入</h1><h1 id="cmd1-2-gt-amp-1-cmd2-cmd1-的输出和错误输出通过管道连接到-cmd2-的输入"><a href="#cmd1-2-gt-amp-1-cmd2-cmd1-的输出和错误输出通过管道连接到-cmd2-的输入" class="headerlink" title="cmd1 2&gt;&amp;1 | cmd2                    # cmd1 的输出和错误输出通过管道连接到 cmd2 的输入"></a>cmd1 2&gt;&amp;1 | cmd2                    # cmd1 的输出和错误输出通过管道连接到 cmd2 的输入</h1><p>修改你的配置文件 ~/.bashrc (也可以是 ~/.bash_profile)。下列条目非常有用，使用”. .bashrc”重新加载。</p>
<h1 id="in-bashrc"><a href="#in-bashrc" class="headerlink" title="in .bashrc"></a>in .bashrc</h1><p>bind ‘“\e[A”‘:history-search-backward # 使用上下键查找<br>bind ‘“\e[B”‘:history-search-forward  # 历史命令。无价之宝!<br>set -o emacs                          # Set emacs mode in bash (看下面)<br>set bell-style visible                # Do not beep, inverse colors</p>
<pre><code># 设置一个漂亮的提示符像 [user@host]/path/todir&gt;
</code></pre><p>PS1=”[\033[1;30m][[\033[1;34m]\u[\033[1;30m]“<br>PS1=”$PS1@[\033[0;33m]\h[\033[1;30m]][\033[0;37m]“<br>PS1=”$PS1\w[\033[1;30m]&gt;[\033[0m]“</p>
<h1 id="要检查当前可用别名-alias-，只需简单输入命令-alias"><a href="#要检查当前可用别名-alias-，只需简单输入命令-alias" class="headerlink" title="要检查当前可用别名(alias)，只需简单输入命令 alias"></a>要检查当前可用别名(alias)，只需简单输入命令 alias</h1><p>alias  ls=’ls -aF’                    # 添加指示符(*/=&gt;@| 其中之一)<br>alias  ll=’ls -aFls’                  # 清单<br>alias  la=’ls -all’<br>alias ..=’cd ..’<br>alias …=’cd ../..’<br>export HISTFILESIZE=5000              # 巨大的历史记录<br>export CLICOLOR=1                     # 使用颜色(如果可用)<br>export LSCOLORS=ExGxFxdxCxDxDxBxBxExEx<br>tcsh</p>
<p>Tcsh、csh 的重定向和管道(&gt; 和 &gt;&gt; 同 sh 中一样)：</p>
<h1 id="cmd-gt-amp-file-重定向标准输出和标准错误输出到-file。"><a href="#cmd-gt-amp-file-重定向标准输出和标准错误输出到-file。" class="headerlink" title="cmd &gt;&amp; file                         # 重定向标准输出和标准错误输出到 file。"></a>cmd &gt;&amp; file                         # 重定向标准输出和标准错误输出到 file。</h1><h1 id="cmd-gt-gt-amp-file-追加标准输出和标准错误输出到-file。"><a href="#cmd-gt-gt-amp-file-追加标准输出和标准错误输出到-file。" class="headerlink" title="cmd &gt;&gt;&amp; file                        # 追加标准输出和标准错误输出到 file。"></a>cmd &gt;&gt;&amp; file                        # 追加标准输出和标准错误输出到 file。</h1><h1 id="cmd1-cmd2-cmd1-的输出通过管道连接到-cmd2-的输入-1"><a href="#cmd1-cmd2-cmd1-的输出通过管道连接到-cmd2-的输入-1" class="headerlink" title="cmd1 | cmd2                         # cmd1 的输出通过管道连接到 cmd2 的输入"></a>cmd1 | cmd2                         # cmd1 的输出通过管道连接到 cmd2 的输入</h1><h1 id="cmd1-amp-cmd2-cmd1-的输出和错误输出通过管道连接到-cmd2-的输入"><a href="#cmd1-amp-cmd2-cmd1-的输出和错误输出通过管道连接到-cmd2-的输入" class="headerlink" title="cmd1 |&amp; cmd2                        # cmd1 的输出和错误输出通过管道连接到 cmd2 的输入"></a>cmd1 |&amp; cmd2                        # cmd1 的输出和错误输出通过管道连接到 cmd2 的输入</h1><p>Csh/tcsh 的设置在 ~/.cshrc 中，使用”source .cshrc”来重新加载。例子：</p>
<h1 id="in-cshrc"><a href="#in-cshrc" class="headerlink" title="in .cshrc"></a>in .cshrc</h1><p>alias  ls      ‘ls -aF’<br>alias  ll      ‘ls -aFls’<br>alias  la      ‘ls -all’<br>alias  ..      ‘cd ..’<br>alias  …     ‘cd ../..’<br>set   prompt    = “%B%n%b@%B%m%b%/&gt; “ # 像 user@host/path/todir&gt;<br>set   history   =  5000<br>set   savehist  = ( 6000 merge )<br>set   autolist                        # 控制命令补全和变量补全<br>set   visiblebell                     # 使用闪动屏幕的方式来取代蜂鸣器鸣叫</p>
<h1 id="Bindkey-和颜色"><a href="#Bindkey-和颜色" class="headerlink" title="Bindkey 和颜色"></a>Bindkey 和颜色</h1><p>bindkey -e     Select Emacs bindings  # 将命令行编辑器切换到emacs模式<br>bindkey -k up history-search-backward # 使用上下键来搜索<br>bindkey -k down history-search-forward<br>setenv CLICOLOR 1                     # 使用颜色(可能的话)<br>setenv LSCOLORS ExGxFxdxCxDxDxBxBxExEx<br>该 emacs 模式将使用 emacs 快捷键来修改命令提示行。这是非常有用的(不单为 Emacs 用户)。最常用的命令如下：<br>C-a       移动光标到行头<br>C-e       移动光标到行尾<br>M-b       移动光标到前一个单词<br>M-f       移动光标到后一个单词<br>M-d       剪切下一个单词<br>C-w       剪切最后一个单词<br>C-u       剪切光标前所有字符<br>C-k       剪切光标后所有字符<br>C-y       粘帖最后剪切的字符(简易的粘帖)<br>C-_       重做<br>注意: C- = 按住 control 键，M- = 按住 meta (它通常为 alt 或者 escape)键。<br>脚本</p>
<p>基础 | 脚本实例 | sed/实用命令</p>
<p>Bourne shell (/bin/sh) 存在于所有的 Unix 系统上，并且用她写的脚本是(完全)可移植的； man 1 sh 是一个好的参考。<br>基础</p>
<p>变量和参数</p>
<p>使用 variable=value 的命令格式设置变量，其中 variable 是变量名称，value是打算赋给该变量的值。使用 $variable 获取变量值。<br>MESSAGE=”Hello World”                        # 赋予一个字符串<br>PI=3.1415                                    # 赋予一个十进制小数<br>N=8<br>TWON=<code>expr $N * 2</code>                           # 算术表达式(只限整数)<br>TWON=$(($N <em> 2))                             # 另一种语法<br>TWOPI=`echo “$PI </em> 2” | bc -l<code># 使用 bc 进行浮点运算
ZERO=</code>echo “c($PI/4)-sqrt(2)/2” | bc -l`<br>命令行参数：<br>$0, $1, $2, …                              # $0 命令本身<br>$#                                           # 命令参数个数<br>$*                                           # 所有参数(也可以是 $@)<br>一些特殊的变量</p>
<p>$$                                           # 当前进程 ID<br>$?                                           # 最后命令退出状态码<br>  command<br>  if [ $? != 0 ]; then<br>    echo “command failed”<br>  fi<br>mypath=<code>pwd</code><br>mypath=${mypath}/file.txt<br>echo ${mypath##<em>/}                           # 只显示文件名<br>echo ${mypath%%.</em>}                           # 除了扩展名的全路径<br>var2=${var:=string}                          # 如果var没有被赋值，则string值先赋值给var，</p>
<pre><code># 然后再赋值给var2
</code></pre><p>结构控制</p>
<p>for file in <code>ls</code><br>do<br>    echo $file<br>done</p>
<p>count=0<br>while [ $count -lt 5 ]; do<br>    echo $count<br>    sleep 1<br>    count=$(($count + 1))<br>done</p>
<p>myfunction() {<br>    find . -type f -name “*.$1” -print       # $1 为方法的第一个参数<br>}<br>myfunction “txt”<br>产生一个文件</p>
<p>MYHOME=/home/colin<br>cat &gt; testhome.sh &lt;&lt; _EOF</p>
<h1 id="所有-EOF前的代码都会进入到-testhome-sh-文件中去"><a href="#所有-EOF前的代码都会进入到-testhome-sh-文件中去" class="headerlink" title="所有_EOF前的代码都会进入到 testhome.sh 文件中去"></a>所有_EOF前的代码都会进入到 testhome.sh 文件中去</h1><p>if [ -d “$MYHOME” ] ; then<br>    echo $MYHOME exists<br>else<br>    echo $MYHOME does not exist<br>fi<br>_EOF<br>sh testhome.sh<br>Bourne 脚本实例</p>
<p>来一个小实例，此脚本从本 xhtml 文档创建一个 PDF 小册子：</p>
<p>#!/bin/sh</p>
<h1 id="此脚本可以创建一份供双面打印机打印的-PDF-格式的书"><a href="#此脚本可以创建一份供双面打印机打印的-PDF-格式的书" class="headerlink" title="此脚本可以创建一份供双面打印机打印的 PDF 格式的书"></a>此脚本可以创建一份供双面打印机打印的 PDF 格式的书</h1><p>if [ $# -ne 1 ]; then                        # 检查参数是否等于 1<br>  echo 1&gt;&amp;2 “Usage: $0 HtmlFile”<br>  exit 1                                     # 如果不等于1，非0退出<br>fi</p>
<p>file=$1                                      # 文件变量<br>fname=${file%.<em>}                             # 文件名变量<br>fext=${file#</em>.}                              # 文件扩展名变量</p>
<p>prince $file -o $fname.pdf                   # www.princexml.com<br>pdftops -paper A4 -noshrink $fname.pdf $fname.ps # 创建 postscript 小册子<br>cat $fname.ps |psbook|psnup -Pa4 -2 |pstops -b “2:0,1U(21cm,29.7cm)” &gt; $fname.book.ps</p>
<p>ps2pdf13 -sPAPERSIZE=a4 -sAutoRotatePages=None $fname.book.ps $fname.book.pdf</p>
<pre><code># 在 Windows 上使用 #a4 和 #None!
</code></pre><p>exit 0                                       # exit 0 意为成功<br>一些 sed 命令</p>
<p>这里是单行 sed 命令的金矿。还有一个很好的 sed 介绍及教程。<br>sed ‘s/string1/string2/g’                    # 替换 string1 为 string2<br>sed -i ‘s/wroong/wrong/g’ <em>.txt              # 用 g 替换所有返回的单词<br>sed ‘s/(.</em>)1/\12/g’                        # 修改 anystring1 为 anystring2<br>sed ‘/</p><p>/,/&lt;\/p&gt;/d’ t.xhtml                 # 删除以 </p><p> 开始，以 </p> 结尾的行<br>sed ‘/ <em>#/d; /^ </em>$/d’                        # 删除注释和空行<br>sed ‘s/[ \t]<em>$//‘                            # 删除行尾空格 (使用 tab 代替 \t)<br>sed ‘s/^[ \t]</em>//;s/[ \t]<em>$//‘                # 删除行头尾空格<br>sed ‘s/[^</em>]/[&amp;]/‘                            # 括住首字符 [] top -&gt; [t]op<br>sed = file | sed ‘N;s/\n/\t/‘ &gt; file.num     # 为文件添加行号<br>正则表达式<p></p>
<p>一些基本的正则表达式同样可用于 sed。作为一个良好的启蒙，可看 基本正则语法。<br>[\^$.|?*+()                          # 特殊字符，其他字符将匹配自身<br>\                                    # 转义特殊字符，当成普通字符对待</p>
<ul>
<li><h1 id="重复前项-0-次或多次"><a href="#重复前项-0-次或多次" class="headerlink" title="重复前项 0 次或多次"></a>重复前项 0 次或多次</h1>.                                    # 单个字符除换行符<br>.*                                   # 匹配 0 个或多个字符<br>^                                    # 匹配字符串行开始处<br>$                                    # 匹配字符串行结尾处<br>.$                                   # 匹配字符串行最后一个字符<br>^ $                                  # 匹配单个空格的行<br>[^A-Z]                               # 匹配任何以 A-Z 字符开始的行<br>一些实用命令</li>
</ul>
<p>下列命令对于包含于一个脚本或者单行命令来说很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sort -t. -k1,1n -k2,2n -k3,3n -k4,4n         # 排序 IPv4 格式的 IP 地址</span><br><span class="line">echo &apos;Test&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;     # 转换成大写</span><br><span class="line">echo foo.bar | cut -d . -f 1                 # 返回 foo</span><br><span class="line">PID=$(ps | grep script.sh | grep bin | awk &apos;&#123;print $1&#125;&apos;)          # 正在运行名为 script 脚本的 PID</span><br><span class="line">PID=$(ps axww | grep [p]ing | awk &apos;&#123;print $1&#125;&apos;)                   # ping 的 PID (w/o grep pid)</span><br><span class="line">IP=$(ifconfig $INTERFACE | sed &apos;/.*inet addr:/!d;s///;s/ .*//&apos;)   # Linux</span><br><span class="line">IP=$(ifconfig $INTERFACE | sed &apos;/.*inet /!d;s///;s/ .*//&apos;)        # FreeBSD</span><br><span class="line">if [ `diff file1 file2 | wc -l` != 0 ]; then [...] fi             # 文件改变了？</span><br><span class="line">cat /etc/master.passwd | grep -v root | grep -v \*: | awk -F&quot;:&quot; \ # 创建 http passwd</span><br><span class="line">&apos;&#123; printf(&quot;%s:%s\n&quot;, $1, $2) &#125;&apos; &gt; /usr/local/etc/apache2/passwd</span><br><span class="line"></span><br><span class="line">testuser=$(cat /usr/local/etc/apache2/passwd | grep -v \    # 查看 passwd 中的用户</span><br><span class="line">root | grep -v \*: | awk -F&quot;:&quot; &apos;&#123; printf(&quot;%s\n&quot;, $1) &#125;&apos; | grep ^user$)</span><br><span class="line">:()&#123; :|:&amp; &#125;;:                                # bash fork 炸弹。会干掉你的机器</span><br><span class="line">tail +2 file &gt; file2                         # 删除文件的第一行</span><br></pre></td></tr></table></figure>
<p>我使用一种小伎俩来一次更改许多文件的扩展名。举个例子，从 .cxx 到 .cpp。排除最后的 | sh 先测试一下。你同样可以使用命令 rename 来做这些，如果安装了的话。或者使用 bash 内建命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls *.cxx | awk -F. &apos;&#123;print &quot;mv &quot;$0&quot; &quot;$1&quot;.cpp&quot;&#125;&apos; | sh</span><br><span class="line"># ls *.c | sed &quot;s/.*/cp &amp; &amp;.$(date &quot;+%Y%m%d&quot;)/&quot; | sh # 如 拷贝 *.c 成 *.c.20080401</span><br><span class="line"># rename .cxx .cpp *.cxx                             # 重命名所有 .cxx 成 .cpp</span><br><span class="line"># for i in *.cxx; do mv $i $&#123;i%%.cxx&#125;.cpp; done      # bash 内建的</span><br></pre></td></tr></table></figure>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C 基础"></a>C 基础</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strcpy(newstr,str)                        /* 拷贝 str 到 newstr */</span><br><span class="line">expr1 ? expr2 : expr3                     /* if (expr1) expr2 else expr3 */</span><br><span class="line">x = (y &gt; z) ? y : z;                      /* if (y &gt; z) x = y; else x = z; */</span><br><span class="line">int a[]=&#123;0,1,2&#125;;                          /* 初始化数组 (或者 a[3]=&#123;0,1,2&#125;; */</span><br><span class="line">int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;            /* 初始化二维数组 */</span><br><span class="line">int i = 12345;                            /* 从 i 转换成 char str */</span><br><span class="line">char str[10];</span><br><span class="line">sprintf(str, &quot;%d&quot;, i);</span><br></pre></td></tr></table></figure>
<h2 id="C-实例"><a href="#C-实例" class="headerlink" title="C 实例"></a>C 实例</h2><p>一个最小化的 C 程式 simple.c：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">main() &#123;</span><br><span class="line">    int number=42;</span><br><span class="line">    printf(&quot;The answer is %i\n&quot;, number);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># gcc simple.c -o simple</span><br><span class="line"># ./simple</span><br><span class="line">The answer is 42</span><br></pre></td></tr></table></figure></p>
<h2 id="C-基础-1"><a href="#C-基础-1" class="headerlink" title="C++ 基础"></a>C++ 基础</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*pointer                                  // 指向对象的指针</span><br><span class="line">&amp;obj                                      // 对象 obj 的地址</span><br><span class="line">obj.x                                     // 类(对象) obj 成员 x</span><br><span class="line">pobj-&gt;x                                   // 指针 pobj 指向类(对象)成员 x</span><br><span class="line">                                          // (*pobj).x 同 pobj-&gt;x</span><br></pre></td></tr></table></figure>
<h2 id="C-实例-1"><a href="#C-实例-1" class="headerlink" title="C++ 实例"></a>C++ 实例</h2><p>来一个稍微现实一点的 C++ 程序，我们在一个头文件(IPv4.h)中创建一个类并且实现它(IPv4.cpp)，然后创建一个程式来使用其功能。这个类的成员方法实现了 IP 地址从一串整数转换成我们熟知的点分格式。这是一个最小化的 C++ 程式和多源文件(multi-source)的编译。<br>IPv4 class</p>
<p>IPv4.h:</p>
<p>#ifndef IPV4_H</p>
<p>#define IPV4_H</p>
<p>#include <string></string></p>
<p>namespace GenericUtils {                          // 创建 namespace<br>class IPv4 {                                      // 类定义<br>public:<br>    IPv4();<br>    ~IPv4();<br>    std::string IPint_to_IPquad(unsigned long ip);// 成员方法接口<br>};<br>} //namespace GenericUtils</p>
<p>#endif // IPV4_H<br>IPv4.cpp:</p>
<p>#include “IPv4.h”</p>
<p>#include <string></string></p>
<p>#include <sstream><br>using namespace std;                              // 使用 namespace<br>using namespace GenericUtils;</sstream></p>
<p>IPv4::IPv4() {}                                   // 默认构造/析构函数<br>IPv4::~IPv4() {}<br>string IPv4::IPint_to_IPquad(unsigned long ip) {  // 成员方法实现<br>    ostringstream ipstr;                          // 使用字符串流<br>    ipstr &lt;&lt; ((ip &amp;0xff000000) &gt;&gt; 24)             // 位右移<br>          &lt;&lt; “.” &lt;&lt; ((ip &amp;0x00ff0000) &gt;&gt; 16)<br>          &lt;&lt; “.” &lt;&lt; ((ip &amp;0x0000ff00) &gt;&gt; 8)<br>          &lt;&lt; “.” &lt;&lt; ((ip &amp;0x000000ff));<br>    return ipstr.str();<br>}<br>程序 simplecpp.cpp</p>
<p>#include “IPv4.h”</p>
<p>#include <iostream></iostream></p>
<p>#include <string><br>using namespace std;</string></p>
<p>int main (int argc, char* argv[]) {<br>    string ipstr;                                 // 定义变量<br>    unsigned long ipint = 1347861486;             // 数字形式的 IP<br>    GenericUtils::IPv4 iputils;                   // 创建一个类的对象<br>    ipstr = iputils.IPint_to_IPquad(ipint);       // 调研类的成员方法<br>    cout &lt;&lt; ipint &lt;&lt; “ = “ &lt;&lt; ipstr &lt;&lt; endl;      // 输出结果</p>
<pre><code>return 0;
</code></pre><p>}<br>编译和执行：</p>
<h1 id="g-c-IPv4-cpp-simplecpp-cpp-编译成目标文件"><a href="#g-c-IPv4-cpp-simplecpp-cpp-编译成目标文件" class="headerlink" title="g++ -c IPv4.cpp simplecpp.cpp                # 编译成目标文件"></a>g++ -c IPv4.cpp simplecpp.cpp                # 编译成目标文件</h1><h1 id="g-IPv4-o-simplecpp-o-o-simplecpp-exe-连接目标代码，生成可执行文件"><a href="#g-IPv4-o-simplecpp-o-o-simplecpp-exe-连接目标代码，生成可执行文件" class="headerlink" title="g++ IPv4.o simplecpp.o -o simplecpp.exe      # 连接目标代码，生成可执行文件"></a>g++ IPv4.o simplecpp.o -o simplecpp.exe      # 连接目标代码，生成可执行文件</h1><h1 id="simplecpp-exe"><a href="#simplecpp-exe" class="headerlink" title="./simplecpp.exe"></a>./simplecpp.exe</h1><p>1347861486 = 80.86.187.238<br>使用 ldd 脚本检查并列出可执行程序所依赖的共享库文件。这个命令同样可以用来检查共享库的丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ldd /sbin/ifconfig</span><br></pre></td></tr></table></figure>
<h2 id="简单的-Makefile"><a href="#简单的-Makefile" class="headerlink" title="简单的 Makefile"></a>简单的 Makefile</h2><p>相应的最小化多源文件(multi-source)编译 Makefile 显示如下。每一个命令行必须以 tab 开始！可以将一个较长行使用反斜线”\”来分解为多行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CC = g++</span><br><span class="line">CFLAGS = -O</span><br><span class="line">OBJS = IPv4.o simplecpp.o</span><br><span class="line"></span><br><span class="line">simplecpp: $&#123;OBJS&#125;</span><br><span class="line">    $&#123;CC&#125; -o simplecpp $&#123;CFLAGS&#125; $&#123;OBJS&#125;</span><br><span class="line">clean:</span><br><span class="line">    rm -f $&#123;TARGET&#125; $&#123;OBJS&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在线帮助"><a href="#在线帮助" class="headerlink" title="在线帮助"></a>在线帮助</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>Linux 文档    en.tldp.org<br>Linux Man Pages www.linuxmanpages.com<br>Linux 命令目录  www.oreillynet.com/linux/cmd<br>Linux doc man howtos    linux.die.net<br>FreeBSD 手册  www.freebsd.org/handbook<br>FreeBSD Man Pages   www.freebsd.org/cgi/man.cgi<br>FreeBSD 用户 wiki www.freebsdwiki.net<br>Solaris Man Pages   docs.sun.com/app/docs/coll/40.10</p>
<h2 id="其他-Unix-Linux-参考"><a href="#其他-Unix-Linux-参考" class="headerlink" title="其他 Unix/Linux 参考"></a>其他 Unix/Linux 参考</h2><p>Rosetta Stone for Unix  bhami.com/rosetta.html (a Unix command translator)<br>Unix guide cross reference  unixguide.net/unixguide.shtml<br>Linux 命令行列表 www.linuxguide.it/commands_list.php<br>Short Linux reference   www.pixelbeat.org/cmdline.html<br>That’s all folks!</p>
<p>This document: “Unix Toolbox revision 12” is licensed under a Creative Commons Licence [Attribution - Share Alike]. © Colin Barschel and Greco Shi 2007-2008. Some rights reserved.</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/11/29/网址收藏夹/" class="next">网址收藏夹</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://zhanghuijun0.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/收藏/">收藏</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资源/">资源</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音频/">音频</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/镜像/" style="font-size: 15px;">镜像</a> <a href="/tags/网址/" style="font-size: 15px;">网址</a> <a href="/tags/teahour/" style="font-size: 15px;">teahour</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/29/UNIX-TOOLBOX中文版/">UNIX-TOOLBOX中文版</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/29/网址收藏夹/">网址收藏夹</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/18/国内镜像/">国内镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/teahour中文技术广播📢/">teahour中文技术广播📢</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zhanghuijun0/" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://tool.lu/" title="在线工具 - 程序员的工具箱" target="_blank">在线工具 - 程序员的工具箱</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Hexo Blogs.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>